<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Go - Tag - 我的全新 Hugo 网站</title>
        <link>http://example.org/tags/go/</link>
        <description>Go - Tag - 我的全新 Hugo 网站</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 23 Apr 2023 23:21:42 &#43;0000</lastBuildDate><atom:link href="http://example.org/tags/go/" rel="self" type="application/rss+xml" /><item>
    <title>Go语言将Map数据写入EXCEL文件</title>
    <link>http://example.org/go%E8%AF%AD%E8%A8%80%E5%B0%86map%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5excel%E6%96%87%E4%BB%B6/</link>
    <pubDate>Sun, 23 Apr 2023 23:21:42 &#43;0000</pubDate>
    <author>五彩斑斓的黑</author>
    <guid>http://example.org/go%E8%AF%AD%E8%A8%80%E5%B0%86map%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5excel%E6%96%87%E4%BB%B6/</guid>
    <description><![CDATA[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 package main import ( &#34;fmt&#34; &#34;strconv&#34; &#34;time&#34; &#34;github.]]></description>
</item>
<item>
    <title>解决离线环境下go语言项目依赖问题</title>
    <link>http://example.org/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/</link>
    <pubDate>Fri, 14 Apr 2023 22:16:06 &#43;0000</pubDate>
    <author>五彩斑斓的黑</author>
    <guid>http://example.org/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/</guid>
    <description><![CDATA[思路： 实现原理：GOPROXY变量可以设置为本地目录的特点。 以下为实现方法（均为Windows系统）
联网电脑上的操作 目的：将需要的包下载到移动硬盘
在移动硬盘根目录新建gomods文件夹； 使用set GOPATH=x:\gomods将GOPATH临时设置为x:\gomods， 新建一个项目（for_dl_mods）并初始化，在该项目中将需要的依赖写进去，如下： 1 2 3 4 5 6 7 package main import ( // `_`意思只导入不使用 _ &#34;github.com/gocolly/colly&#34; _ &#34;github.com/tidwall/gjson&#34; ) 在该目录下使用go mod download命令，将会自动下载colly等依赖及其子依赖到x:\gomods下， 离线电脑上的操作 目的：将需要的包从移动硬盘自动复制到本地gopath中，并自动整理go.mod和go.sum两个文件。 4. 将移动硬盘插入离线机器， 5. 使用set GOPROXY=file:///x:\gomods\cache\download将获取依赖的服务器指向本地目录(注意：file后面是三个/，路径使用\符号) 6. 在开发的目录中运行go mod tidy。
第4、5步需要保持移动硬盘插在离线电脑上，如果不想这样，可以先从移动硬盘复制到离线电脑的本地磁盘，再相应改GOPROXY指向地址。
以上仍没有解决，因为go mod tidy会将下载的包与go官方进行一次哈希校验如下：
1 2 3 4 5 6 7 main imports github.com/gocolly/colly: github.com/gocolly/colly@v1.2.0: verifying module: github.com/gocolly/colly@v1.2.0: Get &#34;https://sum.golang.org/lookup/github.com/gocolly/colly@v1.2.0&#34;: dial tcp 142.251.42.241:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.]]></description>
</item>
<item>
    <title>Golang的网络请求库req学习笔记</title>
    <link>http://example.org/golang%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93req%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
    <pubDate>Wed, 12 Apr 2023 18:21:01 &#43;0000</pubDate>
    <author>五彩斑斓的黑</author>
    <guid>http://example.org/golang%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93req%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
    <description><![CDATA[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 package main import ( &#34;fmt&#34; &#34;net/http&#34; &#34;strings&#34; &#34;sync&#34; &#34;time&#34; &#34;github.]]></description>
</item>
<item>
    <title>Colly学习笔记</title>
    <link>http://example.org/colly%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
    <pubDate>Tue, 11 Apr 2023 22:20:56 &#43;0000</pubDate>
    <author>五彩斑斓的黑</author>
    <guid>http://example.org/colly%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
    <description><![CDATA[go语言爬虫框架Colly学习 https://darjun.github.io/2021/06/30/godailylib/colly/ 以下代码是自己结合ChatGPT的回答与测试的结果。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 package main import ( &#34;fmt&#34; &#34;log&#34; &#34;net/http&#34; &#34;net/http/cookiejar&#34; &#34;net/url&#34; &#34;strings&#34; &#34;time&#34; &#34;github.]]></description>
</item>
<item>
    <title>Python和Golang超大文本文件处理</title>
    <link>http://example.org/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</link>
    <pubDate>Tue, 20 Dec 2022 15:26:31 &#43;0000</pubDate>
    <author>五彩斑斓的黑</author>
    <guid>http://example.org/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</guid>
    <description><![CDATA[Python Python中迭代读取超大文本文件，每次读取1000行。 在python中，我们可以使用yield关键字和for循环实现迭代读取超大文本文件，每次读取1000行。
例如，我们可以定义一个函数read_lines_by_1000()，每次yield 1000行的数据：
1 2 3 4 5 6 7 8 9 def read_lines_by_1000(filename): with open(filename, &#39;r&#39;) as f: lines = [] for line in f: lines.append(line) if len(lines) == 1000: yield lines lines = [] yield lines 然后，我们可以使用for循环迭代读取超大文本文件：
1 2 3 4 filename = &#39;data.txt&#39; for lines in read_lines_by_1000(filename): print(lines) # 处理lines中的数据 有比这个效率更高的方法吗 这样就可以在python中迭代读取超大文本文件，每次读取1000行了。 使用yield关键字和for循环迭代读取超大文本文件，每次读取1000行的方法已经是目前效率最高的方法之一。
如果想要提升效率，还可以考虑以下几种方法：
尽量使用内存映射文件读取超大文本文件，这样可以避免将数据从磁盘读取到内存中，从而提升读取速度。
尽量使用多线程读取超大文本文件，从而提升读取速度。
尽量使用多进程读取超大文本文件，从而提升读取速度。
尽量使用单个较大的缓冲区读取超大文本文件，从而提升读取速度。
需要注意的是，使用上述方法时可能会带来一些问题，例如内存占用过大，多线程/多进程同步问题等。因此，需要根据实际情况选择适合的方法。
python如何正确处理超大文本文件，防止内存吃不消。 在python中，可以使用以下几种方法正确处理超大文本文件，防止内存吃不消：
使用yield关键字和for循环迭代读取超大文本文件，每次读取一定数量的行。这样可以避免将整个文件一次性读取到内存中，从而防止内存吃不消。
使用内存映射文件读取超大文本文件。这样可以避免将数据从磁盘读取到内存中，从而防止内存吃不消。
使用多线程/多进程读取超大文本文件。这样可以分担读取超大文本文件的负担，从而防止内存吃不消。
使用单个较大的缓冲区读取超大文本文件。这样可以减少读取超大文本文件时的系统调用次数，从而提升读取速度，防止内存吃不消。]]></description>
</item>
<item>
    <title>GO语言学习历程</title>
    <link>http://example.org/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/</link>
    <pubDate>Thu, 13 Jan 2022 22:33:24 &#43;0000</pubDate>
    <author>五彩斑斓的黑</author>
    <guid>http://example.org/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/</guid>
    <description><![CDATA[GO语言教程 - 菜鸟教程
中国最可靠的 Go 模块代理
《365 天深入理解 Go 语言》
《Golang 学习资源大全》]]></description>
</item>
</channel>
</rss>
