<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>编程 - Tag - 我的全新 Hugo 网站</title>
        <link>http://example.org/tags/%E7%BC%96%E7%A8%8B/</link>
        <description>编程 - Tag - 我的全新 Hugo 网站</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 02 Mar 2022 22:12:44 &#43;0000</lastBuildDate><atom:link href="http://example.org/tags/%E7%BC%96%E7%A8%8B/" rel="self" type="application/rss+xml" /><item>
    <title>Python pip 离线安装 package 方法总结（以 TensorFlow 为例）</title>
    <link>http://example.org/python-pip-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85-package-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%BB%A5-tensorflow-%E4%B8%BA%E4%BE%8B/</link>
    <pubDate>Wed, 02 Mar 2022 22:12:44 &#43;0000</pubDate>
    <author>五彩斑斓的黑</author>
    <guid>http://example.org/python-pip-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85-package-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%BB%A5-tensorflow-%E4%B8%BA%E4%BE%8B/</guid>
    <description><![CDATA[文章背景 Python 环境安装 package，一般采用 pip 命令在线从 PyPI 是安装，这也是最方便的途径。但在某些情况下，要为一台离线的机器（比如在内网运行的一台生产服务器）安装 package，根本就连不上 PyPI。当然，大厂一般都有内网 PyPI 代理，只要改一下 --index-url 参数即可；但若代理也没有，只能手工将所有依赖到的 package 离线下载下来，放到离线的机器上安装。
下面是说明了整个探索过程。最终总结的方法，直接看文末的 “推荐方法” 即可。
心路历程 手工下载 之前我只是傻了吧唧，将要安装的 package（比如 tensorflow）从 PyPI 网站手工下载下来，放到内网机器直接安装，当然立马就会报 xxx 依赖不存在导致安装失败；根据报错提示再到 PyPI 上再下载这个 xxx 的 package 安装。而这个 xxx 可能又依赖另外一个 yyy。如此反复，整个过程有 30 个左右的多层依赖，搞了一下午，痛苦不堪。
读取 requirement 后来，我发现这些 package 里面都有 requirements 的声明文件，于是我就先解压出来看 requirement，这样至少直接依赖的 package 一下子都知道了。总比根据报错再一个一个下载快了。
但这还是不行，诉诸网络，发现了 pip download 可以解决这个问题，不过实际操作中还是有不少问题，下面以 TensorFlow 的离线安装为例说明。
pip download 总的思路是:
在 online 机器，通过 pip download tensorflow 命令（与 pip install 的区别就是，前者只下载不安装），将要安装的 xxx_package 以及所有依赖都下载到本地]]></description>
</item>
<item>
    <title>Python执行JS的几种方式</title>
    <link>http://example.org/python%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</link>
    <pubDate>Wed, 16 Feb 2022 23:00:47 &#43;0000</pubDate>
    <author>五彩斑斓的黑</author>
    <guid>http://example.org/python%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</guid>
    <description><![CDATA[https://juejin.cn/post/7015603661225066532
1.PyExecJS 经测试，比js2py快5倍多
安装依赖
pip3 install PyExecJS
使用方式
add.js 文件
1 2 3 4 function add(a,b){ return a+b; } 复制代码 py 文件去调用
1 2 3 4 5 6 7 8 import execjs with open(&#39;add.js&#39;, &#39;r&#39;, encoding=&#39;UTF-8&#39;) as f: js_code = f.read() context = execjs.compile(js_code) result = context.call(&#34;add&#34;, 2, 3) // 参数一为函数名，参数二和三为函数的参数 print(result) 复制代码 运行
2.js2py 安装依赖库
pip3 install js2py
还是上面的 add.js 文件
python 调用
1 2 3 4 5 6 7 8 import js2py with open(&#39;add.]]></description>
</item>
<item>
    <title>GO语言学习历程</title>
    <link>http://example.org/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/</link>
    <pubDate>Thu, 13 Jan 2022 22:33:24 &#43;0000</pubDate>
    <author>五彩斑斓的黑</author>
    <guid>http://example.org/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/</guid>
    <description><![CDATA[GO语言教程 - 菜鸟教程
中国最可靠的 Go 模块代理
《365 天深入理解 Go 语言》
《Golang 学习资源大全》]]></description>
</item>
<item>
    <title>轻松理解 Python中 的 async-await 概念</title>
    <link>http://example.org/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3-python%E4%B8%AD-%E7%9A%84-async-await-%E6%A6%82%E5%BF%B5/</link>
    <pubDate>Sat, 27 Nov 2021 07:21:36 &#43;0000</pubDate>
    <author>五彩斑斓的黑</author>
    <guid>http://example.org/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3-python%E4%B8%AD-%E7%9A%84-async-await-%E6%A6%82%E5%BF%B5/</guid>
    <description><![CDATA[前言 写这篇文章是受 xinghun85 的这篇博客 的启发, 但是人家后面写的东西跳跃太快, 有点没看懂, 自己在此做一个补充.
我希望能用一个最平易近人的例子, 把 Python 协程中的 async/await 概念讲清楚, 希望能够帮助大家有一个形象化的认识.
注: 所有的讲解都在代码的注释里. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 from time import sleep, time def demo1(): &#34;&#34;&#34; 假设我们有三台洗衣机, 现在有三批衣服需要分别放到这三台洗衣机里面洗.]]></description>
</item>
<item>
    <title>python3异步编程async/await原理解释的比较详细的文章</title>
    <link>http://example.org/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/</link>
    <pubDate>Sat, 27 Nov 2021 07:06:09 &#43;0000</pubDate>
    <author>五彩斑斓的黑</author>
    <guid>http://example.org/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/</guid>
    <description><![CDATA[身为Python核心开发组的成员，我对于这门语言的各种细节充满好奇。尽管我很清楚自己不可能对这门语言做到全知全能，但哪怕是为了能够解决各种issue和参与常规的语言设计工作，我也觉得有必要试着接触和理解Python的内核，弄清楚在底层它是怎么工作的。
话虽如此，直到最近我才理解了Python3.5中async/await的工作机制。在此之前，对于async/await语法，我只知道Python3.3中的yield from和Python3.4中的asyncio让这个新语法得以在Python3.5中实现。由于日常工作中没有接触多少网络编程&ndash;asyncio的主要应用领域，虽然它可以做的远不止于此&ndash;我对async/await并没有关注太多。以代码来说，我知道：
1 yield from iterator (大体)等价于:
1 2 from x in iterator: yield x 而且我知道asyncio是个事件循环的框架，支持异步编程，还有这些术语所表示的(基本)意义。但未曾真正的深入研究async/await语法，分析从最基础的指令到实现代码语法功能的过程，我觉得并没有理解Python中的异步编程，这一点甚至让我心烦意乱。因此我决定花点时间弄明白这个语法的工作机制。鉴于我听到许多人说他们也不理解异步编程的工作机制，我写出了这篇论文(是的，这篇博文耗费时间之长，字数之多，让我妻子把它叫做论文)。
由于我希望对这个语法的工作机制有一个完整的理解，这篇论文中会出现涉及CPython的底层技术细节。如果你不关心这些细节，或者无法通过这篇文章完全理解这些细节&ndash;限于篇幅，我不可能详细解释CPython的每个细节，否则这篇文章就要变成一本书了(例如，如果你不知道代码对象具有标识位，那就别在意代码对象是什么，这不是这篇文章的重点)&ndash;那也没什么关系。在每个章节的最后，我都添加了一个概念明确的小结，因此如果你对某个章节的内容不感兴趣，那么可以跳过前面的长篇大论，直接阅读结论。
Python中协程(coroutine)的历史
根据维基百科，“协程是将多个低优先级的任务转换成统一类型的子任务，以实现在多个节点之间停止或唤醒程序运行的程序模块”。这句专业论述翻译成通俗易懂的话就是，“协程就是可以人为暂停执行的函数”。如果你觉得，“这听起来像是生成器(generators)”，那么你是对的。
生成器的概念在Python2.2时的PEP 255中(由于实现了遍历器的协议，生成器也被成为生成器遍历器)第一次被引入。主要受到了Icon语言的影响，生成器允许用户创建一个特殊的遍历器，在生成下一个值时，不会占用额外的内存，并且实现方式非常简单(当然，在自定义类中实现__iter__()和__next__()方法也可以达到不存储遍历器中所有值的效果，但也带来了额外的工作量)。举例来说，如果你想实现自己的range()函数，最直接的方式是创建一个整数数组：
1 2 3 4 5 6 7 8 def eager_range(up_to): &#34;&#34;&#34;创建一个从0到变量up_to的数组，不包括up_to&#34;&#34;&#34; sequence = [] index = [] while index &lt; up_to: sequence.append(index) index += 1 return sequence 简单直白，但这个函数的问题是，如果你需要的序列很大，比如0到一百万，你必须创建一个包含了所有整数的长度是一百万的数组。如果使用生成器，你就可以毫不费力的创建一个从0到上限前一个整数的生成器。所占用的内存也只是每次生成的一个整数。
1 2 3 4 5 6 def lazy_range(up_to): &#34;&#34;&#34;一个从0到变量up_to，不包括up_to的生成器&#34;&#34;&#34; index = 0 while index &lt; up_to: yield index index += 1 函数可以在遇到yield表达式时暂停执行&ndash;尽管yield直到Python2.]]></description>
</item>
</channel>
</rss>
