[{"categories":null,"content":"区别点 Markdown文件的frontmatter不同，需要转换； 可能插入超链接、图片链接不同，需要转换； ","date":"2023-07-26","objectID":"/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BBhugo%E6%96%B9%E6%B3%95/:1:0","tags":null,"title":"Hexo博客迁移Hugo方法","uri":"/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BBhugo%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"frontmatter转换 import yaml import os import glob import re def rename_key(dictionary, old_key, new_key): if old_key in dictionary: dictionary[new_key] = dictionary[old_key] del dictionary[old_key] def delete_key(dictionary, old_key): if old_key in dictionary: del dictionary[old_key] def check_and_increase_header_level(markdown_text): \"\"\" 检查Markdown文本中是否有1级标题，如果为true,增加标题的级别，同时要忽略代码块中的标题。 \"\"\" # Replace code blocks with placeholders code_block_regex = r\"```.*?```\" code_blocks = re.findall(code_block_regex, markdown_text, re.DOTALL) replaced_text = markdown_text placeholders = [] for i, code_block in enumerate(code_blocks): placeholder = f\"\u003cCODEBLOCK{i}\u003e\" placeholders.append(placeholder) replaced_text = replaced_text.replace(code_block, placeholder) # Check if there are level-1 headers level_1_headers = re.findall(r\"^# .*$\", replaced_text, re.MULTILINE) if level_1_headers: # Increase the level of the headers headers_regex = r\"^(#{1,6})(.*)$\" replaced_text = re.sub(headers_regex, lambda match: \"#\" + match.group(1) + match.group(2), replaced_text, flags=re.MULTILINE) # Replace placeholders with the original code blocks for placeholder, code_block in zip(placeholders, code_blocks): replaced_text = replaced_text.replace(placeholder, code_block) return replaced_text def read_markdown_with_frontmatter(md_file_path): \"\"\"读取markdown文件\"\"\" with open(md_file_path, 'r', encoding='utf-8') as file: # Read the entire file content md_content = file.read() # Split Frontmatter and Markdown content frontmatter, md_text = md_content.split(\"---\\n\", 2)[1:] # Parse Frontmatter using yaml frontmatter_data = yaml.safe_load(frontmatter) return frontmatter_data, md_text def write_markdown_with_frontmatter(md_file_path, frontmatter_data, md_text): \"\"\"合并frontmatter与正文后写文件\"\"\" # 排序frontmatter new_frontmatter = \"\" fields_order = [\"title\", \"date\", \"lastmod\", \"tags\", \"categories\", \"description\", \"hidden\", \"image\", \"license\", \"math\", \"comments\", \"draft\"] for field in fields_order: value = frontmatter_data.get(field) if value is not None: new_frontmatter += f\"{field}: {value}\\n\" else: new_frontmatter += f\"{field}: \\n\" md_text = check_and_increase_header_level(md_text) updated_md_content = f\"---\\n{new_frontmatter}---\\n{md_text}\" with open(md_file_path, 'w', encoding='utf-8') as file: # Write the updated content back to the file file.write(updated_md_content) def work(md_file_path): frontmatter_data, md_content = read_markdown_with_frontmatter(md_file_path) rename_key(frontmatter_data,'updated','lastmod') delete_key(frontmatter_data,'keywords') delete_key(frontmatter_data,\"top_img\") delete_key(frontmatter_data,\"highlight_shrink\") delete_key(frontmatter_data,\"cover\") delete_key(frontmatter_data,\"sticky\") frontmatter_data[\"image\"] = None frontmatter_data[\"math\"] = False frontmatter_data[\"license\"] = False frontmatter_data[\"hidden\"] = False frontmatter_data[\"comments\"] = False frontmatter_data[\"draft\"] = False # frontmatter_data[\"tags\"] = None # frontmatter_data[\"description\"] = None # frontmatter_data[\"categories\"] = None write_markdown_with_frontmatter(md_file_path, frontmatter_data, md_content) if __name__ == \"__main__\": files = glob.glob(os.path.join('posts', \"*.md\")) for file in files: try: work(file) except: print(file) ","date":"2023-07-26","objectID":"/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BBhugo%E6%96%B9%E6%B3%95/:2:0","tags":null,"title":"Hexo博客迁移Hugo方法","uri":"/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BBhugo%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"hugo主题收集 Stack：https://github.com/CaiJimmy/hugo-theme-stack 效果见： 如何优雅的从 Hexo 转移 Blog 到 Hugo HBS theme：https://hbs.razonyang.com/ ","date":"2023-07-26","objectID":"/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BBhugo%E6%96%B9%E6%B3%95/:3:0","tags":null,"title":"Hexo博客迁移Hugo方法","uri":"/hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BBhugo%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"为了搭建知识库网站，最近都在找一个合适的框架，需要满足以下几个要求： 方便移植：以文件或者sqlite数据库作为数据储存引擎； 多平台适用； 支持全文检索，且检索时命中关键词部分前后的文章内容会展示在搜索结果中； 支持在线增删改查，而不是像hexo、hugo等静态渲染的博客系统； 资源占用低。 最后被俺找到两个`go语言`(低资源占用的代名词)开发的博客系统：[`sonic`](https://github.com/go-sonic/sonic)和[`journey`](https://github.com/kabukky/journey) ","date":"2023-07-25","objectID":"/sonic%E5%8D%9A%E5%AE%A2%E8%AF%95%E7%94%A8/:0:0","tags":["博客"],"title":"sonic博客试用","uri":"/sonic%E5%8D%9A%E5%AE%A2%E8%AF%95%E7%94%A8/"},{"categories":null,"content":"journey 超级简陋，自定义项目较少。 ","date":"2023-07-25","objectID":"/sonic%E5%8D%9A%E5%AE%A2%E8%AF%95%E7%94%A8/:1:0","tags":["博客"],"title":"sonic博客试用","uri":"/sonic%E5%8D%9A%E5%AE%A2%E8%AF%95%E7%94%A8/"},{"categories":null,"content":"sonic sonic是中国人开发的，更易上手。功能较多，且因为作者是中国人，使用遇到问题交流起来无障碍。 ","date":"2023-07-25","objectID":"/sonic%E5%8D%9A%E5%AE%A2%E8%AF%95%E7%94%A8/:2:0","tags":["博客"],"title":"sonic博客试用","uri":"/sonic%E5%8D%9A%E5%AE%A2%E8%AF%95%E7%94%A8/"},{"categories":["科学上网"],"content":"https://github.com/2dust/v2rayN/issues/1366 ","date":"2023-07-21","objectID":"/vpn%E6%99%BA%E8%83%BD%E5%88%86%E6%B5%81/:0:0","tags":["VPN","科学上网"],"title":"VPN智能分流","uri":"/vpn%E6%99%BA%E8%83%BD%E5%88%86%E6%B5%81/"},{"categories":null,"content":"介绍 指导性文章 : Portable Mode in Visual Studio Code ","date":"2023-07-13","objectID":"/%E5%A6%82%E4%BD%95%E5%B0%86-vscode-%E5%8F%98%E6%88%90%E7%BB%BF%E8%89%B2%E7%89%88%E6%9C%AC/:1:0","tags":["VSCode"],"title":"如何将 VSCode 变成绿色版本","uri":"/%E5%A6%82%E4%BD%95%E5%B0%86-vscode-%E5%8F%98%E6%88%90%E7%BB%BF%E8%89%B2%E7%89%88%E6%9C%AC/"},{"categories":null,"content":"为什么要设置成绿色版 移植方便，到了新的电脑环境，直接拷贝文件夹就完成 VSCode 环境搭建 管理方便，原来的插件，配置文件不在一个地方，而且路径藏的过深 如图，绿色版本的结构很清晰，除了应用程序之外就是一个存放 扩展 (extensions) 和 用户数据 (user-data) 的 数据文件夹 (code-portable-data). 当我使用新的一台电脑的时候，只需要将 VSCode 文件夹 拷贝到新电脑就装有 相同配置，相同扩展的一模一样的 VSCode 编辑器，无需额外下载和配置. ","date":"2023-07-13","objectID":"/%E5%A6%82%E4%BD%95%E5%B0%86-vscode-%E5%8F%98%E6%88%90%E7%BB%BF%E8%89%B2%E7%89%88%E6%9C%AC/:2:0","tags":["VSCode"],"title":"如何将 VSCode 变成绿色版本","uri":"/%E5%A6%82%E4%BD%95%E5%B0%86-vscode-%E5%8F%98%E6%88%90%E7%BB%BF%E8%89%B2%E7%89%88%E6%9C%AC/"},{"categories":null,"content":"如何将 VSCode 编程绿色版本 ","date":"2023-07-13","objectID":"/%E5%A6%82%E4%BD%95%E5%B0%86-vscode-%E5%8F%98%E6%88%90%E7%BB%BF%E8%89%B2%E7%89%88%E6%9C%AC/:3:0","tags":["VSCode"],"title":"如何将 VSCode 变成绿色版本","uri":"/%E5%A6%82%E4%BD%95%E5%B0%86-vscode-%E5%8F%98%E6%88%90%E7%BB%BF%E8%89%B2%E7%89%88%E6%9C%AC/"},{"categories":null,"content":"第一种情况：从零开始配置 VSCode 下载压缩包 下载地址 : Download Visual Studio Code - Mac, Linux, Windows 最后一个支持Win7的版本：VSCode-win32-x64-1.70.3.zip 下载完毕，解压到任意文件夹 创建数据文件夹 (放置插件以及用户设置) Mac 在 VSCode 同一层级的目录下创建文件夹 code-portable-data Windows 在解压后的文件夹内 创建文件夹 data 绿色版制作完成 ","date":"2023-07-13","objectID":"/%E5%A6%82%E4%BD%95%E5%B0%86-vscode-%E5%8F%98%E6%88%90%E7%BB%BF%E8%89%B2%E7%89%88%E6%9C%AC/:3:1","tags":["VSCode"],"title":"如何将 VSCode 变成绿色版本","uri":"/%E5%A6%82%E4%BD%95%E5%B0%86-vscode-%E5%8F%98%E6%88%90%E7%BB%BF%E8%89%B2%E7%89%88%E6%9C%AC/"},{"categories":null,"content":"第二种情况：在 VSCode 已经有配置的前提下变成绿色版 下载压缩包 下载地址 : Download Visual Studio Code - Mac, Linux, Windows 最后一个支持Win7的版本：VSCode-win32-x64-1.70.3.zip 下载完毕，解压到任意文件夹 创建数据文件夹 (放置插件以及用户设置) Mac 在 VSCode 同一层级的目录下创建文件夹 code-portable-data Windows 在解压后的文件夹内 创建文件夹 data 拷贝已有的插件和用户数据到数据文件夹 用户数据默认路径 (剪切到第 2 步建立的数据文件夹下，将 Code 改名为 data) %APPDATA%\\Code 插件默认路径 (直接剪切到第 2 步建立的数据文件夹下) %USERPROFILE%\\.vscode\\extensions 版权声明：本文为 InfoQ 作者【lmymirror】的原创文章。 原文链接:【https://xie.infoq.cn/article/2c6dd3742d5daf4b2d0df20af】。文章转载请联系作者。 ","date":"2023-07-13","objectID":"/%E5%A6%82%E4%BD%95%E5%B0%86-vscode-%E5%8F%98%E6%88%90%E7%BB%BF%E8%89%B2%E7%89%88%E6%9C%AC/:3:2","tags":["VSCode"],"title":"如何将 VSCode 变成绿色版本","uri":"/%E5%A6%82%E4%BD%95%E5%B0%86-vscode-%E5%8F%98%E6%88%90%E7%BB%BF%E8%89%B2%E7%89%88%E6%9C%AC/"},{"categories":["Postgres","数据库"],"content":"psql的copy命令导入 ","date":"2023-07-07","objectID":"/postgres%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6/:1:0","tags":["Postgres","数据库","csv"],"title":"Postgres快速导入csv文件","uri":"/postgres%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6/"},{"categories":["Postgres","数据库"],"content":"第一步 连接数据库： psql -U \u003cuser_name\u003e -d \u003cdatabase_name\u003e -h 远程数据库IP地址 -p 端口， psql位于安装目录的bin目录下，建议将路径X:\\XXX\\PostgreSQL\\15\\bin\\添加到环境变量中 如果想免密码，则需要设置环境变量 PGPASSWORD ","date":"2023-07-07","objectID":"/postgres%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6/:1:1","tags":["Postgres","数据库","csv"],"title":"Postgres快速导入csv文件","uri":"/postgres%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6/"},{"categories":["Postgres","数据库"],"content":"第二步 使用\\copy命令导入，该命令必须在服务端运行，不能通过pg_admin、dbeaver等数据库管理客户端的sql命令执行。 \\copy bbb FROM 'D:\\NavicatExports\\aaa.csv' DELIMITER ',' NULL '' CSV HEADER; 其中bbb是事先创建好的表的名称，下同 ","date":"2023-07-07","objectID":"/postgres%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6/:1:2","tags":["Postgres","数据库","csv"],"title":"Postgres快速导入csv文件","uri":"/postgres%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6/"},{"categories":["Postgres","数据库"],"content":"常见错误 报错: ERROR: character with byte sequence 0xba 0x22 in encoding \"GBK\" has no equivalent in encoding \"UTF8\" 原因: csv文件内容为utf-8 no bom编码，其中有中文。 解决方案: \\encoding UTF8 ","date":"2023-07-07","objectID":"/postgres%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6/:1:3","tags":["Postgres","数据库","csv"],"title":"Postgres快速导入csv文件","uri":"/postgres%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6/"},{"categories":["Postgres","数据库"],"content":"其他 启用计时功能——可查看导入等操作的耗时 \\timing 切换数据库 \\c 目标数据库名 导入时的目标表名不能是中文，csv文件名可以是中文 通过实践，目标表名不能是中文，但文件名可以是中文。 \\copy bbb FROM 'C:\\我是中文.csv' WITH (FORMAT CSV,DELIMITER ',' , HEADER TRUE); csv文件的分隔符为Tab符的表达 \\copy bbb FROM 'C:\\我是中文.csv' WITH (FORMAT CSV,DELIMITER E'\\t' , HEADER TRUE); ","date":"2023-07-07","objectID":"/postgres%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6/:1:4","tags":["Postgres","数据库","csv"],"title":"Postgres快速导入csv文件","uri":"/postgres%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6/"},{"categories":["Postgres","数据库"],"content":"另外的方式 ","date":"2023-07-07","objectID":"/postgres%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6/:2:0","tags":["Postgres","数据库","csv"],"title":"Postgres快速导入csv文件","uri":"/postgres%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6/"},{"categories":["Postgres","数据库"],"content":"pgfutter–自动建表 专用于postgresql的导入工具pgfutter，支持 CSV 和 JSON 格式数据的导入。 使用方法： pgfutter --host \"地址\" --db \"数据库\" --port \"端口\" --user \"用户名\" --pw \"密码\" --schema \"public\" --table \"表名\" csv 待导入的csv文件.csv Database connection details can be provided via environment variables or as separate flags. 参数 默认值 含义 DB_NAME postgres database name DB_HOST localhost host name DB_PORT 5432 port DB_SCHEMA import schema to create tables for DB_USER postgres database user DB_PASS password (or empty if none) 更多用法参见官方文档 经测试，导入时对第一行最后一列为空的数据的数据导入出错。 ","date":"2023-07-07","objectID":"/postgres%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6/:2:1","tags":["Postgres","数据库","csv"],"title":"Postgres快速导入csv文件","uri":"/postgres%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6/"},{"categories":["Postgres","数据库"],"content":"pgloader 支持从文件加载或迁移数据库 其中数据库迁移包括： 从 MySQL 迁移到 PostgreSQL 从 SQLite 迁移到 PostgreSQL 从 MS SQL Server® 迁移到 PostgreSQL 其中文件包括： CSV 系列 固定列格式—作者也不清楚是什么 dBase 文件 ( db3) IBM IXF 文件 其他特色亮点 pgloader 支持存档格式zip、tar和gzip ：直接在临时文件中提取存档，然后加载扩展文件。 支持出错时停止或者出错时继续 缺点 导入参数必须通过脚本文件定义，然后再通过pgloader加载脚本来导入。 ","date":"2023-07-07","objectID":"/postgres%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6/:2:2","tags":["Postgres","数据库","csv"],"title":"Postgres快速导入csv文件","uri":"/postgres%E5%BF%AB%E9%80%9F%E5%AF%BC%E5%85%A5csv%E6%96%87%E4%BB%B6/"},{"categories":["Docker"],"content":"第一步 停止wsl wsl --shutdown ","date":"2023-07-06","objectID":"/%E4%BF%AE%E6%94%B9docker%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E4%BD%8D%E7%BD%AE/:1:0","tags":["Docker"],"title":"修改Docker默认数据保存位置","uri":"/%E4%BF%AE%E6%94%B9docker%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E4%BD%8D%E7%BD%AE/"},{"categories":["Docker"],"content":"第二步 移动默认位置（C:\\Users\\xxxxx\\AppData\\Local\\Docker\\wsl\\data）下的ext4.vhdx到新位置，这里我们移动到D:\\Docker\\data目录下。 ","date":"2023-07-06","objectID":"/%E4%BF%AE%E6%94%B9docker%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E4%BD%8D%E7%BD%AE/:2:0","tags":["Docker"],"title":"修改Docker默认数据保存位置","uri":"/%E4%BF%AE%E6%94%B9docker%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E4%BD%8D%E7%BD%AE/"},{"categories":["Docker"],"content":"第三步 regedit打开注册表，定位到HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Lxss 将其下的DistributionName为docker-desktop-data所在项对应的BasePath修改为新位置目录\\\\?\\D:\\Docker\\data ","date":"2023-07-06","objectID":"/%E4%BF%AE%E6%94%B9docker%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E4%BD%8D%E7%BD%AE/:3:0","tags":["Docker"],"title":"修改Docker默认数据保存位置","uri":"/%E4%BF%AE%E6%94%B9docker%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E4%BD%8D%E7%BD%AE/"},{"categories":["Docker"],"content":"完成 重新打开Docker Desktop ","date":"2023-07-06","objectID":"/%E4%BF%AE%E6%94%B9docker%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E4%BD%8D%E7%BD%AE/:4:0","tags":["Docker"],"title":"修改Docker默认数据保存位置","uri":"/%E4%BF%AE%E6%94%B9docker%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E4%BD%8D%E7%BD%AE/"},{"categories":["Docker"],"content":"限制 wsl2 内存使用 这个解决方案来自 github，简单来说就是创建一个 %UserProfile%\\.wslconfig 文件来限制 wsl 使用的内存总量。比如说我在 Windows 中使用的用户是 tinychen，那么我就在 C:\\Users\\tinychen 中创建了一个.wslconfig 文件，在里面加入以下内容来限制 wsl2 的内存总大小： [wsl2] memory=1GB swap=8GB swapFile=%USERPROFILE%\\AppData\\Local\\Temp\\swap.vhdx localhostForwarding=true 复制以下内容粘贴到cmd中一键解决，然后重新启动Docker Desktop wsl --shutdown echo [wsl2] \u003e %UserProfile%\\.wslconfig echo memory=1GB \u003e\u003e %UserProfile%\\.wslconfig echo swap=8GB \u003e\u003e %UserProfile%\\.wslconfig echo swapFile=^%USERPROFILE^%\\AppData\\Local\\Temp\\swap.vhdx \u003e\u003e %UserProfile%\\.wslconfig echo localhostForwarding=true \u003e\u003e %UserProfile%\\.wslconfig 注意修改完成之后需要重启 wsl2 才能生效。更多详细的配置可以查看官方文档。 ","date":"2023-07-06","objectID":"/%E4%BF%AE%E6%94%B9docker%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E4%BD%8D%E7%BD%AE/:5:0","tags":["Docker"],"title":"修改Docker默认数据保存位置","uri":"/%E4%BF%AE%E6%94%B9docker%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E4%BD%8D%E7%BD%AE/"},{"categories":["Docker"],"content":"其他 通过此方式，重装系统后，可以复用重装系统之前使用的Docker产生的镜像及容器，即Docker数据持久化，同样，可用于Docker镜像、容器的移植。 ","date":"2023-07-06","objectID":"/%E4%BF%AE%E6%94%B9docker%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E4%BD%8D%E7%BD%AE/:6:0","tags":["Docker"],"title":"修改Docker默认数据保存位置","uri":"/%E4%BF%AE%E6%94%B9docker%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E4%BD%8D%E7%BD%AE/"},{"categories":["数据分析"],"content":"树形关系分析 根据id,pid还原树形关系的完整树，找出每个树的每个节点的rootid，以便导入neo4j数据库。 import duckdb from joblib import Parallel, delayed def find_related_ids(current_id,phone,cursor): path_ids = [current_id] id_phone_dict = {current_id:phone} def find_son_ids(current_id): # 父 ID 等于上面 ID 的 phone, 即儿子的 ID cursor.execute(f\"select id, phone from ref{phone} where pid='{current_id}';\") son_ids = cursor.fetchall() for son_id_tuple in son_ids: son_id, son_phone = son_id_tuple if son_id: path_ids.append(son_id) id_phone_dict[son_id] = son_phone find_son_ids(son_id) def find_parent_ids(current_id): # id 等于上面 PID 的 phone, 即父亲的 ID cursor.execute(f\"select pid, phone from ref{phone} where id='{current_id}';\") parent_ids = cursor.fetchall() for pid_tuple in parent_ids: parent_id, parent_phone = pid_tuple if parent_id: path_ids.insert(0, parent_id) # 在列表前方插入父亲 ID，保持父辈在前，子辈在后的顺序 id_phone_dict[parent_id] = parent_phone find_parent_ids(parent_id) find_son_ids(current_id) find_parent_ids(current_id) return path_ids, id_phone_dict def add_path(init_phone): cursor = conn.cursor() \"\"\"找出特定phone的上下级路径并形成路径后保存到path列\"\"\" # 找出phone对应的credit，然后再根据credit找出同样credit的所有行，并将结果保存到新建的临时表中，递归查询关系时只在当前credit中查找，大量减少时间。 cursor.sql( f\"CREATE OR REPLACE TEMP TABLE ref{init_phone} AS SELECT * FROM datas WHERE credit IN (SELECT credit FROM datas WHERE phone='{init_phone}');\" ) # phone 对应的所有 id cursor.execute(f\"select DISTINCT id from ref{init_phone} where phone='{init_phone}';\") current_ids = [i[0] for i in cursor.fetchall()] # print('该phone共对应ID数：',len(current_ids)) for current_id in current_ids: tree_id_list, id_phone_dict = find_related_ids(current_id,init_phone,cursor) # tree_id_list = list(filter(None,tree_id_list)) tree_id_list = list(set(tree_id_list)) # 更新 path 和 level if len(tree_id_list)\u003e1: # path_of_phone = '-\u003e'.join([str(id_phone_dict[id]) for id in tree_id_list]) # print(' path_of_phone:\\t',path_of_phone,end='\\n\\n') # print('treeidlist:',tree_id_list) for i, id in enumerate(tree_id_list): phone = id_phone_dict[id] # print(id_phone_dict) # conn.execute(f\"update datas set path = '{path_of_phone}',level={i} where phone='{phone}' and id='{id}';\") try: cursor.sql(f\"update datas set rootid = '{current_id}' where phone='{phone}' and id='{id}';\") except: pass with duckdb.connect(r'abcd.db') as conn: conn.execute(\"SELECT DISTINCT phone FROM datas WHERE pid ISNULL;\") # AND phone IN('18801973844','13524003126','18635087722','18608143124','18981102776','13429916439','18535904920');\") phones = [phone[0] for phone in conn.fetchall()] Parallel(n_jobs=100, backend='threading')(delayed(add_path)(phone) for phone in phones) # for phone in tqdm(phones): # print('当前查找phone：',phone,end=',') # start = time.time() # add_path(phone) # print('耗时：',time.time()-start) ","date":"2023-07-02","objectID":"/%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/:1:0","tags":["数据分析","DUCKDB"],"title":"关联分析","uri":"/%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/"},{"categories":["数据分析"],"content":"数据加密 将生产数据加密成测试数据，数据结构和数据关系不变 import duckdb from faker import Faker import pandas as pd fake = Faker('zh_CN') def gendata(column_name:str,table_name:str,fake_type): conn.execute(f\"SELECT {column_name} FROM {table_name};\") origin_lists = {i[0] for i in conn.fetchall()} # 返回结果去重 encrypt_data = {} # 储存“旧---新”的映射 fakedata_list = [] for origin_ele in origin_lists: if origin_ele not in encrypt_data: while 1: fakedata = fake_type() if fakedata not in fakedata_list: break encrypt_data[origin_ele]=fakedata # 将字典转化为df df = pd.DataFrame(list(encrypt_data.items()),columns=['old','new']) #df 写入临时表 conn.sql(\"DROP TABLE IF EXISTS mapping;CREATE TEMP TABLE mapping AS SELECT * FROM df;\") # 根据映射写入表中 conn.sql(f\"UPDATE {table_name} SET {column_name}=mapping.new FROM mapping WHERE {table_name}.{column_name}=mapping.old\") # 操作时间,操作人,操作IP,MAC地址,部门,模块,操作类型,受理编号,名称,对象,phone,id,pid,\"path\",\"level\" with duckdb.connect('abcd.duckdb') as conn: gendata('phone','datas',fake.phone_number) gendata('名称','datas',fake.company) # ...... # id和pid加密 conn.sql(\"update datas set id=md5(md5(md5(id))) ,pid = md5(md5(md5(pid)));\") ","date":"2023-07-02","objectID":"/%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/:2:0","tags":["数据分析","DUCKDB"],"title":"关联分析","uri":"/%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/"},{"categories":["数据分析"],"content":"新的树形关系分析 # 先在duckdb中进行数据清洗 # --第一次清洗 # -- 其他字段相同的情况下，保留pid非空的记录 # CREATE TABLE datas_clean AS SELECT * FROM datas # DELETE FROM datas_clean # WHERE pid IS NULL AND phone IN ( # SELECT phone # FROM datas # WHERE pid IS NOT NULL # ) AND id IN ( # SELECT id # FROM datas # WHERE pid IS NOT NULL # ); # --第二次清洗 # --基于id和pid相同合并phone列，保存到datas_clean_clean表中 # CREATE TABLE datas_clean_clean AS # SELECT # MAX(credit) AS credit, # MAX(company) AS company, # MAX(name) AS name, # array_agg(phone) AS phones, # id, # pid, # MAX(rootid) AS rootid # FROM # datas_clean # GROUP BY # id, # pid; import duckdb import pandas as pd df = pd.DataFrame(columns=['id', 'rootid', 'phones']) def find_related_ids(current_id,phone): id_phone_dict = {current_id:[phone]} def find_son_ids(current_id): nonlocal id_phone_dict # 修改函数外部变量 # 父 ID 等于上面 ID 的 phone, 即儿子的 ID conn.execute(f\"select id, phones from temp_table{phone} where pid='{current_id}';\") son_ids = conn.fetchall() for son_id_tuple in son_ids: son_id, son_phone = son_id_tuple if son_id: id_phone_dict[son_id] = son_phone find_son_ids(son_id) def find_parent_ids(current_id): nonlocal id_phone_dict # 修改函数外部变量 # id 等于上面 PID 的 phone, 即父亲的 ID conn.execute(f\"select pid, phones from temp_table{phone} where id='{current_id}';\") parent_ids = conn.fetchall() for pid_tuple in parent_ids: parent_id, parent_phone = pid_tuple if parent_id: # path_ids.insert(0, parent_id) # 在字典前方插入父亲 ID，保持父辈在前，子辈在后的顺序 temp_id_phone_dict = {parent_id:parent_phone} temp_id_phone_dict.update(id_phone_dict) id_phone_dict= temp_id_phone_dict # id_phone_dict[parent_id] = parent_phone find_parent_ids(parent_id) find_son_ids(current_id) # find_parent_ids(current_id) return id_phone_dict def add_path(init_phone:str): global df # start = time.time() \"\"\"找出特定phone的上下级路径并形成路径后保存到path列\"\"\" # 找出phone对应的credit，然后再根据credit找出同样credit的所有行，并将结果保存到新建的临时表中，递归查询关系时只在当前credit中查找，大量减少时间。 sqlstr = f\"CREATE OR REPLACE TABLE temp_table{init_phone} AS SELECT * FROM datas_clean_clean WHERE credit IN (SELECT credit FROM datas_clean_clean WHERE list_contains(phones,'{init_phone}'));\" conn.sql( sqlstr ) # phone 对应的所有 id conn.execute(f\"select DISTINCT id from datas_clean_clean where list_contains(phones,'{init_phone}')\") current_ids = [i[0] for i in conn.fetchall()] print('# 该phone共对应ID：',end='') print(current_ids) # 以这些id为基础，进行id所在树的还原 current_ids_path = [] for current_id in current_ids: temp_path = find_related_ids(current_id,init_phone) # current_ids_path = current_ids_path.append(temp_path) # if current_id in id_phone_dict = temp_path if len(id_phone_dict)\u003e1: print(id_phone_dict) # 将字典转换为dataframe tmp_df = pd.DataFrame(list(id_phone_dict.items()), columns=['id', 'phone']) # 添加rootid列 tmp_df['rootid'] = list(id_phone_dict.keys())[0] # print('\\n','-\u003e'.join(list(id_phone_dict.keys())),'\\n') # df = df.append(tmp_df, ignore_index=True) df = pd.concat([tmp_df, df],ignore_index=True) with duckdb.connect(r'E:\\数据分析\\zfrz.db') as conn: phones = ['3116','9688','4892'] for phone in phones: add_path(phone) print(df) #df 写入临时表 conn.sql(\"DROP TABLE IF EXISTS mapping;CREATE TEMP TABLE mapping AS SELECT * FROM df;\") # # 根据映射写入表中 conn.sql(f\"UPDATE datas_clean_clean SET rootid=mapping.rootid FROM mapping WHERE datas_clean_clean.id =mapping.id\") conn.execute(\"SELECT credit, company, name ,phones, id, pid, rootid FROM datas_clean_clean WHERE rootid NOT NULL GROUP BY credit, company, name ,phones, id, pid, rootid;\") otherdf = conn.fetch_df() otherdf.to_csv('tree.csv',index=False) # neo4j导入节点 # LOAD CSV WITH HEADERS FROM 'file:///tree.csv' AS row # CREATE (n:ZFRZ { # credit: row.credit, # company: row.company, # name: row.name, # phones: row.phones, # id: row.id, # pid: row.pid, # rootid: row.rootid # }) # neo4j 创建关系 # LOAD CSV WITH HEADERS FROM 'file:///tree.csv' AS row # // Find the parent node (B) using the pid value # MATCH (parent:ZFRZ {id: row.pid}) # // Find the child node (A) using the id value # MATCH (child:ZFRZ {id: row.id}) # // Create the relationship from parent to child # C","date":"2023-07-02","objectID":"/%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/:3:0","tags":["数据分析","DUCKDB"],"title":"关联分析","uri":"/%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/"},{"categories":["数据库"],"content":"概述 貌似duckdb能自动识别文件的encoding。 ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"实现emeditor的列拆分功能 ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"关键函数 regexp_matches，查询字符串是否包含正则表达式字符 regexp_split_to_array，按给定的正则表达式字符进行拆分 unnest，将数组转为行 contains，判断是否包含特定字符（不支持正则表达式） ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"数据样本 phone introduce name 111 New York|Chicago Jean Vasquez 222 HK;Tokoy|USA Nakayama Yuito 333 Chinese Shanghai Jean Vasquez ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:2","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"以单个分隔符拆分 duckdb代码 --对包含;的列进行拆分，然后转为行。注意：UNION ALL 前后的列顺序必须一致 SELECT --与 UNION ALL 关键字 后面的列顺序必须一致 phone, UNNEST(regexp_split_to_array(introduce, ';')) introduce, name FROM read_csv('testfile.csv', delim=',', header=True, columns={'phone':'BIGINT','introduce':'VARCHAR','name':'VARCHAR'}) WHERE contains(introduce, ';') UNION ALL -- 与不包含;的行进行合并，实际中要去掉 SELECT --与 UNION ALL 关键字 前面的列顺序必须一致 * FROM read_csv('testfile.csv', delim=',', header=True, columns={'phone':'BIGINT','introduce':'VARCHAR','name':'VARCHAR'}) WHERE not contains(introduce, ';') 结果 phone introduce name 222 HK Nakayama Yuito 222 Tokoy|USA Nakayama Yuito 111 New York|Chicago Jean Vasquez 333 Chinese Shanghai Jean Vasquez ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:3","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"以多个分隔符进行拆分 支持按多个分隔符进行列拆分，此处为将introduce列按;和|进行拆分。 duckdb代码 SELECT phone, UNNEST(regexp_split_to_array(introduce, '[;|]')) introduce, name FROM read_csv('testfile.csv', delim=',', header=True, columns={'phone':'BIGINT','introduce':'VARCHAR','name':'VARCHAR'}) WHERE regexp_matches(introduce,'[;|]') UNION ALL SELECT * FROM read_csv('testfile.csv', delim=',', header=True, columns={'phone':'BIGINT','introduce':'VARCHAR','name':'VARCHAR'}) WHERE not regexp_matches(introduce,'[;|]') 结果 phone introduce name 111 New York Jean Vasquez 111 Chicago Jean Vasquez 222 HK Nakayama Yuito 222 Tokoy Nakayama Yuito 222 USA Nakayama Yuito 333 Chinese Shanghai Jean Vasquez ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:4","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"基于csv文件的分析结果写入到csv文件 COPY (SELECT * FROM tbl) TO 'output.csv' (HEADER, DELIMITER ','); 如，将上节的分析结果写入csv文件的语句是: --对包含;的列进行拆分，然后转为行。注意：UNION ALL 前后的列顺序必须一致 COPY ( SELECT phone, UNNEST(regexp_split_to_array(introduce, '[;|]')) introduce, name FROM read_csv('testfile.csv',delim = ',',header = True,columns = {'phone':'BIGINT','introduce':'VARCHAR','name':'VARCHAR' }) WHERE regexp_matches(introduce, '[;|]') UNION ALL SELECT * FROM read_csv('testfile.csv',delim = ',',header = True,columns = {'phone':'BIGINT','introduce':'VARCHAR','name':'VARCHAR' }) WHERE not regexp_matches(introduce,'[;|]') ) TO 'output.csv' (HEADER, DELIMITER ','); ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"将csv文件导入到duckdb数据库 以下语句将会自动新建数据表ontime并导入csv文件数据。 CREATE TABLE ontime AS SELECT * FROM 'flights.csv'; ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"递归查询 暂未掌握，附源文档链接 https://duckdb.org/docs/sql/query_syntax/with ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"实现低内存占用的CSV文件按指定列去重 CSV文件中有A,B,C,D,E,F6列，E列为日期时间列。 ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"只保留要去重的列 基于哪几列去重就只保留哪几列 COPY (SELECT DISTINCT A,B,C,D FROM '待去重CSV文件路径') TO 'output.csv' (HEADER, DELIMITER ','); ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:1","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"保留所有字段 基于A,B,C,D四列去重，同时保留E,F两个字段（值随意），因为GROUP BY的作用，会出现一组A,B,C,D的值对应多组E,F的值，所以使用ANY_VALUE函数来随机选取E,F列的值。 COPY (SELECT A,B,C,D,ANY_VALUE(E),ANY_VALUE(F) FROM '待去重CSV文件路径' GROUP BY A,B,C,D) TO 'output.csv' (HEADER, DELIMITER ','); ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:2","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"保留最早和日晚``日期时间 基于A,B,C,D四列去重，同时保留E中最早和最晚两个值，使用MAX、MIN函数分别获取最晚、最早日期时间: COPY (SELECT A,B,C,D,MAX(E) 最晚日期时间,MIN(e) 最早日期时间 FROM '待去重CSV文件路径' GROUP BY A,B,C,D) TO 'output.csv' (HEADER, DELIMITER ','); ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:3","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"获取特定表的所有列名 SELECT column_name FROM information_schema.columns WHERE table_name = '表名'; Output: column_name phone uid 个人信息 备注 ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"结果保存为数组 SELECT ARRAY_AGG(column_name) FROM information_schema.columns WHERE table_name = '表名'; Output: array_agg(column_name) [‘phone’,‘uid’,‘个人信息’,‘备注’] ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:1","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"保存为字典（结构体） SELECT row(column_name,data_type) as name_type FROM information_schema.columns WHERE table_name = '表名'; Output name_type {‘column_name’: phone, ‘data_type’: BIGINT} {‘column_name’: uid, ‘data_type’: BIGINT} {‘column_name’: 个人信息, ‘data_type’: VARCHAR} {‘column_name’: 备注, ‘data_type’: VARCHAR} ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:2","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"其他与列相关基础信息的查询 SELECT * FROM information_schema.columns WHERE table_name = '表名'; Output: table_catalog table_schema table_name column_name ordinal_position column_default is_nullable data_type character_maximum_length character_octet_length numeric_precision numeric_precision_radix numeric_scale datetime_precision interval_type interval_precision character_set_catalog character_set_schema character_set_name collation_catalog collation_schema collation_name domain_catalog domain_schema domain_name udt_catalog udt_schema udt_name scope_catalog scope_schema scope_name maximum_cardinality dtd_identifier is_self_referencing is_identity identity_generation identity_start identity_increment identity_maximum identity_minimum identity_cycle is_generated generation_expression is_updatable test main 表名 phone 1 YES BIGINT 64 2 0 test main 表名 uid 2 YES BIGINT 64 2 0 test main 表名 个人信息 3 YES VARCHAR test main 表名 备注 4 YES VARCHAR ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:3","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"获取当前DuckDB文件所有数据库名 其中catalog为可见的schema(通俗理解的数据库)名称 SELECT * FROM information_schema.schemata; Output: catalog_name schema_name schema_owner default_character_set_catalog default_character_set_schema default_character_set_name sql_path system information_schema duckdb system main duckdb system pg_catalog duckdb temp information_schema duckdb temp main duckdb temp pg_catalog duckdb test information_schema duckdb test main duckdb test pg_catalog duckdb ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:4","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"获取某数据库下所有的数据表名 第一种方式 SELECT table_name FROM information_schema.tables WHERE table_catalog = 'test'; Output: table_name table1 table2 test 第二种方式【推荐】 PRAGMA show_tables; Output: table_name table1 table2 test ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:5","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"限制使用内存大小和并发数 第一种【推荐】 -- 设置内存大小限制 SET memory_limit='10GB'; -- configure the system to use 1 thread 待测试作用 SET threads TO 1; -- 查看所有可用设置，同时可在网页中查看所有可用设置：https://duckdb.org/docs/sql/configuration#configuration-reference SELECT * FROM duckdb_settings(); -- 查看特定的设置值 SELECT current_setting('access_mode'); -- 将内存限制重置为默认，默认好像是程序自动的。 RESET memory_limit; 第二种 -- 设置内存大小限制 PRAGMA memory_limit='1GB'; -- 设置并行查询数 PRAGMA threads=4; 更多关于数据库基础设置信息详见： https://duckdb.org/docs/sql/pragmas https://duckdb.org/docs/sql/configuration 见DuckDB设置参数描述翻译 ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"关于删除大表不会改变数据库文件的大小疑问 从数据库中删除了一个数据量巨大的表。但是，数据库文件的大小保持不变，尝试使用commit()和 VACCUM 语句也无济于事。 找到相关的话题：https://github.com/duckdb/duckdb/discussions/7152 结论：删除表不会改变存储空间，以在将来插入新数据时重新利用，这是个问题，将来会解决。 ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:0","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"DuckDB设置参数描述翻译 获取当前版本所有可用参数：SELECT * FROM duckdb_settings(); 参数 默认值 中文描述 英文描述 值类型 access_mode automatic 数据库的访问模式（AUTOMATIC，READ_ONLY或READ_WRITE） Access mode of the database (AUTOMATIC, READ_ONLY or READ_WRITE) VARCHAR checkpoint_threshold 16.7MB 自动触发检查点的WAL大小阈值（例如1GB） The WAL size threshold at which to automatically trigger a checkpoint (e.g. 1GB) VARCHAR debug_checkpoint_abort none DEBUG设置：出于测试目的，在检查点时触发中止 DEBUG SETTING: trigger an abort while checkpointing for testing purposes VARCHAR debug_force_external FALSE DEBUG设置：对支持它的操作符强制进行核外计算，用于测试 DEBUG SETTING: force out-of-core computation for operators that support it, used for testing BOOLEAN debug_force_no_cross_product FALSE DEBUG设置：当超图未连接时，强制禁用交叉产品生成，用于测试 DEBUG SETTING: Force disable cross product generation when hyper graph isn’t connected, used for testing BOOLEAN debug_asof_iejoin FALSE DEBUG设置：强制使用IEJoin实现AsOf连接 DEBUG SETTING: force use of IEJoin to implement AsOf joins BOOLEAN debug_window_mode NULL DEBUG设置：切换要使用的窗口模式 DEBUG SETTING: switch window mode to use VARCHAR default_collation 未指定时使用的排序设置 The collation setting used when none is specified VARCHAR default_order asc 未指定时使用的排序类型（ASC或DESC） The order type used when none is specified (ASC or DESC) VARCHAR default_null_order nulls_last 未指定时使用的空值排序（NULLS_FIRST或NULLS_LAST） Null ordering used when none is specified (NULLS_FIRST or NULLS_LAST) VARCHAR disabled_optimizers DEBUG设置：禁用特定的优化器集（逗号分隔） DEBUG SETTING: disable a specific set of optimizers (comma separated) VARCHAR enable_external_access TRUE 允许数据库访问外部状态（例如通过加载/安装模块，COPY TO/FROM，CSV读取器，pandas替换扫描等） Allow the database to access external state (through e.g. loading/installing modules, COPY TO/FROM, CSV readers, pandas replacement scans, etc) BOOLEAN enable_fsst_vectors FALSE 允许对FSST压缩段进行扫描以发出压缩向量以利用后期解压缩 Allow scans on FSST compressed segments to emit compressed vectors to utilize late decompression BOOLEAN allow_unsigned_extensions FALSE 允许加载具有无效或缺失签名的扩展 Allow to load extensions with invalid or missing signatures BOOLEAN custom_extension_repository 覆盖远程扩展安装的自定义端点 Overrides the custom endpoint for remote extension installation VARCHAR enable_object_cache FALSE 是否使用对象缓存来缓存例如Parquet元数据 Whether or not object cache is used to cache e.g. Parquet metadata BOOLEAN enable_http_metadata_cache FALSE 是否使用全局http元数据来缓存HTTP元数据 Whether or not the global http metadata is used to cache HTTP metadata BOOLEAN enable_profiling NULL 启用分析，并设置输出格式（JSON，QUERY_TREE，QUERY_TREE_OPTIMIZER） Enables profiling, and sets the output format (JSON, QUERY_TREE, QUERY_TREE_OPTIMIZER) VARCHAR enable_progress_bar FALSE 启用进度条，将长查询的进度打印到终端 Enables the progress bar, printing progress to the terminal for long queries BOOLEAN enable_progress_bar_print TRUE 在’enable_progress_bar’为true时，控制进度条的打印 Controls the printing of the progress bar, when ’enable_progress_bar’ is true BOOLEAN experimental_parallel_csv NULL 是否使用实验性的并行CSV阅读器 Whether or not to use the experimental parallel CSV reader BOOLEAN explain_output physical_only EXPLAIN语句的输出（ALL，OPTIMIZED_ONLY，PHYSICAL_ONLY） Output of EXPLAIN statements (ALL, OPTIMIZED_ONLY, PHYSICAL_ONLY) VARCHAR extension_directory 设置存储扩展的目录 Set the directory to store extensions in VARCHAR external_threads 0 处理DuckDB任务的外部线程数。 The number of external threads that work on DuckDB tasks. BIGINT file_search_path 用于搜索输入文件的目录的逗号分隔列表 A comma separated list of directories to search for input files VARCHAR force_compression Auto DEBUG设置：强制使用特定的压缩方法 DEBUG SETTING: forces a specific compression method to be used VARCHAR force_bitpacking_mode auto DEBUG设置：强制使用特定的位打包模式 DEBUG SETTING: forces a specific bitpacking mode VARCHAR home_directory 设置系统使用的主目录 Sets the home directory used by the system VARCHAR log_query_path NULL 指定应记录查询的路径（默认：空字符串，不记录查询） Specifies the path to which queries should be logged (default: empty string, queries are not logged) VARCHAR immediate_transaction_mode FALSE 是否应在需要时懒惰地启动事务，或在调用BEGIN TRANSACTION时立即启动 Whether transactions should be started lazily when needed, or immediately when","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:10:0","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"查看当前版本所有可用扩展 select * from duckdb_extensions(); Output: extension_name loaded installed install_path description aliases autocomplete false false Add supports for autocomplete in the shell [] fts false false Adds support for Full-Text Search Indexes [] httpfs false false Adds support for reading and writing files over a HTTP(S) connection [‘http’,‘https’,‘s3’] icu true true (BUILT-IN) Adds support for time zones and collations using the ICU library [] inet false false Adds support for IP-related data types and functions [] jemalloc false false Overwrites system allocator with JEMalloc [] json true true (BUILT-IN) Adds support for JSON operations [] motherduck false false Enables motherduck integration with the system [‘md’] parquet true true (BUILT-IN) Adds support for reading and writing parquet files [] postgres_scanner false false Adds support for reading from a Postgres database [‘postgres’] spatial true true C:\\spatial.duckdb_extension Geospatial extension that adds support for working with spatial data and functions [] sqlite_scanner false true C:\\sqlite_scanner.duckdb_extension Adds support for reading SQLite database files [‘sqlite’,‘sqlite3’] tpcds false false Adds TPC-DS data generation and query support [] tpch false false Adds TPC-H data generation and query support [] visualizer true [] ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:0","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"扩展的安装与加载 INSTALL spatial; LOAD spatial; ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:11:1","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"内存与临时文件 默认情况下，如果 DuckDB 在内存模式下运行，它不会尝试将数据缓存到磁盘，而当使用磁盘支持的数据库时，DuckDB 将尝试将数据缓存到目录mydb.db.tmp。您也可以手动指定要缓存的目录，也可以使用SET temp_directory=’/tmp/mytmp.duck’; ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:12:0","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"进行连接查询时，内存消耗殆尽 下文是问题描述 https://github.com/duckdb/duckdb/discussions/3820 下面的ISSUE说是已经解决这个问题，实现了支持超过内存大小的连接查询 https://github.com/duckdb/duckdb/pull/4189 ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:13:0","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"DuckDB VS ClickHouse VS DataBend https://github.com/datafuselabs/databend/discussions/11357 ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:14:0","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"DuckDB快速排序 这篇文章中，介绍 DuckDB 如何排序，以及它与其他数据管理系统的比较。 因为人们通常在笔记本电脑或其他个人电脑上运行数据分析，因此此文在2020 MacBook Pro上运行这些实验。该笔记本电脑具有基于ARM的Apple M1 CPU。M1处理器具有8个核心：4个高性能核心和4个能效核心，16GB内存，固态硬盘。 我们将比较以下数据库系统的差异： 数据库 版本 ClickHouse 21.7.5 HyPer 2021.2.1.12564 Pandas 1.3.2 SQLite 3.36.0 结论 DuckDB 的新并行排序实现可以有效地对超出内存容量的数据进行排序，从而利用现代 SSD 的速度。在其他系统因内存不足或切换到速度慢得多的外部排序策略而崩溃的情况下，DuckDB 的性能会在超过内存限制时优雅地下降。 性能测试的源代码：https://github.com/lnkuiper/experiments/tree/master/sorting ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:15:0","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"DuckDB计算树路径(关联分析) ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:16:0","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"数据样本（含下面一、二的数据） 数据样本使用excel的randombetween函数及excel办公助手插件生成的虚假测试数据，如与您的个人信息一致，纯乃天意。 数据样本.csv 数据样本中号码15834961213两次在phone中出现，且都处于树形关系的路径中间。 ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:16:1","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"数据样本（一）结构 phone id pid 18693044740 37775 78340 14580719766 78340 47070 15834961213 47070 10960 13395855488 10960 67272 15657298376 67272 55701 15889121934 55701 18631569256 14280 13807639997 15582 duckdb代码，花费6秒： import duckdb def find_all_son_phones(phone): path = [phone] def find_son_phones(phone): # phone对应的id conn.execute(f\"select id from datas where phone='{phone}';\") current_id = conn.fetchone()[0] # 父ID等于上面ID的Phone,即儿子的Phone conn.execute(f\"select phone from datas where pid='{current_id}';\") son_phone_array = conn.fetchone() if son_phone_array: # 有儿子的情况 son_phone = son_phone_array[0] path.append(son_phone) find_son_phones(son_phone) find_son_phones(phone) return path def add_path(phone): \"\"\"找出特定号码的子孙号码形成路径后保存到path列\"\"\" tree_list = find_all_son_phones(phone) tree_list = [str(i) for i in tree_list] if len(tree_list)\u003e1: for i,e in enumerate(tree_list): conn.execute(f\"update datas set path = '{'-\u003e'.join(tree_list)}',level={i} where phone ={e};\") def gen_phone_trees(): # 全表生成数关系 root_phones = conn.execute(\"select phone from datas where id NOTNULL AND pid ISNULL;\").fetchall() root_phones = [j for i in root_phones for j in i] for phone in root_phones: add_path(phone) conn = duckdb.connect('test.duckdb') conn.execute(\"CREATE TABLE IF NOT EXISTS datas AS SELECT * FROM 'C:\\\\Users\\\\xxxxxx\\\\test.csv';\") conn.execute(\"ALTER TABLE datas ADD COLUMN IF NOT EXISTS path VARCHAR;\") conn.execute(\"ALTER TABLE datas ADD COLUMN IF NOT EXISTS level INT;\") # 创建索引，数据量大的时候测试是否有价值【待测试】。 conn.execute(\"CREATE INDEX p_id_pid_idx ON datas (phone, id,pid);\") gen_phone_trees() conn.close() 上述代码只能对给定号码出现在一个数中的情况进行处理，并且只能查找下子孙元素，以下是改进后的代码，能够： 从树的任意位置元素开始，还原整个树的路径； 处理同一个号码出现在多个树中的情况。 缺陷：没有考虑一个PID对应多个同级ID的情况。 import duckdb import time count= 0 def find_related_ids(current_id,phone): path_ids = [current_id] id_phone_dict = {current_id:phone} def find_son_ids(current_id): # 父ID等于上面ID的Phone,即儿子的ID conn.execute(f\"select id, phone from datas where pid='{current_id}';\") son_ids = conn.fetchall() for son_id_tuple in son_ids: son_id, son_phone = son_id_tuple path_ids.append(son_id) id_phone_dict[son_id] = son_phone find_son_ids(son_id) def find_parent_ids(current_id): # id等于上面PID的Phone,即父亲的ID conn.execute(f\"select pid, phone from datas where id='{current_id}';\") parent_ids = conn.fetchall() for pid_tuple in parent_ids: parent_id, parent_phone = pid_tuple path_ids.insert(0, parent_id) # 在列表前方插入父亲ID，保持父辈在前，子辈在后的顺序 id_phone_dict[parent_id] = parent_phone find_parent_ids(parent_id) find_son_ids(current_id) # find_parent_ids(current_id) return path_ids, id_phone_dict def add_path(init_phone): global count \"\"\"找出特定号码的上下级路径并形成路径后保存到path列\"\"\" # phone对应的所有id conn.execute(f\"select DISTINCT id from datas where phone='{init_phone}';\") current_ids = [i[0] for i in conn.fetchall()] print('该号码共对应ID数：',len(current_ids)) for current_id in current_ids: tree_id_list, id_phone_dict = find_related_ids(current_id,init_phone) # tree_id_list = list(filter(None,tree_id_list)) tree_id_list = list(set(tree_id_list)) # 更新path和level if len(tree_id_list)\u003e1: count+=len(tree_id_list) print(len(tree_id_list),'\\ntree_id_list:\\t',tree_id_list) print(' id_phone_dict:\\t',id_phone_dict) path_of_phone = '-\u003e'.join([str(id_phone_dict[id]) for id in tree_id_list]) print(' path_of_phone:\\t',path_of_phone,end='\\n\\n') for i, id in enumerate(tree_id_list): phone = id_phone_dict[id] conn.execute(f\"update datas set path = '{path_of_phone}',level={i} where phone='{phone}' and id='{id}';\") with duckdb.connect('test.duckdb') as conn: ceshi = [''] ceshi_str = ','.join([f\"'{item}'\" for item in ceshi]) # 有记录的 conn.execute(f'SELECT DISTINCT phone FROM datas WHERE phone IN ({ceshi_str});') phones = [phone[0] for phone in conn.fetchall()] for phone in phones: print('当前查找号码：',phone,end=',') start = time.time() add_path(phone) print('耗时：',time.time()-start) # add_path(\"97891706516\") print(count) Pandas代码，花费22+秒: import pandas as pd df = pd.read_csv(r\"test.csv\", encoding='utf-8', dtype='str',usecols=[\"name\",\"phone\",\"id\",\"pid\"]) ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:16:2","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"数据样本（二）结构 phone pphone 18693044740 14580719766 14580719766 15834961213 15834961213 13395855488 13395855488 15657298376 15657298376 15889121934 15889121934 18815083183 13918139598 13918139598 15762062144 15762062144 18109707945 18109707945 13254675670 13254675670 Pandas代码，花费7.5秒 import pandas as pd df = pd.read_csv(r\"test.csv\", encoding='utf-8', dtype='str',usecols=[\"name\",\"phone\",\"pphone\"]) def find_all_son_phones(df, phone): path = [phone] def find_son_phones(df, phone): # phone对应的id # 父ID等于上面ID的Phone,即儿子的Phone son_phone_array = df[df['pphone'] == phone]['phone'].values if son_phone_array.any(): # 有儿子的情况 son_phone = son_phone_array[0] path.append(son_phone) find_son_phones(df,son_phone) find_son_phones(df, phone) return path def add_path(df,phone): \"\"\"找出特定号码的子孙号码形成路径后保存到path列\"\"\" if 'path' not in df: df['path'] = None if 'level' not in df: df['level']= None tree_list = find_all_son_phones(df, phone) if len(tree_list)\u003e1: for i,e in enumerate(tree_list): df.loc[df['phone']==e,'path'] = '-\u003e'.join(tree_list) df.loc[df['phone']==e,'level'] = str(i) # 为所有父ID为空而ID不为空的号码生成子孙路径关系 def gen_phone_trees(df): root_phones = df[(df['phone']!='')\u0026(df['pphone'].isnull())]['phone'].values for phone in root_phones: add_path(df,phone) gen_phone_trees(df) # 找出特定号码的子孙树关系 # add_path(df,'15834961213') df[~df['path'].isnull()] DuckDB代码，花费3.3秒 import duckdb # import functools conn = duckdb.connect('zfrz.duckdb') conn.execute(\"CREATE TABLE IF NOT EXISTS datas AS SELECT * FROM 'C:\\\\Users\\\\xxx\\\\编程\\\\test.csv';\") conn.execute(\"ALTER TABLE datas ADD COLUMN IF NOT EXISTS path VARCHAR;\") conn.execute(\"ALTER TABLE datas ADD COLUMN IF NOT EXISTS level INT;\") # conn.execute(\"CREATE INDEX p_id_pid_idx ON datas (phone, id,pid);\") def find_all_son_phones(phone): path = [phone] def find_son_phones(phone): conn.execute(f\"select phone from datas where pphone='{phone}';\") # 父ID等于上面ID的Phone,即儿子的Phone son_phone_array = conn.fetchone() if son_phone_array: # 有儿子的情况 son_phone = son_phone_array[0] path.append(son_phone) find_son_phones(son_phone) find_son_phones(phone) return path def add_path(phone): \"\"\"找出特定号码的子孙号码形成路径后保存到path列\"\"\" tree_list = find_all_son_phones(phone) tree_list = [str(i) for i in tree_list] if len(tree_list)\u003e1: for i,e in enumerate(tree_list): conn.execute(f\"update datas set path = '{'-\u003e'.join(tree_list)}',level={i} where phone ={e};\") def gen_phone_trees(): root_phones = conn.execute(\"select phone from datas where pphone ISNULL;\").fetchall() root_phones = [j for i in root_phones for j in i] for phone in root_phones: add_path(phone) # add_path(15834961213) gen_phone_trees() conn.close() ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:16:3","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"树形关系新思路 ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:17:0","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"第一步 postgres数据库的datas表中有phone,id,pid,path,level,rootid等6个字段，path,level,rootid三个字段本来均为NULL，根据id和pid的关联关系，计算出每个id对应的子节点，并以数组形式将id保存到path列，同时将此节点的根节点id保存到rootid，将节点在树形结构中的层级保存到level（根节点为0，依此类推）。 phone id pid path level rootid 15889121934 55701 15657298376 67272 55701 13395855488 10960 67272 15834961213 47070 10960 14580719766 78340 47070 18693044740 37775 78340 18693044741 37775 78340 18631569256 14280 13807639997 15582 13254675670 75663 18109707945 12959 75663 15834961213 22099 12959 13918139598 22099 12959 18815083183 83540 22099 13875678880 58053 15793943526 72534 18739688136 75579 13028479619 51390 13339189047 90300 51390 15834961213 46686 90300 18073413108 53266 46686 15154627416 50707 53266 13722872673 84764 WITH RECURSIVE datas_cte AS ( SELECT id, pid, ARRAY[id] as path, 0 as level, id as rootid FROM datas WHERE pid IS NULL UNION ALL SELECT d.id, d.pid, c.path || d.id, c.level + 1, c.rootid FROM datas d JOIN datas_cte c ON d.pid = c.id ) UPDATE datas SET path = datas_cte.path, level = datas_cte.level, rootid = datas_cte.rootid FROM datas_cte WHERE datas.id = datas_cte.id; phone id pid path level rootid 15889121934 55701 [55701] 0 55701 15657298376 67272 55701 [55701,67272] 1 55701 13395855488 10960 67272 [55701,67272,10960] 2 55701 15834961213 47070 10960 [55701,67272,10960,47070] 3 55701 14580719766 78340 47070 [55701,67272,10960,47070,78340] 4 55701 18693044740 37775 78340 [55701,67272,10960,47070,78340,37775] 5 55701 18693044741 37775 78340 [55701,67272,10960,47070,78340,37775] 5 55701 18631569256 14280 13807639997 15582 13254675670 75663 [75663] 0 75663 18109707945 12959 75663 [75663,12959] 1 75663 15834961213 22099 12959 [75663,12959,22099] 2 75663 13918139598 22099 12959 [75663,12959,22099] 2 75663 18815083183 83540 22099 [75663,12959,22099,83540] 3 75663 13875678880 58053 15793943526 72534 18739688136 75579 13028479619 51390 [51390] 0 51390 13339189047 90300 51390 [51390,90300] 1 51390 15834961213 46686 90300 [51390,90300,46686] 2 51390 18073413108 53266 46686 [51390,90300,46686,53266] 3 51390 15154627416 50707 53266 [51390,90300,46686,53266,50707] 4 51390 13722872673 84764 ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:17:1","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"第二步 将相同rootid的level值最大的path列数组中的id转化为对应的phone,一个id对应多个phone的，使用#连接多个phone，此时path仍然为数组， 然后将path的数组元素用-\u003e连接，此时path为字符串类型。 -- 创建一个临时表，将每个id对应的所有电话号码用#连接起来 CREATE TEMP TABLE temp_id_phone AS SELECT id, STRING_AGG(phone, '#') as phone FROM datas GROUP BY id; -- 找出每个 rootid 组里面 level 最大的记录 WITH max_level AS ( SELECT rootid, MAX(level) as level FROM datas GROUP BY rootid ), max_level_datas AS ( SELECT d.* FROM datas d JOIN max_level m ON d.rootid = m.rootid AND d.level = m.level ), -- 更新这些记录的 path，将 id 替换为对应的电话号码 updated_path AS ( SELECT mld.id, mld.pid, ARRAY_TO_STRING(ARRAY( SELECT t.phone::TEXT FROM unnest(mld.path::INTEGER[]) p(id) JOIN temp_id_phone t ON p.id = t.id ), '-\u003e') as path FROM max_level_datas mld ) UPDATE datas d SET path = up.path FROM updated_path up WHERE d.id = up.id AND d.pid = up.pid; -- 删除临时表 DROP TABLE temp_id_phone; ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:17:2","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"第三步 将相同rootid的path列值设置为相同rootid且level值最大的path列的值。 要更新一个表中的一列的值，基于同一表中的其他行的值，你需要使用一个自连接。 UPDATE datas AS d1 SET path = d2.path FROM ( SELECT rootid, path FROM datas WHERE level = ( SELECT MAX(level) FROM datas AS d3 WHERE d3.rootid = datas.rootid ) ) AS d2 WHERE d1.rootid = d2.rootid; 先创建一个子查询 d2，该查询对于每一个 rootid 找到对应 level 最大的 path。 然后，我们将原表 datas 更新为子查询 d2 中找到的 path。 这个查询假设 rootid 和 level 的组合是唯一的，也就是说，在同一 rootid 中，不可能有两行具有相同的最大 level 值。如果这不是你的情况，你可能需要对查询进行进一步的调整以处理这种情况。 ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:17:3","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据库"],"content":"以上三步的完整代码 --CREATE TABLE datas AS SELECT * FROM 'C:\\Users\\xxx\\Desktop\\tree.csv'; --ALTER table datas ADD COLUMN path varchar DEFAULT null; --ALTER table datas ADD COLUMN rootid varchar DEFAULT null; --ALTER table datas ADD COLUMN level int DEFAULT null; --------------------------------------------------------------------------- -- 创建一个递归查询来获取每一行的根节点、路径和级别 WITH RECURSIVE datas_cte AS ( SELECT id, pid, ARRAY[id] as path, 0 as level, id as rootid FROM datas WHERE pid IS NULL UNION ALL SELECT d.id, d.pid, c.path || ARRAY[d.id], c.level + 1, c.rootid FROM datas d JOIN datas_cte c ON d.pid = c.id ) UPDATE datas SET path = datas_cte.path, level = datas_cte.level, rootid = datas_cte.rootid FROM datas_cte WHERE datas.id = datas_cte.id; --------------------------------------------------------------------------- UPDATE datas SET path=null,level=null,rootid=null; --------------------------------------------------------------------------- -- 找出rootid个数大于1的所有记录，即树形节点大于1的记录 SELECT d.* FROM datas d WHERE d.rootid IN ( SELECT rootid FROM datas GROUP BY rootid HAVING COUNT(*) \u003e 1 ); --------------------------------------------------------------------------- -- 创建一个中间表，将每个id对应的所有电话号码用#连接起来 CREATE TEMP TABLE temp_id_phone AS SELECT id, STRING_AGG(phone, '#') as phone FROM datas GROUP BY id; -- 更新路径，将id替换为对应的电话号码 WITH RECURSIVE datas_cte AS ( SELECT d.id, d.pid, ARRAY[t.phone::TEXT] as path, 0 as level, d.id as rootid FROM datas d JOIN temp_id_phone t ON d.id = t.id WHERE pid IS NULL UNION ALL SELECT d.id, d.pid, c.path || ARRAY[t.phone::TEXT], c.level + 1, c.rootid FROM datas d JOIN datas_cte c ON d.pid = c.id JOIN temp_id_phone t ON d.id = t.id ) UPDATE datas SET path = ARRAY_TO_STRING(datas_cte.path, '-\u003e'), level = datas_cte.level, rootid = datas_cte.rootid FROM datas_cte WHERE datas.id = datas_cte.id; -- 删除临时表 DROP TABLE temp_id_phone; --------------------------------------------------------------------------- --------------------------------------------------------------------------- -- 将level值最大的path列数组中的id替换成phone -- 创建一个临时表，将每个id对应的所有电话号码用#连接起来 CREATE TEMP TABLE temp_id_phone AS SELECT id, STRING_AGG(phone, '#') as phone FROM datas GROUP BY id; -- 找出每个 rootid 组里面 level 最大的记录 WITH max_level AS ( SELECT rootid, MAX(level) as level FROM datas GROUP BY rootid ), max_level_datas AS ( SELECT d.* FROM datas d JOIN max_level m ON d.rootid = m.rootid AND d.level = m.level ), -- 更新这些记录的 path，将 id 替换为对应的电话号码 updated_path AS ( SELECT mld.id, mld.pid, ARRAY_TO_STRING(ARRAY( SELECT t.phone::TEXT FROM unnest(mld.path::INTEGER[]) p(id) JOIN temp_id_phone t ON p.id = t.id ), '-\u003e') as path FROM max_level_datas mld ) UPDATE datas d SET path = up.path FROM updated_path up WHERE d.id = up.id AND d.pid = up.pid; -- 删除临时表 DROP TABLE temp_id_phone; --------------------------------------------------------------------------- --------------------------------------------------------------------------- --将rootid相同的所有行的path设置为：rootid相同的对应level列值最大的对应的path的值。 UPDATE datas AS d1 SET path = d2.path FROM ( SELECT rootid, path FROM datas WHERE level = ( SELECT MAX(level) FROM datas AS d3 WHERE d3.rootid = datas.rootid ) ) AS d2 WHERE d1.rootid = d2.rootid; --------------------------------------------------------------------------- ","date":"2023-05-29","objectID":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:17:4","tags":["DuckDB","数据库"],"title":"DuckDB学习笔记","uri":"/duckdb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"原Naiveproxy的搭建脚本有个弊端，域名证书需要手动申请，比较蛋疼，这次找到的一键搭建脚本可以自动申请证书（暂时未找到到期续期的脚本，可以重置服务器，重新运行脚本来实现变相续期）。 脚本地址如下：https://github.com/crazypeace/naive 修改用户名密码：修改/etc/caddy/Caddyfile { order forward_proxy before file_server } :443, np.mydomain.com { tls e16d9cb045d7@gmail.com forward_proxy { basic_auth 用户名 密码 hide_ip hide_via probe_resistance } file_server { root /var/www/html } } 然后重启：service caddy restart ","date":"2023-05-02","objectID":"/naiveproxy%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:0:0","tags":null,"title":"NaiveProxy搭建过程记录","uri":"/naiveproxy%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":["Go"],"content":"写65万行数据 1.6441729 秒","date":"2023-04-23","objectID":"/go%E8%AF%AD%E8%A8%80%E5%B0%86map%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5excel%E6%96%87%E4%BB%B6/","tags":["Go"],"title":"Go语言将Map数据写入EXCEL文件","uri":"/go%E8%AF%AD%E8%A8%80%E5%B0%86map%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5excel%E6%96%87%E4%BB%B6/"},{"categories":["Go"],"content":" package main import ( \"fmt\" \"strconv\" \"time\" \"github.com/xuri/excelize/v2\" ) func main() { var Datas []map[string]string for i := 0; i \u003c 650000; i++ { data := map[string]string{\"姓名\": \"张三\", \"序号\": strconv.Itoa(i), \"性别\": \"男\"} Datas = append(Datas, data) } start := time.Now() StreamWriter(\"abc.xlsx\", \"Sheet1\", Datas) elapsed := time.Since(start) fmt.Printf(\"Elapsed time: %s\\n\", elapsed) } // 来源http://t.csdn.cn/qv6PS func StreamAppendWriter(filename, sheet_name string, contents [][]string) { //打开工作簿 file, err := excelize.OpenFile(filename) if err != nil { return } // 确保在函数结束时关闭文件 defer func() { if err := file.Close(); err != nil { fmt.Println(err) } }() // 获取流式写入器 streamWriter, _ := file.NewStreamWriter(sheet_name) rows_old, _ := file.GetRows(sheet_name) // 按行获取内容 cols_old, _ := file.GetCols(sheet_name) // 按列获取内容 fmt.Println(\"已有内容行数rows: \", len(rows_old), \"已有内容列数cols: \", len(cols_old)) // 将源文件内容先写入excel for rowid, row_element_old := range rows_old { row := make([]interface{}, len(cols_old)) // 每行数据的个数等于列的个数 // 构造准备写入的每行数据 for col := 0; col \u003c len(cols_old); col++ { if row_element_old == nil { row[col] = nil } else { row[col] = row_element_old[col] } } // 构造写入行的初始位置 cell_start, _ := excelize.CoordinatesToCellName(1, rowid+1) if err := streamWriter.SetRow(cell_start, row); err != nil { fmt.Println(err) } } // 将新加contents写进流式写入器 for rowID := 0; rowID \u003c len(contents); rowID++ { row := make([]interface{}, len(contents[0])) for colID := 0; colID \u003c len(contents[0]); colID++ { row[colID] = contents[rowID][colID] } // 构造写入行的初始位置 cell_start, _ := excelize.CoordinatesToCellName(1, rowID+len(rows_old)+1) if err := streamWriter.SetRow(cell_start, row); err != nil { fmt.Println(err) } } // 结束流式写入过程 err = streamWriter.Flush() if err != nil { fmt.Println(err) } // 保存工作簿 err = file.SaveAs(filename) if err != nil { fmt.Println(err) } } // 来源http://t.csdn.cn/qv6PS func StreamWriter(filename, sheet_name string, list_of_map []map[string]string) { //打开工作簿 file := excelize.NewFile() defer func() { if err := file.Close(); err != nil { fmt.Println(err) } }() // 获取流式写入器 streamWriter, _ := file.NewStreamWriter(sheet_name) headers := GetKeys(list_of_map[0]) cell_start, _ := excelize.CoordinatesToCellName(1, 1) if err := streamWriter.SetRow(cell_start, headers); err != nil { fmt.Println(err) } // 将contents写进流式写入器 for index, map_value := range list_of_map { row_number := index + 2 row_of_values := GetValues(map_value, InterfaceToStringSlice(headers)) // 每行数据的个数 = 列的个数 = 切片中元素的个数 // 构造写入行的初始位置 cell_start, _ := excelize.CoordinatesToCellName(1, row_number) if err := streamWriter.SetRow(cell_start, row_of_values); err != nil { fmt.Println(err) } } // 结束流式写入过程 err := streamWriter.Flush() if err != nil { fmt.Println(err) } // 保存工作簿 err = file.SaveAs(filename) if err != nil { fmt.Println(err) } } func GetKeys(map_obj map[string]string) []interface{} { // 数组默认长度为map长度,后面append时,不需要重新申请内存和拷贝,效率很高 keys := make([]interface{}, 0, len(map_obj)) for k := range map_obj { keys = append(keys, k) } return keys } func GetValues(map_obj map[string]string, headers []string) []interface{} { values := make([]interface{}, 0, len(map_obj)) for _, header := range headers { value := map_obj[header] values = append(values, value) } return values } func InterfaceToStringSlice(ifaceSlice []interface{}) []string { strSlice := make([]string, len(ifaceSlice)) for i, v := range ifaceSlice { strSlice[i] = v.(string) } return strSlice } ","date":"2023-04-23","objectID":"/go%E8%AF%AD%E8%A8%80%E5%B0%86map%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5excel%E6%96%87%E4%BB%B6/:0:0","tags":["Go"],"title":"Go语言将Map数据写入EXCEL文件","uri":"/go%E8%AF%AD%E8%A8%80%E5%B0%86map%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5excel%E6%96%87%E4%BB%B6/"},{"categories":["Pandas","Python"],"content":"转载自https://blog.csdn.net/Asher117/article/details/84346073 ","date":"2023-04-18","objectID":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/:0:0","tags":["Python","Pandas"],"title":"Pandas 一列分多列，一行分多行，提取列中的要素，实现vlookup功能等","uri":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Pandas","Python"],"content":"摘要 在进行数据分析时，我们经常需要把DataFrame的一列拆成多列或者根据某列把一行拆成多行，这篇文章主要讲解这两个目标的实现。 读取数据 ","date":"2023-04-18","objectID":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/:1:0","tags":["Python","Pandas"],"title":"Pandas 一列分多列，一行分多行，提取列中的要素，实现vlookup功能等","uri":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Pandas","Python"],"content":"一列分多列 将City列转成多列（以|为分隔符）,这里使用匿名函数lambda来将City列拆成两列。 ","date":"2023-04-18","objectID":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/:1:1","tags":["Python","Pandas"],"title":"Pandas 一列分多列，一行分多行，提取列中的要素，实现vlookup功能等","uri":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Pandas","Python"],"content":"一行分多行 将DataFrame一行拆成多行（以|为分隔符） 方法一 在刚刚得到的DataFrame基础上操作,如下图所以，可以明显看到我们按照City列将DataFrame拆成了多行。主要是先将DataFrame拆成多列，然后拆成多个DataFrame再使用concat组合。但是这种方法碰到City列切割不均匀的时候可能会麻烦一点，因此，这个时候你可以使用万能方法二。 方法二 这个方法的主要思想是，首先将DataFrame中需要拆分的列进行拆分，再使用stack（）进行轴变换，然后通过index来join即可，如下所示。 首先，将刚刚的df还原成原始形式： 接下来取出其City列，并切分成多列之后轴转换，之后重新设置索引，并且重命名为Company 最后删除df里面的Country列，并将DataFrame-df1 使用join到df里面得到最后的结果。 ","date":"2023-04-18","objectID":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/:1:2","tags":["Python","Pandas"],"title":"Pandas 一列分多列，一行分多行，提取列中的要素，实现vlookup功能等","uri":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Pandas","Python"],"content":"正则提取某列的要素并按要素分列 有个csv表格（以逗号,作为分隔符），数据样本如下，其中电话号码列中电话号码的个数不确定： 姓名 性别 电话号码 张三 男 电话号码:13788881111;+86-18911112222;其码:86-17722221111;其号码:+86 13565459999;86 15366558877 王五 女 16535468764;+77-16888779512;+86 13565457898;其他+87-13544569871 使用pandas库结合正则表达式将第三列中的手机号码提取后每个号码单独成列，与原来的数据一起形成新的行。 预期结果： 姓名 性别 电话号码 (0, 0) (0, 1) (0, 2) (0, 3) (0, 4) 张三 男 电话号码:13788881111;+86-18911112222;其码:86-17722221111;其号码:+86 13565459999;86 15366558877 13788881111 18911112222 17722221111 13565459999 15366558877 王五 女 16535468764;+77-16888779512;+86 13565457898;其他+87-13544569871 16535468764 16888779512 13565457898 13544569871 ","date":"2023-04-18","objectID":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/:2:0","tags":["Python","Pandas"],"title":"Pandas 一列分多列，一行分多行，提取列中的要素，实现vlookup功能等","uri":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Pandas","Python"],"content":"实现代码一 import pandas as pd df = pd.read_csv('data.csv') # 使用简单的正则表达式提取所有的手机号码 phones = df[df.columns[2]].str.extractall(r'([1][345678][0-9]{9})') # 将提取出的Series展开为多列 phones = phones.unstack() # 将原df和phones拼接 df = pd.concat([df, phones], axis=1) df.to_excel(\"abc.xlsx\",index=False) ","date":"2023-04-18","objectID":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/:2:1","tags":["Python","Pandas"],"title":"Pandas 一列分多列，一行分多行，提取列中的要素，实现vlookup功能等","uri":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Pandas","Python"],"content":"实现代码二 import pandas as pd df = pd.read_csv('data.csv') def find_phone_number(text): ph_no = re.findall(r\"[1][345678][0-9]{9}\",text) return pd.Series(ph_no) df_phones=df[df.columns[2]].apply(lambda x: find_phone_number(x)) # 将原df和phones拼接 df = pd.concat([df, df_phones], axis=1) df.to_excel(\"abc2.xlsx\",index=False) ","date":"2023-04-18","objectID":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/:2:2","tags":["Python","Pandas"],"title":"Pandas 一列分多列，一行分多行，提取列中的要素，实现vlookup功能等","uri":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Pandas","Python"],"content":"其他正则表达式 卡号： [4][6][0][0-9]\\{12\\} 机身： [0-9]\\{14\\}\\|[0-9]\\{15\\} 提取[]内字符 (?\u003c=\\[)[^\\[\\]]*(?=\\]) ","date":"2023-04-18","objectID":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/:2:3","tags":["Python","Pandas"],"title":"Pandas 一列分多列，一行分多行，提取列中的要素，实现vlookup功能等","uri":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Pandas","Python"],"content":"实现vlookup功能 df1 = pd.DataFrame({ 'Name': ['John', 'Jane', 'Jack'], 'Age': [30, 25, 50], 'Address': ['New York', 'London', 'Sydney'] }) print(df1) df2 = pd.DataFrame({ 'Name': ['John', 'Ja1ck', 'Jane'], 'Phone': ['1234567890', '0987654321', '0123456789'] }) print('-'*100) print(df2) 输出： Name Age Address 0 John 30 New York 1 Jane 25 London 2 Jack 50 Sydney ---------------------------------------------------------------------------------------------------- Name Phone 0 John 1234567890 1 Ja1ck 0987654321 2 Jane 0123456789 result = df1.merge(df2, on='Name',how='left') # left：保留df1的所有行，right：保留df2的所有行 print(result) 输出: Name Age Address Phone 0 John 30 New York 1234567890 1 Jane 25 London 0123456789 2 Jack 50 Sydney NaN ","date":"2023-04-18","objectID":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/:3:0","tags":["Python","Pandas"],"title":"Pandas 一列分多列，一行分多行，提取列中的要素，实现vlookup功能等","uri":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Pandas","Python"],"content":"pandas的merge知识扩展 在pandas的.merge()方法中,how参数有几种JOIN方法: inner - 内连接。默认方法，只保留两个表共有的行。 outer - 外连接。保留两个表所有行,无匹配的用NaN填充。 left - 左连接。以左表为基准,保留左表所有行,右表无匹配的用NaN填充。 right - 右连接。以右表为基准,保留右表所有行,左表无匹配的用NaN填充。 cross - 笛卡尔乘积。每一个左表行与右表的每一行组合。 示例代码: df1 = pd.DataFrame({ 'Name': ['John', 'Jane', 'Jack'], 'Age': [30, 25, 50] }) print('-'*50,\"df1\",\"-\"*50,'\\n',df1) df2 = pd.DataFrame({ 'Name': ['John', 'Jack', 'Mike'], 'Address': ['New York', 'Sydney', 'London'] }) print('-'*50,\"df2\",\"-\"*50,'\\n',df2) # inner join result = df1.merge(df2, on='Name') print('-'*50,\"inner join\",\"-\"*50,'\\n',result) # outer join result = df1.merge(df2, on='Name', how='outer') print('-'*50,\"outer join\",\"-\"*50,'\\n',result) # left join result = df1.merge(df2, on='Name', how='left') print('-'*50,\"left join\",\"-\"*50,'\\n',result) # right join result = df1.merge(df2,on='Name',how='right') print('-'*50,\"right join\",\"-\"*50,'\\n',result) # cross join result = df1.merge(df2, how='cross') print('-'*50,\"cross join\",\"-\"*50,'\\n',result) 输出： -------------------------------------------------- df1 -------------------------------------------------- Name Age 0 John 30 1 Jane 25 2 Jack 50 -------------------------------------------------- df2 -------------------------------------------------- Name Address 0 John New York 1 Jack Sydney 2 Mike London -------------------------------------------------- inner join -------------------------------------------------- Name Age Address 0 John 30 New York 1 Jack 50 Sydney -------------------------------------------------- outer join -------------------------------------------------- Name Age Address 0 John 30.0 New York 1 Jane 25.0 NaN 2 Jack 50.0 Sydney 3 Mike NaN London -------------------------------------------------- left join -------------------------------------------------- Name Age Address 0 John 30 New York 1 Jane 25 NaN 2 Jack 50 Sydney -------------------------------------------------- right join -------------------------------------------------- Name Age Address 0 John 30.0 New York 1 Jack 50.0 Sydney 2 Mike NaN London -------------------------------------------------- cross join -------------------------------------------------- Name_x Age Name_y Address 0 John 30 John New York 1 John 30 Jack Sydney 2 John 30 Mike London 3 Jane 25 John New York 4 Jane 25 Jack Sydney 5 Jane 25 Mike London 6 Jack 50 John New York 7 Jack 50 Jack Sydney 8 Jack 50 Mike London ","date":"2023-04-18","objectID":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/:3:1","tags":["Python","Pandas"],"title":"Pandas 一列分多列，一行分多行，提取列中的要素，实现vlookup功能等","uri":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Pandas","Python"],"content":"多行合并一行 现有数据如下： 登录IP 用户ID 登录时间 操作记录 11.1.11.1 738322 2022/5/17 11:25 ABC 11.1.11.1 738322 2022/5/17 11:25 DEF 154.2.15.1 738765 2022/5/17 11:25 大大 11.1.11.3 738322 2022/5/17 11:25 GHI 使用pandas根据条件进行合并，条件是：登录IP、用户ID、登录时间三个字段的值都相同的情况下，将操作记录的值从上往下进行合并。 预期结果如下表： 登录IP 用户ID 登录时间 操作记录 ———— ——– —————– ——– 11.1.11.1 738322 2022/5/17 11:25 ABCDEF 154.2.15.1 738765 2022/5/17 11:25 大大 11.1.11.3 738322 2022/5/17 11:25 GHI 实现代码： import pandas as pd data = { '登录IP' : ['11.1.11.1', '11.1.11.1', '154.2.15.1', '11.1.11.3'], '用户ID' : [738322, 738322, 738765, 738322], '登录时间' : ['2022/5/17 11:25', '2022/5/17 11:25', '2022/5/17 11:25', '2022/5/17 11:25'], '操作记录' : ['ABC', 'DEF', '大大', 'GHI'] } df = pd.DataFrame(data) grouped = df.groupby(['登录IP', '用户ID', '登录时间']) result = grouped['操作记录'].agg(lambda x: ''.join(x)) print(result) 代码解析： 使用.groupby()按照三个字段进行分组 调用.agg(),传入lambda x: ''.join(x)对操作记录列进行字符串合并 最终实现了根据条件对指定列合并后的结果表 所以,掌握 .groupby()和.agg()这两个方法,可以轻松实现根据条件对指定列(特别是字符串列)进行各种统计和处理。 在实际工作中,这两个方法可以应用到大量数据处理的场景中,是数据分析和挖掘中的重要工具,熟练运用可以大大提高工作效率和质量。 见：https://segmentfault.com/q/1010000041855612/a-1020000041855836?_ea=236896464 ","date":"2023-04-18","objectID":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/:3:2","tags":["Python","Pandas"],"title":"Pandas 一列分多列，一行分多行，提取列中的要素，实现vlookup功能等","uri":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Pandas","Python"],"content":"QQ群成员分析 数据样本如下 QQ群号 群成员 群聊1 9758430 群聊1 4559318 群聊1 6962205 群聊1 4613618 群聊1 5734685 群聊1 6141414 群聊1 323030 群聊1 2344021 群聊1 7121977 群聊1 5081996 群聊1 8926421 群聊1 6745628 群聊1 3863137 群聊2 7676445 群聊2 6089608 群聊2 2995915 群聊2 482082 群聊2 531802 群聊2 4834330 群聊2 7692453 群聊2 2258744 群聊2 1026183 群聊2 225674 群聊2 7121977 群聊2 9926942 群聊2 5222292 群聊2 7436960 群聊2 8227345 群聊2 6992045 群聊2 8742475 群聊3 24016256 群聊3 90206526 群聊3 48341462 群聊3 24684071 群聊3 29748179 群聊3 6089608 群聊3 41037056 群聊3 90788423 群聊4 437351868 群聊4 207182601 群聊4 32875139 群聊4 371786257 群聊4 314738440 群聊4 469359518 群聊4 915810745 群聊4 593472861 群聊4 4613618 群聊4 90788423 群聊4 365482277 群聊4 656786903 群聊4 826146966 将重复出现在多个群的成员number及其所在群展示出来。 import pandas as pd df = pd.read_excel(\"QQ.xlsx\") # 找出出现在多个群的成员 duplicate_members = df.groupby('群成员').count().sort_values('QQ群号', ascending=False).loc[df.groupby('群成员').count()['QQ群号'] \u003e 1,:] # 展示重复出现的成员及所在的群 for member, groups in duplicate_members.iterrows(): print(f'成员{member}在以下群出现: ', end='') group_list = df.loc[df['群成员'] == member, 'QQ群号'].unique() print(*group_list, sep=', ') 输出 成员90788423在以下群出现: 群聊3, 群聊4 成员7121977在以下群出现: 群聊1, 群聊2 成员4613618在以下群出现: 群聊1, 群聊4 成员6089608在以下群出现: 群聊2, 群聊3 ","date":"2023-04-18","objectID":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:0","tags":["Python","Pandas"],"title":"Pandas 一列分多列，一行分多行，提取列中的要素，实现vlookup功能等","uri":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Pandas","Python"],"content":"找出只出现在一个群的成员 single_group_members = df[~df['群成员'].isin(duplicate_members.index)] print('只出现在一个群的成员:') for member in single_group_members['群成员'].unique(): print(member) 输出 只出现在一个群的成员: 9758430 4559318 6962205 5734685 6141414 ","date":"2023-04-18","objectID":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:1","tags":["Python","Pandas"],"title":"Pandas 一列分多列，一行分多行，提取列中的要素，实现vlookup功能等","uri":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Pandas","Python"],"content":"给定另一个群成员number列表，查找其是否在前面的群成员列表中 import pandas as pd df = pd.DataFrame({ \"name\": [\"John\", \"Alice\", \"Bob\", \"Jane\"], \"target\": [1, 2, 3, 4] }) readytocompare = [1, 2, 5] isin_series = df[df[\"target\"].isin(readytocompare)] isin_series 输出： name target 0 John 1 1 Alice 2 ","date":"2023-04-18","objectID":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:2","tags":["Python","Pandas"],"title":"Pandas 一列分多列，一行分多行，提取列中的要素，实现vlookup功能等","uri":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Pandas","Python"],"content":"关系可视化 import pandas as pd from pyecharts import options as opts from pyecharts.charts import Graph from pyecharts.commons.utils import JsCode # 读取表格数据 df = pd.read_excel(\"QQ.xlsx\") # 创建节点和边的列表 nodes = [] links = [] for group in df['QQ群号'].unique(): nodes.append({\"name\": group, \"symbolSize\": 50}) members = set(df[df['QQ群号']==group]['群成员']) for other_group in df[df['QQ群号']!=group]['QQ群号'].unique(): other_members = set(df[df['QQ群号']==other_group]['群成员']) common_members = members \u0026 other_members if common_members: links.append({ \"source\": group, \"target\": other_group, \"value\": len(common_members), \"common_members\": list(common_members) }) # 绘制关系图 graph = ( Graph() .add( \"\", nodes, links, repulsion=8000, edge_label=opts.LabelOpts( position=\"middle\", formatter=JsCode(\"function (params) {return params.data.common_members.join('\u003cbr/\u003e')}\"), font_size=10 ), label_opts=opts.LabelOpts(is_show=False), ) .set_global_opts( title_opts=opts.TitleOpts(title=\"Group Relations\"), tooltip_opts=opts.TooltipOpts( formatter=JsCode( \"function (params) {return 'Group: ' + params.data.name + '\u003cbr/\u003eMembers: ' + params.data.value.join('\u003cbr/\u003e')}\" ) ), ) ) graph.render(\"group_relations.html\") import pandas as pd from pyecharts import options as opts from pyecharts.charts import Graph # 读取表格数据 df = pd.read_excel(\"QQ.xlsx\") # 创建节点和边的列表 nodes = [] links = [] for group in df['QQ群号'].unique(): nodes.append({\"name\": group, \"symbolSize\": 50}) members = set(df[df['QQ群号']==group]['群成员']) for other_group in df[df['QQ群号']!=group]['QQ群号'].unique(): other_members = set(df[df['QQ群号']==other_group]['群成员']) common_members = members \u0026 other_members if common_members: links.append({ \"source\": group, \"target\": other_group, \"value\": len(common_members), \"common_members\": list(common_members) }) # 绘制关系图 graph = ( Graph() .add(\"\", nodes, links, repulsion=8000, edge_label=opts.LabelOpts( position=\"middle\", formatter=f\"{common_members}\\n\", font_size=10 )) .set_global_opts(title_opts=opts.TitleOpts(title=\"Group Relations\")) ) graph.render(\"group_relations.html\") ","date":"2023-04-18","objectID":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:3","tags":["Python","Pandas"],"title":"Pandas 一列分多列，一行分多行，提取列中的要素，实现vlookup功能等","uri":"/pandas%E4%B8%80%E5%88%97%E5%88%86%E5%A4%9A%E5%88%97%E4%B8%80%E8%A1%8C%E5%88%86%E5%A4%9A%E8%A1%8C%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Go"],"content":"解决离线（offline）环境下,go语言项目go mod tidy无法使用的问题。","date":"2023-04-14","objectID":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/","tags":["Go","mod"],"title":"解决离线环境下go语言项目依赖问题","uri":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"},{"categories":["Go"],"content":"思路： 实现原理：GOPROXY变量可以设置为本地目录的特点。 以下为实现方法（均为Windows系统） ","date":"2023-04-14","objectID":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/:0:0","tags":["Go","mod"],"title":"解决离线环境下go语言项目依赖问题","uri":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"},{"categories":["Go"],"content":"联网电脑上的操作 目的：将需要的包下载到移动硬盘 在移动硬盘根目录新建gomods文件夹； 使用set GOPATH=x:\\gomods将GOPATH临时设置为x:\\gomods， 新建一个项目（for_dl_mods）并初始化，在该项目中将需要的依赖写进去，如下： package main import ( // `_`意思只导入不使用 _ \"github.com/gocolly/colly\" _ \"github.com/tidwall/gjson\" ) 在该目录下使用go mod download命令，将会自动下载colly等依赖及其子依赖到x:\\gomods下， ","date":"2023-04-14","objectID":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/:0:1","tags":["Go","mod"],"title":"解决离线环境下go语言项目依赖问题","uri":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"},{"categories":["Go"],"content":"离线电脑上的操作 目的：将需要的包从移动硬盘自动复制到本地gopath中，并自动整理go.mod和go.sum两个文件。 4. 将移动硬盘插入离线机器， 5. 使用set GOPROXY=file:///x:\\gomods\\cache\\download将获取依赖的服务器指向本地目录(注意：file后面是三个/，路径使用\\符号) 6. 在开发的目录中运行go mod tidy。 第4、5步需要保持移动硬盘插在离线电脑上，如果不想这样，可以先从移动硬盘复制到离线电脑的本地磁盘，再相应改GOPROXY指向地址。 以上仍没有解决，因为go mod tidy会将下载的包与go官方进行一次哈希校验如下： main imports github.com/gocolly/colly: github.com/gocolly/colly@v1.2.0: verifying module: github.com/gocolly/colly@v1.2.0: Get \"https://sum.golang.org/lookup/github.com/gocolly/colly@v1.2.0\": dial tcp 142.251.42.241:443: connectex: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond. 参考文章： go-offline-packager https://pkg.go.dev/github.com/go-sharp/go-offline-packager#section-readme https://gist.github.com/gmolveau/f09c1038ca622620e54d0579ba06ea96 以下为备份 ","date":"2023-04-14","objectID":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/:0:2","tags":["Go","mod"],"title":"解决离线环境下go语言项目依赖问题","uri":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"},{"categories":["Go"],"content":"Using go mod vendor ","date":"2023-04-14","objectID":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/:1:0","tags":["Go","mod"],"title":"解决离线环境下go语言项目依赖问题","uri":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"},{"categories":["Go"],"content":"0 - With an existing module copy go.mod and go.sum files from the offline PC to the internet PC ","date":"2023-04-14","objectID":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/:1:1","tags":["Go","mod"],"title":"解决离线环境下go语言项目依赖问题","uri":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"},{"categories":["Go"],"content":"0bis - New module create a folder on the internet PC create a go module : go mod init test ","date":"2023-04-14","objectID":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/:1:2","tags":["Go","mod"],"title":"解决离线环境下go语言项目依赖问题","uri":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"},{"categories":["Go"],"content":"1 - Download dependencies via vendor folder create a offline_modules.go file : package offline_modules func main() {} add the dependencies you want to download (use _) : package offline_modules import ( _ \"github.com/gorilla/mux\" _ \"github.com/sirupsen/logrus\" ) func main() {} run go mod vendor the vendor folder should have new folders in it representing dependencies ","date":"2023-04-14","objectID":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/:1:3","tags":["Go","mod"],"title":"解决离线环境下go语言项目依赖问题","uri":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"},{"categories":["Go"],"content":"2 - Back to offline copy go.mod, go.sum and vendor paste them on your offline PC, edit go.mod module name if necessary run your go commands with the flag -mod=vendor like go run -mod=vendor main.go ","date":"2023-04-14","objectID":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/:1:4","tags":["Go","mod"],"title":"解决离线环境下go语言项目依赖问题","uri":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"},{"categories":["Go"],"content":"Using git TODO ","date":"2023-04-14","objectID":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/:2:0","tags":["Go","mod"],"title":"解决离线环境下go语言项目依赖问题","uri":"/%E8%A7%A3%E5%86%B3%E7%A6%BB%E7%BA%BF%E7%8E%AF%E5%A2%83%E4%B8%8Bgo%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"},{"categories":["Go"],"content":"Golang学习","date":"2023-04-12","objectID":"/golang%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93req%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":["Go","req"],"title":"Golang的网络请求库req学习笔记","uri":"/golang%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93req%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Go"],"content":" package main import ( \"fmt\" \"net/http\" \"strings\" \"sync\" \"time\" \"github.com/imroc/req/v3\" // 国人开发的强大网络请求库，有中文文档https://req.cool/zh/docs/prologue/introduction/ ) var ( errMsg ErrorMessage client = req.C(). // 在每个请求的请求级别启用转储，仅 // 暂时将转储内容存储在内存中，因此我们可以调用 // desp.dump（）在需要时获取转储内容中间件。 // EnableDumpEachRequest(). OnAfterResponse(func(client *req.Client, resp *req.Response) error { // 响应中间件 if resp.Err != nil { //当存在基本错误时忽略，例如网络错误。 return nil } // 将非成功响应视为错误，将原始转储内容记录在错误消息中。 if !resp.IsSuccessState() { // 状态代码不在200到299之间。 resp.Err = fmt.Errorf(\"bad response, raw content:\\n%s\", resp.Dump()) } return nil }). // 请求客户端统一设置参数 SetTimeout(60 * time.Second). SetCommonHeaders(map[string]string{ \"host\": \"12.15.5.172\", \"proxy-connection\": \"keep-alive\", \"content-length\": \"105\", \"accept\": \"application/json, text/javascript, */*; q=0.01\", \"origin\": \"https://httpbin.org\", \"x-requested-with\": \"XMLHttpRequest\", \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36\", \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\", \"referer\": \"https://httpbin.org\", \"accept-encoding\": \"gzip, deflate\", \"accept-language\": \"zh-CN,zh;q=0.9\", }) ) func main(){ // 默认开启自动解码，关闭自动解码如下 // client.DisableAutoDecode() // 设置代理 client.SetProxyURL(\"http://127.0.0.1:8889\") // 启用调试 client.EnableDebugLog() // 设置cookies cookieStr := fmt.Sprintf(\"cf_clearance=5v3CUcJ7MVgRn8u.Z1Gbiyso0; __Host-next-auth.csrf-token=88a2e1e11900d8fbb60c7a4aeb011a|830f6605; __Secure-next-auth.callback-url=https://chat.openai.com; _cfuvid=gXYxKWDPuZr_24800000; intercom-device-id-dgkjq2bp=b88f30WQ; _puid=user-FFb339PNbfoDI6RYvkzqkkbM:1680876948-=; __cf_bm=1IIT8Cdx=%s; intercom-session-dgkjq2bp=MWhSUGtrM3d0Rmp\", jwt) BatSetCookies(cookieStr, client) // POST请求 onMissionPostData := map[string]string{ \"caseTypeVal\": \"allType\", \"caseName\": \"\", \"startTime\": \"missionStart\", \"endTime\": \"missionEnd\", \"checkAllFlag\": \"0\", \"status\": \"0\", \"caseStatus\": \"\", } resp, err := client.R(). EnableForceMultipart(). // 请求级别临时设置请求头，一次设置多个标题 SetHeaders(map[string]string{ \"my-custom-header\": \"My Custom Value\", \"user\": \"imroc\", }). SetFormData(onMissionPostData). Post(url) if err != nil { log.Fatal(err) } fmt.Println(resp.String()) // GET请求 queryparam := \"abc\" url := \"https://httpbin.org/get\" headers := map[string]string{ \"Accept-Encoding\": \"gzip, deflate\", \"Accept-Language\": \"zh-CN,zh;q=0.9\", \"Upgrade-Insecure-Requests\": \"1\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36\", \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\", \"Referer\": \"\", \"Connection\": \"keep-alive\", } resp, _ := client.R(). SetQueryParams(map[string]string{ \"objId\": queryparam, \"objType\": \"1001\", }). // 一次设置多个字段的请求头 SetHeaders(headers). Get(url) fmt.Println(resp.String()) } func BatSetCookies(cookieStr string, client *req.Client) { // 根据字符串，批量设置Cookies cookiePairs := strings.Split(cookieStr, \";\") for _, pair := range cookiePairs { pair = strings.TrimSpace(pair) if len(pair) == 0 { continue } parts := strings.SplitN(pair, \"=\", 2) if len(parts) != 2 { continue } cookie := \u0026http.Cookie{ Name: parts[0], Value: parts[1], } client.SetCommonCookies(cookie) } } ","date":"2023-04-12","objectID":"/golang%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93req%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["Go","req"],"title":"Golang的网络请求库req学习笔记","uri":"/golang%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93req%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Go"],"content":"Golang 学习","date":"2023-04-11","objectID":"/colly%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":["Go","Colly","爬虫"],"title":"Colly学习笔记","uri":"/colly%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Go"],"content":"go语言爬虫框架Colly学习 https://darjun.github.io/2021/06/30/godailylib/colly/ 以下代码是自己结合ChatGPT的回答与测试的结果。 package main import ( \"fmt\" \"log\" \"net/http\" \"net/http/cookiejar\" \"net/url\" \"strings\" \"time\" \"github.com/gocolly/colly/v2\" \"github.com/gocolly/colly/v2/debug\" ) // 创建一个新的collector var c = colly.NewCollector( // 启用异步请求 colly.Async(true), colly.AllowURLRevisit(), // 附加调试器 colly.Debugger(\u0026debug.WebDebugger{}), // 下面是用法和区别 // 1. LogDebugger // colly.Debugger(\u0026debug.LogDebugger{}) // 控制台输入日志形如： // [000068] 1 [ 66 - responseHeaders] map[\"status\":\"OK\" \"url\":\"https://httpbin.org/post\"] (744.2505ms) // [000067] 1 [ 1 - responseHeaders] map[\"status\":\"OK\" \"url\":\"https://httpbin.org/cookies?param1=value1\u0026param2=value2\"] (744.2505ms) // 2. WebDebug,用网页展示请求状态，默认访问路径http://127.0.0.1:7676/ // colly.Debugger(\u0026debug.WebDebugger{}), // 结果形如： // Current Requests (1)# Finished Requests (115) // https://httpbin.org/post https://httpbin.org/post // Collector #1 - 2023-04-12T08:00:01.0840252+08:00 Collector #1 - 64.4904635s ) func init() { initialCookie := \u0026http.Cookie{ Name: \"initial_cookie\", Value: \"initial_value\", Domain: \"httpbin.org\", } // 创建一个新的cookiejar jar, _ := cookiejar.New(nil) hosturl, _ := url.Parse(\"https://httpbin.org\") jar.SetCookies(hosturl, []*http.Cookie{initialCookie}) // 创建一个自定义的http.Client，以使用设置好的cookiejar client := \u0026http.Client{ Jar: jar, } // 将自定义的http.Client设置为collector的客户端 c.SetClient(client) // 使用OnRequest回调为所有请求设置初始headers initialHeaders := map[string]string{ \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36\", \"Accept-Custom\": \"en-US,en;q=0.9\", } // 设置代理 err := c.SetProxy(\"http://127.0.0.1:8889\") if err != nil { log.Fatal(\"设置代理失败:\", err) } // 设置并发限制 c.Limit(\u0026colly.LimitRule{ DomainGlob: \"*\", Parallelism: 5, // 设置并发数 RandomDelay: 5 * time.Second, }) // 使用OnRequest回调处理请求 c.OnRequest(func(r *colly.Request) { if r.Method == \"GET\" { fmt.Println(\"👉正准备发起GET请求，当前处于请求前中间件函数\") } else if r.Method == \"POST\" { fmt.Println(\"👆正准备发起POST请求，当前处于请求前中间件函数\") } // 设置初始headers for k, v := range initialHeaders { r.Headers.Set(k, v) } // 根据URL路径临时修改headers if strings.Contains(r.URL.Path, \"headers\") { r.Headers.Set(\"Custom-Header\", \"Custom-Value\") } }) } func main() { // 设置访问的URL urls := []string{\"https://httpbin.org/cookies\", \"https://httpbin.org/html\", \"https://httpbin.org/headers\"} // 某一个URL请求成功后，Colly将会自动调用该函数进行响应的处理，此处写响应处理逻辑。 c.OnResponse(func(r *colly.Response) { // 根据请求URL路径，选择不同的处理方法，此处嵌套调用c.OnHTML url := r.Request.URL.String() // 请求的URL if strings.Contains(url, \"https://httpbin.org/html\") { c.OnHTML(\"body h1\", func(e *colly.HTMLElement) { fmt.Println(\"Processing HTML response...\", e.Text) }) } else { // 在这里处理其他类型的响应 fmt.Println(\"Processing non-HTML response...\", string(r.Body)) } // fmt.Println(time.Now().Format(\"2006-01-02 15:04:05\"), \"Finished Visited URL:\", r.Request.URL, r.Request.Method) // if r.Request.Method == \"POST\" { // fmt.Println(r.Request.Body) // } // fmt.Println(\"Response body:\", string(r.Body)) }) // 使用Visit方法开始抓取(Visit方法只能实现GET请求) 同时也是并发测试 for _, baseURL := range urls { // 设置查询参数 queryParams := url.Values{} queryParams.Add(\"param1\", \"value1\") queryParams.Add(\"param2\", \"value2\") // 将查询参数附加到基本URL requestURL := fmt.Sprintf(\"%s?%s\", baseURL, queryParams.Encode()) err := c.Visit(requestURL) if err != nil { fmt.Println(\"Visit error:\", err) } } // POST请求 同时也是并发测试 for i := 1; i \u003c 10; i += 2 { postURL := \"https://httpbin.org/post\" postData := map[string]string{ \"param1\": fmt.Sprintf(\"%d\", i), \"param2\": \"value2\", } err := c.Post(postURL, postData) if err != nil { log.Println(\"POST request error:\", err) } } // 等待所有请求完成——开启异步时需要该设置 c.Wait() } 输出结果（部分省略） C:\\Users\\admin\\Desktop\\Colly学习\u003ego run . 👉正准备发起GET请求，当前处于请求前中间件函数 👆正准备发起POST请求，当前处于请求前中间件函数 👉正准备发起GET请求，当前处于请求前中间件函数 👆正准备发起POST请求，当前处于请求前中间件函数 👆正准备发起POST请求，当前处于请求前中间件函数 👆正准备发起POST请求，当前处于请求前中间件函数 👆正准备发起POST请求，当前处于请求前中间件函数 👆正准备发起POST请求，当前处于请求前中间件函数 👆正准备发起POST请求，当前处于请求前中间件函数 👉正准备发起GET请求，当前处于请求前中间件函数 2023-04-11 23:0","date":"2023-04-11","objectID":"/colly%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["Go","Colly","爬虫"],"title":"Colly学习笔记","uri":"/colly%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Go"],"content":"自定义参数的传递 package main import ( \"fmt\" \"github.com/gocolly/colly/v2\" ) func main() { // 初始化collector c := colly.NewCollector() // 设置访问url url := \"https://www.httpbin.org/headers\" // 在请求之前处理 c.OnRequest(func(r *colly.Request) { fmt.Println(\"Visiting\", r.URL.String()) // 使用Context传递自定义参数 r.Ctx.Put(\"customData\", \"Hello, I'm custom data!\") }) // 处理响应 c.OnResponse(func(r *colly.Response) { // 从Context中获取自定义参数 customData := r.Ctx.Get(\"customData\") fmt.Printf(\"获取传递的自定义参数: %s\\n\", customData) }) // 开始爬取 err := c.Visit(url) if err != nil { fmt.Println(\"Error:\", err) } } ","date":"2023-04-11","objectID":"/colly%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["Go","Colly","爬虫"],"title":"Colly学习笔记","uri":"/colly%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Go"],"content":"在Visit或Post方法中传递自定义参数给Onresponse方法 这种情形用于每个不同的请求，自定义参数给下一个环节的response处理。 package main import ( \"fmt\" \"github.com/gocolly/colly/v2\" ) func main() { // 初始化collector c := colly.NewCollector() // 设置访问url url := \"https://www.example.com\" // 在请求之前处理 c.OnRequest(func(r *colly.Request) { fmt.Println(\"Visiting\", r.URL.String()) }) // 处理响应 c.OnResponse(func(r *colly.Response) { // 从Context中获取自定义参数 customData := r.Ctx.Get(\"customData\") fmt.Printf(\"Response received, customData: %s\\n\", customData) }) // 创建一个新的Context ctx := colly.NewContext() ctx.Put(\"customData\", \"Hello, I'm custom data!\") // 使用WithContext方法在访问时传入自定义Context err := c.Request(\"GET\", url, nil, ctx, nil) // 使用`Request`方法——（`Visit`和`Post`的底层实现） if err != nil { fmt.Println(\"Error:\", err) } } 不过,如果任务足够复杂或具有不同类型的子任务，建议对一个抓取作业使用多个Collector。比如一个解析列表视图并处理分页，另一个收集详细信息。 使用多个Collector的中文例子:https://darjun.github.io/2021/06/30/godailylib/colly/ 官方例子：https://go-colly.org/docs/best_practices/multi_collector/ ","date":"2023-04-11","objectID":"/colly%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["Go","Colly","爬虫"],"title":"Colly学习笔记","uri":"/colly%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Go"],"content":"利用Context计算请求耗时 package main import ( \"fmt\" \"time\" \"github.com/gocolly/colly/v2\" ) func main() { // 初始化collector c := colly.NewCollector() // 设置访问url url := \"https://www.163.com\" // 在请求之前处理 c.OnRequest(func(r *colly.Request) { fmt.Println(\"Visiting\", r.URL.String()) // 记录请求开始时间 startTime := time.Now() // 使用Context传递请求开始时间，将时间转换为字符串 r.Ctx.Put(\"startTime\", startTime.Format(time.RFC3339Nano)) }) // 处理响应 c.OnResponse(func(r *colly.Response) { // 从Context中获取请求开始时间，将字符串转换为time.Time类型 startTimeStr := r.Ctx.Get(\"startTime\") startTime, err := time.Parse(time.RFC3339Nano, startTimeStr) if err != nil { fmt.Println(\"Error:\", err) return } // 计算请求耗时 duration := time.Since(startTime) fmt.Printf(\"Response received, duration: %v\\n\", duration) }) // 开始爬取 err := c.Visit(url) if err != nil { fmt.Println(\"Error:\", err) } } ","date":"2023-04-11","objectID":"/colly%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["Go","Colly","爬虫"],"title":"Colly学习笔记","uri":"/colly%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":" CSS选择器做游戏 https://flukeout.github.io/ https://codepen.io/jnani/pen/JRwPWO?editors=1100 这个最屌 https://www.w3schools.com/cssref/trysel.php Click the CSS Selectors and see the specified element(s) get selected. 单击左边列出的CSS选择器表达式，对应被选择的元素（集）会高亮显示。 菜鸟教程网的css选择测试工具，可以在左上角输入html源码，右上角输入css定位语法及其相应字体颜色等来查看定位到的元素。 https://c.runoob.com/front-end/61/ 在Chrome的开发者工具检查元素选项卡中，按Ctrl+F显示的输入框中直接输入css语法可定位到元素。 CSS语法说明:https://www.runoob.com/cssref/css-selectors.html 最最方便的方法，在html文件同目录新建css文件abc.css，同时在html的head标签中引用该css文件，然后开启html的live preview，边在abc.css文件中编写，边观察html的预览效果，引用abc.css文件方法： \u003chead\u003e \u003clink rel=\"stylesheet\" href=\"详情.css\"\u003e \u003c/head\u003e ","date":"2023-04-09","objectID":"/css-%E9%80%89%E6%8B%A9%E5%99%A8selector%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95%E7%BD%91%E7%AB%99/:0:0","tags":null,"title":"CSS 选择器（Selector）学习及相关在线测试网站","uri":"/css-%E9%80%89%E6%8B%A9%E5%99%A8selector%E5%AD%A6%E4%B9%A0%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%95%E7%BD%91%E7%AB%99/"},{"categories":null,"content":" 问: 已有精简版的windows镜像，镜像中不含简体中文语言包，我要怎么样将中文语言包添加进去，再封装成ISO ChatGPT 为了将简体中文语言包添加到精简版的Windows镜像中，并将其重新封装为ISO文件，请按照以下步骤操作： 准备工具和文件： a. 下载 Windows ADK（Windows Assessment and Deployment Kit）工具包，它包含用于自定义和部署Windows映像的工具。下载地址：https://docs.microsoft.com/en-us/windows-hardware/get-started/adk-install b. 下载简体中文语言包（请注意，选择与镜像相匹配的Windows版本）。语言包可以从以下链接下载：https://www.microsoft.com/en-us/language c. 准备一个精简版的Windows镜像。 2. 安装Windows ADK并选择Deployment Tools组件进行安装。 3. 以管理员身份运行“部署和映像工具环境”。 4. 将Windows镜像文件（install.wim）从原始ISO文件中提取出来。如果已有精简版的镜像文件，请跳过此步骤。 5. 创建一个新的文件夹，用于存放提取出的Windows映像文件和语言包文件。 6. 使用DISM（Deployment Image Servicing and Management）工具将Windows映像挂载到新创建的文件夹中： dism /Mount-Image /ImageFile:\"\u003cWIM文件路径\u003e\\install.wim\" /Index:1 /MountDir:\"\u003c挂载目录路径\u003e\" 请将\u003cWIM文件路径\u003e替换为实际的WIM文件路径，将\u003c挂载目录路径\u003e替换为实际的挂载目录路径。 7. 将简体中文语言包添加到挂载的Windows映像中： dism /Image:\"\u003c挂载目录路径\u003e\" /Add-Package /PackagePath:\"\u003c语言包文件路径\u003e\" 请将\u003c挂载目录路径\u003e替换为实际的挂载目录路径，将\u003c语言包文件路径\u003e替换为实际的简体中文语言包文件路径。 8. 等待操作完成后，卸载Windows映像并提交更改： dism /Unmount-Image /MountDir:\"\u003c挂载目录路径\u003e\" /Commit 请将\u003c挂载目录路径\u003e替换为实际的挂载目录路径。 9. 用新生成的install.wim文件替换原始ISO中的install.wim文件。可以使用任何支持编辑ISO文件的工具，例如PowerISO、UltraISO等。 10. 保存修改后的ISO文件。 现在你已经成功地将简体中文语言包添加到了精简版的Windows镜像中，并重新封装成了ISO文件。在安装时，可以选择简体中文作为系统语言。 问: 完成以上步骤，系统默认设置是不是中文语言，默认“当前系统区域设置”是不是中文 ChatGPT 完成以上步骤后，虽然已经将简体中文语言包添加到了Windows镜像中，但系统默认设置和“当前系统区域设置”仍然可能不是中文。要将默认设置更改为中文，您需要在安装过程中进行设置，或在系统安装完成后手动更改。 如果您希望在安装过程中将默认设置更改为中文，可以创建一个自动应答文件（autounattend.xml），并将其放置在安装媒体（如U盘、ISO文件）的根目录中。以下是一个简化的autounattend.xml示例，用于设置系统默认语言为简体中文： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cunattend xmlns=\"urn:schemas-microsoft-com:unattend\"\u003e \u003csettings pass=\"oobeSystem\"\u003e \u003ccomponent name=\"Microsoft-Windows-International-Core\" processorArchitecture=\"amd64\" publicKeyToken=\"31bf3856ad364e35\" language=\"neutral\" versionScope=\"nonSxS\" xmlns:wcm=\"http://schemas.microsoft.com/WMIConfig/2002/State\"\u003e \u003cInputLocale\u003ezh-CN\u003c/InputLocale\u003e \u003cSystemLocale\u003ezh-CN\u003c/SystemLocale\u003e \u003cUILanguage\u003ezh-CN\u003c/UILanguage\u003e \u003cUserLocale\u003ezh-CN\u003c/UserLocale\u003e \u003c/component\u003e \u003c/settings\u003e \u003c/unattend\u003e 这个文件会在Windows安装过程中自动应用，将系统默认设置更改为简体中文。 问: 能不能在封装前设置好？ ChatGPT 在封装前设置好默认语言为简体中文，需要修改Windows镜像中的注册表。以下是在封装前将默认设置更改为中文的方法： 在完成添加简体中文语言包的步骤之后，但在卸载Windows映像并提交更改之前，请执行以下命令，将注册表加载到一个临时位置： reg load HKLM\\TempHive \"\u003c挂载目录路径\u003e\\Windows\\System32\\config\\SYSTEM\" 请将\u003c挂载目录路径\u003e替换为实际的挂载目录路径。 2. 使用以下命令更改默认输入法、系统语言、界面语言和用户区域设置： reg add \"HKLM\\TempHive\\ControlSet001\\Control\\Nls\\Language\" /v InstallLanguage /t REG_SZ /d 0804 /f reg add \"HKLM\\TempHive\\ControlSet001\\Control\\Nls\\Locale\" /v Default /t REG_SZ /d 00000804 /f reg add \"HKLM\\TempHive\\ControlSet001\\Control\\Nls\\Locale\" /v InstallLanguage /t REG_SZ /d 00000804 /f reg add \"HKLM\\TempHive\\ControlSet001\\Control\\Nls\\Locale\" /v SystemDefaultUILanguage /t REG_SZ /d 0804 /f reg add \"HKLM\\TempHive\\ControlSet001\\Control\\Nls\\Locale\" /v SystemLocale /t REG_SZ /d 00000804 /f reg add \"HKLM\\TempHive\\ControlSet001\\Control\\Nls\\Locale\" /v UserDefaultUILanguage /t REG_SZ /d 0804 /f reg add \"HKLM\\TempHive\\ControlSet001\\Control\\Nls\\Locale\" /v UserLocale /t REG_SZ /d 00000804 /f 卸载临时位置的注册表： reg unload HKLM\\TempHive 继续执行卸载Windows映像并提交更改的步骤： dism /Unmount-Image /MountDir:\"\u003c挂载目录路径\u003e\" /Commit 请将\u003c挂载目录路径\u003e替换为实际的挂载目录路径。 5. 用新生成的install.wim文件替换原始ISO中的install.wim文件，然后保存修改后的ISO文件。 完成这些步骤后，新生成的ISO文件将具有预先设置为简体中文的默认设置。在安装此镜像时，系统默认设置和“当前系统区域设置”将为简体中文。 ","date":"2023-03-17","objectID":"/%E4%B8%BA%E8%8B%B1%E6%96%87win%E9%95%9C%E5%83%8F%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%87%E8%AF%AD%E8%A8%80%E5%8C%85/:0:0","tags":null,"title":"为英文WIN镜像添加中文语言包","uri":"/%E4%B8%BA%E8%8B%B1%E6%96%87win%E9%95%9C%E5%83%8F%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%87%E8%AF%AD%E8%A8%80%E5%8C%85/"},{"categories":null,"content":"背景 小主机（CentOS 7）挂载移动固态硬盘，有次重启系统后，突然开不了机，发现硬盘盒不亮灯了，平时数据都存在挂载的移动固态硬盘里，所以估计移动硬盘挂了。同时小主机内置emmc里还有数据也需要备份，所以需要找一款能在windows下打开浏览Linux格式硬盘的软件。 ","date":"2023-03-16","objectID":"/windows%E4%B8%8B%E6%81%A2%E5%A4%8Dlinux%E6%A0%BC%E5%BC%8F%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95/:1:0","tags":["Linux","恢复","Windows"],"title":"Windows下恢复Linux格式硬盘数据记录","uri":"/windows%E4%B8%8B%E6%81%A2%E5%A4%8Dlinux%E6%A0%BC%E5%BC%8F%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"寻找历程 一番寻找后发现UFS_Explorer才是需要的，期间还有DiskInternals Linux Reader 4.15.2、ext2explore-2.2.71等都试了，不是不支持我硬盘的格式，就是需要付费使用。尝试之后UFS_Explorer才符合我的需求，故记录在此，供自己以后查看。 ","date":"2023-03-16","objectID":"/windows%E4%B8%8B%E6%81%A2%E5%A4%8Dlinux%E6%A0%BC%E5%BC%8F%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95/:2:0","tags":["Linux","恢复","Windows"],"title":"Windows下恢复Linux格式硬盘数据记录","uri":"/windows%E4%B8%8B%E6%81%A2%E5%A4%8Dlinux%E6%A0%BC%E5%BC%8F%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"软件地址 阿里云盘中，搜索即得。 ","date":"2023-03-16","objectID":"/windows%E4%B8%8B%E6%81%A2%E5%A4%8Dlinux%E6%A0%BC%E5%BC%8F%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95/:3:0","tags":["Linux","恢复","Windows"],"title":"Windows下恢复Linux格式硬盘数据记录","uri":"/windows%E4%B8%8B%E6%81%A2%E5%A4%8Dlinux%E6%A0%BC%E5%BC%8F%E7%A1%AC%E7%9B%98%E6%95%B0%E6%8D%AE%E8%AE%B0%E5%BD%95/"},{"categories":["gis"],"content":"背景 已知多边形A（{\"Type\":\"MultiPolygon\"}）以及其包含的多个子多边形（均为MultiPolygon）的GPS坐标，求多边形A包含的剩余1个子多边形的GPS坐标。 import geopandas as gpd from shapely.ops import unary_union, polygonize import pandas as pd # 读取geojson文件并转换为GeoDataFrame类型的数据 data = gpd.read_file('长沙市（缺一）.json') # 将所有多边形合并成一个单独的多边形 polygons = unary_union(data.geometry) # 将合并后的多边形转换为镂空多边形F,polygonize函数为关键 holes = list(polygonize(polygons)) # 将镂空多边形F转换为GeoDataFrame类型的数据 gdf_F = gpd.GeoDataFrame(geometry=holes, crs=data.crs) gdf_F['type'] = 'F' # 将A、B、C、D、E转换为GeoDataFrame类型的数据 gdf_ABCDE = data.copy() gdf_ABCDE['type'] = gdf_ABCDE.index # 将镂空多边形F和A、B、C、D、E合并为一个GeoDataFrame gdf = gpd.GeoDataFrame(pd.concat([gdf_F, gdf_ABCDE], ignore_index=True), crs=data.crs) # 将GeoDataFrame类型的数据保存为geojson文件 gdf.to_file('长沙市（补全）.json', driver='GeoJSON') ","date":"2023-03-11","objectID":"/%E8%AE%A1%E7%AE%97%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%95%82%E7%A9%BA%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%9D%90%E6%A0%87/:1:0","tags":["geo","Python","gis","geopandas","chatgpt"],"title":"计算多边形镂空区域的坐标","uri":"/%E8%AE%A1%E7%AE%97%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%95%82%E7%A9%BA%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%9D%90%E6%A0%87/"},{"categories":["gis"],"content":"样本 长沙市（缺一）.rar ","date":"2023-03-11","objectID":"/%E8%AE%A1%E7%AE%97%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%95%82%E7%A9%BA%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%9D%90%E6%A0%87/:1:1","tags":["geo","Python","gis","geopandas","chatgpt"],"title":"计算多边形镂空区域的坐标","uri":"/%E8%AE%A1%E7%AE%97%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%95%82%E7%A9%BA%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%9D%90%E6%A0%87/"},{"categories":["gis"],"content":"ChatGPT给出的分析解答过程 ChatGPT: 在Python中实现求被多个多边形包围的镂空多边形可以使用Shapely和Geopandas库。下面是一种可能的实现方法： import geopandas as gpd from shapely.geometry import Polygon, MultiPolygon # 创建多边形A、B、C、D、E polygon_a = Polygon([(0, 0), (0, 1), (1, 1), (1, 0)]) polygon_b = Polygon([(1, 0), (1, 1), (2, 1), (2, 0)]) polygon_c = Polygon([(0, 1), (0, 2), (1, 2), (1, 1)]) polygon_d = Polygon([(1, 1), (1, 2), (2, 2), (2, 1)]) polygon_e = Polygon([(2, 0), (2, 1), (3, 1), (3, 0)]) # 将多边形A、B、C、D、E合并成一个Multipolygon multi_polygon = MultiPolygon([polygon_a, polygon_b, polygon_c, polygon_d, polygon_e]) # 创建要裁剪的多边形F polygon_f = Polygon([(0.5, 0.5), (0.5, 1.5), (1.5, 1.5), (1.5, 0.5)]) # 将多边形F转换成Geopandas的GeoDataFrame类型 gdf_f = gpd.GeoDataFrame(geometry=[polygon_f], crs=\"EPSG:4326\") # 对多边形F进行裁剪 result = gdf_f.geometry.difference(multi_polygon) # 输出结果 print(result) 输出结果为： 0 POLYGON ((0.50000 1.00000, 0.50000 0.50000, 1... dtype: geometry 这表示被多边形A、B、C、D、E包围的镂空多边形F的GPS坐标为POLYGON ((0.50000 1.00000, 0.50000 0.50000, 1...。 我: 多边形A,B,C,D,E均为multipolygon类型 ChatGPT: 如果多边形A、B、C、D、E均为MultiPolygon类型，那么可以按照以下方式修改上面的代码： import geopandas as gpd from shapely.geometry import Polygon, MultiPolygon # 创建MultiPolygon类型的多边形A、B、C、D、E multi_polygon_a = MultiPolygon([Polygon([(0, 0), (0, 1), (1, 1), (1, 0)]), Polygon([(1, 0), (1, 1), (2, 1), (2, 0)])]) multi_polygon_b = MultiPolygon([Polygon([(0, 0), (0, -1), (-1, -1), (-1, 0)]), Polygon([(-1, 0), (-1, -1), (-2, -1), (-2, 0)])]) multi_polygon_c = MultiPolygon([Polygon([(0, 1), (0, 2), (1, 2), (1, 1)]), Polygon([(1, 1), (1, 2), (2, 2), (2, 1)])]) multi_polygon_d = MultiPolygon([Polygon([(0, 0), (0, -1), (-1, -1), (-1, 0)]), Polygon([(0, 0), (0, -1), (1, -1), (1, 0)])]) multi_polygon_e = MultiPolygon([Polygon([(1, 0), (1, -1), (2, -1), (2, 0)]), Polygon([(2, 0), (2, -1), (3, -1), (3, 0)])]) # 将多边形A、B、C、D、E合并成一个MultiPolygon multi_polygon = multi_polygon_a.union(multi_polygon_b).union(multi_polygon_c).union(multi_polygon_d).union(multi_polygon_e) # 创建要裁剪的多边形F polygon_f = Polygon([(0.5, 0.5), (0.5, 1.5), (1.5, 1.5), (1.5, 0.5)]) # 将多边形F转换成Geopandas的GeoDataFrame类型 gdf_f = gpd.GeoDataFrame(geometry=[polygon_f], crs=\"EPSG:4326\") # 对多边形F进行裁剪 result = gdf_f.geometry.difference(multi_polygon) # 输出结果 print(result) 上述代码中，multi_polygon_a、multi_polygon_b、multi_polygon_c、multi_polygon_d和multi_polygon_e是MultiPolygon类型的多边形A、B、C、D、E。将它们合并成一个MultiPolygon类型的对象multi_polygon，然后对多边形F进行裁剪，输出结果即为被多个多边形包围的镂空多边形F的GPS坐标。 我: 继续该话题 ChatGPT: 如果多边形A、B、C、D、E均为MultiPolygon类型，可以将上述代码中的多边形A、B、C、D、E的定义替换为如下代码： # 创建MultiPolygon类型的多边形A polygon_a1 = Polygon([(0, 0), (0, 1), (1, 1), (1, 0)]) polygon_a2 = Polygon([(1, 0), (1, 1), (2, 1), (2, 0)]) multi_polygon_a = MultiPolygon([polygon_a1, polygon_a2]) # 创建MultiPolygon类型的多边形B polygon_b1 = Polygon([(0, 0), (0, -1), (-1, -1), (-1, 0)]) polygon_b2 = Polygon([(-1, 0), (-1, -1), (-2, -1), (-2, 0)]) multi_polygon_b = MultiPolygon([polygon_b1, polygon_b2]) # 创建MultiPolygon类型的多边形C polygon_c1 = Polygon([(0, 1), (0, 2), (1, 2), (1, 1)]) polygon_c2 = Polygon([(1, 1), (1, 2), (2, 2), (2, 1)]) multi_polygon_c = MultiPolygon([polygon_c1, polygon_c2]) # 创建MultiPolygon类型的多边形D polygon_d1 = Polygon([(0, 0), (0, -1), (-1, -1), (-1, 0)]) polygon_d2 = Polygon([(0, 0), (0, -1), (1, -1), (1, 0)]) multi_polygon_d = MultiPolygon([polygon_d1, polygon_d2]) # 创建MultiPolygon类型的多边形E polygon_e1 = Polygon([(1, 0), (1, -1), (2, -1), (2, 0)]) polygon_e2 = Polygon([(2, 0), (2, -1), (3, -1), (3, 0)]) multi_polygon_e = MultiPolygon([polygon_e1, polygon_e2]) 然后，继续使用上述代码中的其余部分即可。 我: 继续 ChatGPT: 好的，那我们继续。根据上述代码，我们得到了五个多边形A、B、C、D、E，它们均为MultiPolygon类型。下面，我们使用Python中的shapely库来求被这些多边形包围的镂空多边形F的GPS坐标。 首先，我们需要导入必要的库和定义五个多边形A、B、C、D、E。这部分代码如下： from shapely.geometry import Polygon, MultiPolygon from shapely.ops import unary_union, polygonize # 创建MultiPolygon类型的多边形A polygon_a1 = Polygon([(0, 0), (0, 1), (1, 1), (1, 0)]) polygon_a2 = Polygon([(1, 0), (1, 1), (2, 1), (2, 0)]) multi_polygon_a = MultiPolygon([polygon_a1, polygon_a2]) # 创建MultiPolygon类型的多边形B polygon_b1 = Polygon([(0, 0), (","date":"2023-03-11","objectID":"/%E8%AE%A1%E7%AE%97%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%95%82%E7%A9%BA%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%9D%90%E6%A0%87/:2:0","tags":["geo","Python","gis","geopandas","chatgpt"],"title":"计算多边形镂空区域的坐标","uri":"/%E8%AE%A1%E7%AE%97%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%95%82%E7%A9%BA%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%9D%90%E6%A0%87/"},{"categories":null,"content":" import json import geojson from shapely.geometry import shape def determine_geometry(coords: list): # 改装自https://stackoverflow.com/a/73100925 if not coords: return \"invalid geometry\" if isinstance(coords[0], (int, float)): return \"Point\" if len(coords) \u003e= 2 else \"incomplete/invalid\" elif isinstance(coords[0], list): # line, polygon or other if len(coords) \u003e= 2 and isinstance(coords[0][0], (int, float)): # LineString or MultiPoint return \"LineString\" elif isinstance(coords[0][0], list): if isinstance(coords[0][0][0], (int, float)): return \"Polygon\" if len(coords) \u003e 1 else \"Polygon\" # Polygon else: # probably MultiPolygon return \"MultiPolygon\" def to_wkt(coordinates: list): type_ = determine_geometry(coordinates) GeoJson = {\"coordinates\": coordinates, \"type\": type_} s = json.dumps(GeoJson) try: g1 = geojson.loads(s) except: pass return shape(g1).wkt ","date":"2023-03-06","objectID":"/%E5%88%A4%E6%96%AD%E5%9D%90%E6%A0%87%E9%9B%86coordinates%E7%9A%84%E5%87%A0%E4%BD%95%E7%B1%BB%E5%9E%8B/:0:0","tags":null,"title":"判断坐标集coordinates的几何类型","uri":"/%E5%88%A4%E6%96%AD%E5%9D%90%E6%A0%87%E9%9B%86coordinates%E7%9A%84%E5%87%A0%E4%BD%95%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"概述 为了搭建一个开箱即用的Python开发环境，结合个人平时用到的场景，将常用的Python库封装进Docker容器中，实现换电脑后可迅速重建开发环境，同时也是用于内网（无法连接互联网）环境的开发环境快速准确搭建。遂有此文： ","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:1:0","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"Jupyter官方容器关系图，供选择时参考 https://jupyter-docker-stacks.readthedocs.io/en/latest/using/selecting.html#image-relationships 经测试，base、minimal等容器开启后的默认状态（不启动Python等内核）内存消耗都差不多，都是 85M 左右。 ","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:1:1","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"常用启动参数 ","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:2:0","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"重启jupyter内核不会重启容器 -e RESTARTABLE=yes 所有的容器默认启动JupyterLab，要改回传统的Notebook，需要指定变量DOCKER_STACKS_JUPYTER_CMD参数来启动： DOCKER_STACKS_JUPYTER_CMD 后端 前端 lab (default) Jupyter Server JupyterLab notebook Jupyter Notebook Jupyter Notebook nbclassic Jupyter Server Jupyter Notebook server Jupyter Server None retro* Jupyter Server RetroLab ","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:2:1","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"最高权限运行 默认情况下jovyan用户不能使用sudu权限，也不能通过为该用户设置密码来获得root权限，这是为了暴露在公网上的jupyterlab容器的安全。但是，有一个名为GRANT_SUDO的环境变量改变这一点。以下启动将赋予jovyan用户无需密码的root权限: docker run -it --rm -p 8888:8888 -e GRANT_SUDO=yes --user root gcr.io/kubeflow-images-staging/tensorflow-notebook-cpu ","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:2:2","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"选择JupyterLab JupyterLab具有更方便的布局、更完善的插件支持等等，改用JupyterLab。 自行构建可参考：https://www.cnblogs.com/ulysessweb/p/14317515.html 关键是apt-get安装库文件之前使用USER root来使用root权限进行安装，否则安装不了，库文件安全之后，改回官方提供的默认用户USER $NB_UID进行Python包安装 ","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:3:0","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"自定义密码 https://jupyter-docker-stacks.readthedocs.io/en/latest/using/common.html#jupyter-server-options ","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:3:1","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"中文包 pip install jupyterlab-language-pack-zh-CN ","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:3:2","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"自定义构建 成品镜像 以下Dockerfile对应镜像地址：https://hub.docker.com/r/blackelks/jupyterlab-datascience Dockerfile 构建命令docker build -t docker.io/blackelks/jupyterlab-datascience . FROM jupyter/datascience-notebook # 安装lsp自动补全插件、excel查看插件,中文语言包、 onedarkpro主题、 创建硬链接（lsp官方推荐） RUN pip install --no-cache-dir jupyterlab-language-pack-zh-CN jupyterlab-lsp 'python-lsp-server[all]' jupyterlab-drawio \\ \u0026\u0026 jupyterlab_execute_time pyinstall openpyxl xlrd XlsxWriter xlutils xlwings xlwt pdfminer python-docx docx2pdf \\ \u0026\u0026 pyexecjs selenium aiohttp httpx feapder[all] beautifulsoup4 requests lxml html5lib playwright matplotlib_inline \\ \u0026\u0026 opencv-python matplotlib pyecharts scipy plotly wordcloud flask django fastapi psycopg2-binary pymongo sqlalchemy \\ \u0026\u0026 pymysql pandas geopandas jieba tqdm unzip ddddocr loguru lars -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com \\ \u0026\u0026 playwright install \u0026\u0026 ln -s / .lsp_symlink RUN jupyter labextension install jupyterlab_onedarkpro RUN jupyter labextension install jupyterlab-spreadsheet # 设置显示语言为中文 RUN mkdir -p /home/jovyan/.jupyter/lab/user-settings/@jupyterlab/translation-extension/ \\ \u0026\u0026 echo '{\"locale\":\"zh_CN\"}'\u003e/home/jovyan/.jupyter/lab/user-settings/@jupyterlab/translation-extension/plugin.jupyterlab-settings \\ # 不接收新闻 \u0026\u0026 mkdir -p /home/jovyan/.jupyter/lab/user-settings/@jupyterlab/apputils-extension/ \\ \u0026\u0026 echo '{\"fetchNews\": \"false\"}'\u003e/home/jovyan/.jupyter/lab/user-settings/@jupyterlab/apputils-extension/notification.jupyterlab-settings \\ # 启用插件 \u0026\u0026 mkdir -p /home/jovyan/.jupyter/lab/user-settings/@jupyterlab/extensionmanager-extension/ \\ \u0026\u0026 echo '{\"disclaimed\": true}'\u003e/home/jovyan/.jupyter/lab/user-settings/@jupyterlab/extensionmanager-extension/plugin.jupyterlab-settings \\ # 设置默认主题为JupyterLab Dark----the one of two default themes. \u0026\u0026 echo '{\"theme\": \"JupyterLab Dark\"}'\u003e/home/jovyan/.jupyter/lab/user-settings/@jupyterlab/apputils-extension/themes.jupyterlab-settings \\ # 开启自动补全 \u0026\u0026 mkdir -p /home/jovyan/.jupyter/lab/user-settings/@krassowski/jupyterlab-lsp \\ \u0026\u0026 echo '{\"continuousHinting\": true}'\u003e/home/jovyan/.jupyter/lab/user-settings/@krassowski/jupyterlab-lsp/completion.jupyterlab-settings \\ # 设置默认开启自动框号补全等 \u0026\u0026 mkdir -p /home/jovyan/.jupyter/lab/user-settings/@jupyterlab/notebook-extension/ \\ \u0026\u0026 echo '{\"codeCellConfig\":{\"autoClosingBrackets\":true,\"lineNumbers\":true,\"codeFolding\":true,},\"experimentalDisableDocumentWideUndoRedo\":true,\"kernelShutdown\":true,\"kernelStatus\":{\"showOnStatusBar\":true,\"showProgress\":true},\"markdownCellConfig\":{\"autoClosingBrackets\":true,\"lineNumbers\":true,\"lineWrap\":\"on\",\"matchBrackets\":true,\"codeFolding\":true,},\"rawCellConfig\":{\"autoClosingBrackets\":true,\"lineNumbers\":true,\"lineWrap\":\"on\",\"matchBrackets\":true,\"codeFolding\":true,},\"recordTiming\":true}'\u003e/home/jovyan/.jupyter/lab/user-settings/@jupyterlab/notebook-extension/tracker.jupyterlab-settings # `jupyterlab-variableInspector`帮助我们在`jupyter lab`中查看当前环境中存在的变量相关信息， # 以美观的界面形式对多种类型的对象予以呈现。 # https://cloud.tencent.com/developer/article/1971947 RUN pip install --no-cache-dir lckr-jupyterlab-variableinspector -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com # jupyterlab-system-monitor通过在jupyter lab界面中添加资源监视器部件， # 能帮助我们在工作过程中方便的看到CPU、内存的实时占用情况 RUN pip install --no-cache-dir nbresuse -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com \\ \u0026\u0026 jupyter labextension install jupyterlab-topbar-extension jupyterlab-system-monitor # docker run -itd --name=lab -p 8888:8888 -e CHOWN_HOME=yes -e NB_UID=1000 -e NB_GID=1000 -e RESTARTABLE=yes -e GRANT_SUDO=yes --user root docker.io/blackelks/jupyterlab-datascience:latest # 补充库:faker 代码格式化、black isort RUN pip install --no-cache-dir faker jupyterlab-code-formatter black isort -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com # 代码格式化插件设置 RUN mkdir -p /home/jovyan/.jupyter/lab/user-settings/@ryantam626/jupyterlab_code_formatter/ \\ \u0026\u0026 echo '{\"preferences\":{\"default_formatter\":{\"python\":[\"isort\",\"black\"],}},\"black\":{\"line_length\":88,\"string_normalization\":true},","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:3:3","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"Notebook相关(弃用，需要时可参考) ","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:4:0","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"安装主题 pip install jupyterthemes ","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:4:1","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"更新主题 pip install --upgrade jupyterthemes ","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:4:2","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"查看可用主题 jt -l ","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:4:3","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"我个人喜欢亮一点的背景主题，于是选择了grade3，它还支持语法高亮。下面是我的背景主题设置： jt -t grade3 -f fira -fs 13 -cellw 90% -ofs 11 -dfs 11 -T -N -f(字体) -fs(字体大小) -cellw(占屏比或宽度) -ofs(输出段的字号) -T(显示工具栏) -N(显示自己主机名) ","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:4:4","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"2.代码自动补全 首先安装 nbextensions： pip install --no-cache-dir jupyter_contrib_nbextensions jupyter contrib nbextension install --user 然后安装 nbextensions_configurator： pip install --no-cache-dir jupyter_nbextensions_configurator jupyter nbextensions_configurator enable --user 如果提示缺少依赖，就使用pip安装对应依赖即可。 最后重启jupyter 在弹出的Home面里，能看到增加了一个Nbextensions标签页，在这个页面里，勾选Hinterland即启用了代码自动补全，如图所示： 效果图： https://www.cnblogs.com/shanger/p/12006161.html ","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:4:5","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"其他备注信息 ","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:5:0","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"Notebook配置文件路径: /home/jovyan/.jupyter/jupyter_notebook_config.py ","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:5:1","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"Notebook语言文件目录 /opt/conda/lib/python3.10/site-packages/notebook/i18n ","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:5:2","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"容器内工作目录 默认为/home/jovyan/work，可通过自定义环境变量来变更。 ","date":"2023-02-08","objectID":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/:5:3","tags":null,"title":"Jupyter容器搭建`开发环境`过程记录","uri":"/jupyter%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"使用Docker容器，一键启动ELK stack，所有服务集中在一个容器内，真香！！","date":"2023-01-23","objectID":"/docker%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BAelk-aio/","tags":["Docker","ELK"],"title":"Docker容器搭建ELK AIO","uri":"/docker%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BAelk-aio/"},{"categories":null,"content":"镜像地址 https://hub.docker.com/r/sebp/elk ","date":"2023-01-23","objectID":"/docker%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BAelk-aio/:1:0","tags":["Docker","ELK"],"title":"Docker容器搭建ELK AIO","uri":"/docker%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BAelk-aio/"},{"categories":null,"content":"参数说明 docker run -itd -p 5601:5601 -p 9200:9200 -p 5044:5044 --name=elk -e TZ=\"Asia/Shanghai\" sebp/elk TZ: 时区 (这里查看 可用时区参数), 例如 Asia/Shanghai、America/Los_Angeles (default is Etc/UTC, i.e. UTC). ES_HEAP_SIZE: Elasticsearch heap size，内存占用？ (default is 256MB min, 1G max) Specifying a heap size – e.g. 2g – will set both the min and max to the provided value. To set the min and max values separately, see the ES_JAVA_OPTS below. ES_JAVA_OPTS: additional Java options for Elasticsearch (default: \"\") For instance, to set the min and max heap size to 512MB and 2G, set this environment variable to -Xms512m -Xmx2g. ES_CONNECT_RETRY: number of seconds to wait for Elasticsearch to be up before starting Logstash and/or Kibana (default: 30) ES_PROTOCOL: protocol to use to ping Elasticsearch’s JSON interface URL (default: http) Note that this variable is only used to test if Elasticsearch is up when starting up the services. It is not used to update Elasticsearch’s URL in Logstash’s and Kibana’s configuration files. CLUSTER_NAME: the name of the Elasticsearch cluster (default: automatically resolved when the container starts if Elasticsearch requires no user authentication). The name of the Elasticsearch cluster is used to set the name of the Elasticsearch log file that the container displays when running. By default the name of the cluster is resolved automatically at start-up time (and populates CLUSTER_NAME) by querying Elasticsearch’s REST API anonymously. However, when Elasticsearch requires user authentication (as is the case by default when running X-Pack for instance), this query fails and the container stops as it assumes that Elasticsearch is not running properly. Therefore, the CLUSTER_NAME environment variable can be used to specify the name of the cluster and bypass the (failing) automatic resolution. LS_HEAP_SIZE: Logstash heap size (default: \"500m\") LS_OPTS: Logstash options (default: \"--auto-reload\" in images with tags es231_l231_k450 and es232_l232_k450, \"\" in latest; see Breaking changes) NODE_OPTIONS: Node options for Kibana (default: \"--max-old-space-size=250\") MAX_MAP_COUNT: limit on mmap counts (default: system default) Warning – This setting is system-dependent: not all systems allow this limit to be set from within the container, you may need to set this from the host before starting the container (see Prerequisites). MAX_OPEN_FILES: maximum number of open files (default: system default; Elasticsearch needs this amount to be equal to at least 65536) KIBANA_CONNECT_RETRY: number of seconds to wait for Kibana to be up before running the post-hook script (see Pre-hooks and post-hooks) (default: 30) ES_HEAP_DISABLE and LS_HEAP_DISABLE: disable HeapDumpOnOutOfMemoryError for Elasticsearch and Logstash respectively if non-zero (default: HeapDumpOnOutOfMemoryError is enabled). Setting these environment variables avoids potentially large heap dumps if the services run out of memory. ","date":"2023-01-23","objectID":"/docker%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BAelk-aio/:2:0","tags":["Docker","ELK"],"title":"Docker容器搭建ELK AIO","uri":"/docker%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BAelk-aio/"},{"categories":null,"content":"镜像使用手册文档 https://elk-docker.readthedocs.io ","date":"2023-01-23","objectID":"/docker%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BAelk-aio/:3:0","tags":["Docker","ELK"],"title":"Docker容器搭建ELK AIO","uri":"/docker%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BAelk-aio/"},{"categories":["windows美化"],"content":"最终显示效果如图： {height=“400px”} ","date":"2022-12-30","objectID":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/:0:0","tags":["win","windows","win11","字体","font","美化"],"title":"修改Windows显示字体","uri":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/"},{"categories":["windows美化"],"content":"背景 最近将笔记本装上了Phoenix团队精简的系统X-Lite，其默认显示语言为英文，可以下载安装中文语言包，但是貌似有以下几个问题： 会出现方块（乱码） 微软拼音无法启动（通过临时启动ctfmon.exe或将其设为开机启动解决） 中文字相较原版win11镜像难看（细小不齐等） 命令行中文字乱码（解决方法） ","date":"2022-12-30","objectID":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/:1:0","tags":["win","windows","win11","字体","font","美化"],"title":"修改Windows显示字体","uri":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/"},{"categories":["windows美化"],"content":"添加中文语言包 ","date":"2022-12-30","objectID":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/:2:0","tags":["win","windows","win11","字体","font","美化"],"title":"修改Windows显示字体","uri":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/"},{"categories":["windows美化"],"content":"走过的弯路 使用该精简内置的优化工具Winaero Tweaker修改为HarmonyOS_Sans_Medium.ttf字体，结果发现只能修改只对英文生效。 通过修改注册表，参见：https://blog.csdn.net/amoscn/article/details/106224359 ","date":"2022-12-30","objectID":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/:2:1","tags":["win","windows","win11","字体","font","美化"],"title":"修改Windows显示字体","uri":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/"},{"categories":["windows美化"],"content":"正确姿势 详细情况参见：https://www.revi.cc/revios/workspace/lang#h.ry7gga391br1： 先打开系统更新 在设置里面添加中文语言包 注销之后中文显示正常 使用dism /Online /Get-Packages获取已安装语言包，找到包名类似Microsoft-Windows-Client-LanguagePack-Package~31bf3856ad364e35~amd64~en-US~10.0.19041.1（取决于你的系统）， 使用dism /Online /Remove-Package /PackageName:XXX删除英文语言包，在系统设置界面中删除英文语言…. 解决锁屏界面仍然是英文的现象，（参考此文进行设置：https://jingyan.baidu.com/article/fcb5aff7c6dc90adaa4a71b5.html） 以下为备份： 在资源管理器中输入控制面板\\时钟和区域\\日期和时间–\u003e更改日期和时间(D)–\u003e更改日历设置，切换到管理选项卡–\u003e复制设置–\u003e勾选最底下欢迎屏幕和系统账户。 ","date":"2022-12-30","objectID":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/:2:2","tags":["win","windows","win11","字体","font","美化"],"title":"修改Windows显示字体","uri":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/"},{"categories":["windows美化"],"content":"字体美化正确姿势 使用noMeiryoUI(下载地址)进行修改，字体使用HarmonyOS_Sans_SC_Medium.ttf。你就能如愿以偿了。以下是我的配置截图： {height=“300px”} 2023/1/1日更新，从上图可以看到，noMeiryoUI(下载地址)并不支持窗口标题字体的修改，这时我们可以用Winaero Tweaker来进行，可以说两者互为补充。 ","date":"2022-12-30","objectID":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/:2:3","tags":["win","windows","win11","字体","font","美化"],"title":"修改Windows显示字体","uri":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/"},{"categories":["windows美化"],"content":"Everything的黑色主题美化与配置备份 效果如下图 定位到Everything目录； 退出Everything； 将下面内容替换到Everything.exe所在目录的Everything.ini中； 重启Everything。（如果你再打开Everything.ini，会发现已经将你提供的配置信息吸收了） [Everything] ; 交错行 alternate_row_color=1 show_mouseover=1 ; 无关键词时空结果 hide_empty_search_results=1 ; 切换窗口快捷键 toggle_window_key=602 ; 在状态栏显示大小 show_size_in_statusbar=1 single_click_tray=1 double_click_path=1 auto_scroll_view=1 ; 复制时自动加双引号 double_quote_copy_as_path=1 focus_search_on_activate=1 ; 大小格式——自动 size_format=0 ; 索引文件夹大小 index_folder_size=1 ; 显示筛选器 filters_visible=1 filter=EVERYTHING ; 结果排序规则——文件（夹）大小 sort=Size ; 结果排序规则——正向 sort_ascending=0 ; 字体，需要先安装对应字体才会生效 result_list_font=HarmonyOS Sans SC Medium ; 配色 normal_background_color=#21252b normal_foreground_color=#aaaaaa highlighted_foreground_color=#008080 current_sort_background_color=#1c2026 current_sort_highlighted_background_color=#21252b mouseover_background_color=#2b2a33 mouseover_highlighted_background_color=#ff0080 网页制作的多种配色方案：https://www.voidtools.com/forum/viewtopic.php?t=7240 ","date":"2022-12-30","objectID":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/:3:0","tags":["win","windows","win11","字体","font","美化"],"title":"修改Windows显示字体","uri":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/"},{"categories":["windows美化"],"content":"去除不想要的右键菜单 使用火绒自带的右键菜单管理工具即可 ","date":"2022-12-30","objectID":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/:4:0","tags":["win","windows","win11","字体","font","美化"],"title":"修改Windows显示字体","uri":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/"},{"categories":["windows美化"],"content":"WPS相关 ","date":"2022-12-30","objectID":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/:5:0","tags":["win","windows","win11","字体","font","美化"],"title":"修改Windows显示字体","uri":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/"},{"categories":["windows美化"],"content":"去除WPS云文档入口 注册表，找到如下位置删除文件。（不是右边的数值） 资源管理左导航栏：（中间数字可能有区别，看好开头结尾即可） HKEY_USERS\\S-1-5-21-1514480548-2261916930-102402149-1001\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace\\{7AE6DE87-C956-4B40-9C89-3D166C9841D3} 资源管理我的电脑： HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace ","date":"2022-12-30","objectID":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/:5:1","tags":["win","windows","win11","字体","font","美化"],"title":"修改Windows显示字体","uri":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/"},{"categories":["windows美化"],"content":"隐藏资源管理器左侧不想要的文件夹 弯路：dism++默认提供7个文件夹的隐藏，但是下载和桌面我经常用到，这就需要自己动手定制了。 https://github.com/Chuyu-Team/Dism-Multi-language/issues/527 https://jingyan.baidu.com/article/75ab0bcbb47b09d6864db2cc.html 直接右键该文件夹，选择从\"快速访问\"取消固定即可，如图。 {height=“300px”} ","date":"2022-12-30","objectID":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/:6:0","tags":["win","windows","win11","字体","font","美化"],"title":"修改Windows显示字体","uri":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/"},{"categories":["windows美化"],"content":"另参考文章 Windows 10 资源管理器隐藏网络、3D对象、视频、图片、文档等多余文件夹： https://blog.csdn.net/m0_46463321/article/details/125387284 ","date":"2022-12-30","objectID":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/:6:1","tags":["win","windows","win11","字体","font","美化"],"title":"修改Windows显示字体","uri":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/"},{"categories":["windows美化"],"content":"windows美化相关网站、视频 https://cleodesktop.gumroad.com/ https://cleodesktop.com/obetal-tequila-theme-for-windows-11/ https://zhutix.com/tag/win11-zhuti/ https://www.youtube.com/watch?v=To1AXc9ESwU及https://github.com/niivu/Windows-11-themes Windows 字体美化经验： https://www.xianyukang.com/windows-font-optimization.html https://www.bilibili.com/video/BV1pP4y187bR/?vd_source=7b484be4a84a335a3d197df33bc93481 {.gallery data-height=“240”} ","date":"2022-12-30","objectID":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/:6:2","tags":["win","windows","win11","字体","font","美化"],"title":"修改Windows显示字体","uri":"/%E4%BF%AE%E6%94%B9windows%E6%98%BE%E7%A4%BA%E5%AD%97%E4%BD%93%E5%85%BC%E5%85%B6%E4%BB%96windows%E7%BE%8E%E5%8C%96/"},{"categories":["Docker","Linux"],"content":"开发环境要求 基于Ubuntu或者Debian，系统源改为国内源， 系统时间为东八区 安装node、golang、python，源都改为国内源 使用ssh秘钥登录，方便vscode链接 生产目录映射到宿主机目录，防止工作数据丢失 暴露端口数至少40个，以满足折腾需求 解决中文乱码问题 ","date":"2022-12-23","objectID":"/win%E4%B8%8B%E5%88%A9%E7%94%A8dockerdesktop%E6%89%93%E9%80%A0linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/:1:0","tags":["Docker","Linux"],"title":"Win下利用DockerDesktop打造Linux开发环境","uri":"/win%E4%B8%8B%E5%88%A9%E7%94%A8dockerdesktop%E6%89%93%E9%80%A0linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"categories":["Docker","Linux"],"content":"符合要求的Dockerfile 参考此链接：https://blog.csdn.net/shykevin/article/details/105305322 FROM node:19-bullseye-slim # 修改更新源为阿里云 RUN sed -i \"s@http://\\(deb\\|security\\).debian.org@http://mirrors.163.com@g\" /etc/apt/sources.list # ADD . / # 时区为上海 ENV TZ Asia/Shanghai # 设置时区,设置utf-8编码 RUN apt-get update \u0026\u0026 apt-get install -y tzdata locales python3-pip cron openssh-server python3 curl wget git \u0026\u0026 apt-get clean all \u0026\u0026 \\ ln -snf /usr/share/zoneinfo/$TZ /etc/localtime \u0026\u0026 echo $TZ \u003e /etc/timezone \u0026\u0026 \\ locale-gen en_US.UTF-8 \u0026\u0026 mkdir ~/.pip\u0026\u0026touch ~/.pip/pip.conf # 将pip国内源配置文件写入~/.pip中 RUN echo '[global]'\u003e~/.pip/pip.conf \\ echo 'index-url = http://pypi.douban.com/simple'\u003e\u003e~/.pip/pip.conf \\ echo 'trusted-host = pypi.douban.com'\u003e\u003e~/.pip/pip.conf # 解决中文乱码问题 RUN echo \"LC_ALL=en_US.UTF-8\" \u003e\u003e /etc/environment \u0026\u0026 \\ echo \"en_US.UTF-8 UTF-8\" \u003e\u003e /etc/locale.gen \u0026\u0026 \\ echo \"LANG=en_US.UTF-8\" \u003e /etc/locale.conf \u0026\u0026 \\ locale-gen en_US.UTF-8 # 安装golang \u0026\u0026source /root/.bashrc RUN curl -L https://gitee.com/blackelk/update-golang/raw/master/update-golang.sh | bash #设置go国内源 RUN /root/.go/bin/go env -w GO111MODULE=on \u0026\u0026 \\ /root/.go/bin/go env -w GOPROXY=https://goproxy.cn,direct # 设置npm国内源 RUN npm config set registry https://mirrors.huaweicloud.com/repository/npm/ # 开启ssh服务 RUN service ssh start RUN echo \"PermitRootLogin yes\" \u003e\u003e /etc/ssh/sshd_config RUN echo \"root:123\" | chpasswd RUN mkdir -p /workdir VOLUME /workdir EXPOSE 22 EXPOSE 8000-9000 # /etc/init.d/ssh start ENTRYPOINT service ssh restart \u0026\u0026 bash ","date":"2022-12-23","objectID":"/win%E4%B8%8B%E5%88%A9%E7%94%A8dockerdesktop%E6%89%93%E9%80%A0linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/:2:0","tags":["Docker","Linux"],"title":"Win下利用DockerDesktop打造Linux开发环境","uri":"/win%E4%B8%8B%E5%88%A9%E7%94%A8dockerdesktop%E6%89%93%E9%80%A0linux%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"categories":["Pandas","Go","Python","ChatGPT"],"content":"Python ","date":"2022-12-20","objectID":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:1:0","tags":["文本处理","Python","ChatGPT","Go"],"title":"Python和Golang超大文本文件处理","uri":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["Pandas","Go","Python","ChatGPT"],"content":"Python中迭代读取超大文本文件，每次读取1000行。 在python中，我们可以使用yield关键字和for循环实现迭代读取超大文本文件，每次读取1000行。 例如，我们可以定义一个函数read_lines_by_1000()，每次yield 1000行的数据： def read_lines_by_1000(filename): with open(filename, 'r') as f: lines = [] for line in f: lines.append(line) if len(lines) == 1000: yield lines lines = [] yield lines 然后，我们可以使用for循环迭代读取超大文本文件： filename = 'data.txt' for lines in read_lines_by_1000(filename): print(lines) # 处理lines中的数据 ","date":"2022-12-20","objectID":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:1:1","tags":["文本处理","Python","ChatGPT","Go"],"title":"Python和Golang超大文本文件处理","uri":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["Pandas","Go","Python","ChatGPT"],"content":"有比这个效率更高的方法吗 这样就可以在python中迭代读取超大文本文件，每次读取1000行了。 使用yield关键字和for循环迭代读取超大文本文件，每次读取1000行的方法已经是目前效率最高的方法之一。 如果想要提升效率，还可以考虑以下几种方法： 尽量使用内存映射文件读取超大文本文件，这样可以避免将数据从磁盘读取到内存中，从而提升读取速度。 尽量使用多线程读取超大文本文件，从而提升读取速度。 尽量使用多进程读取超大文本文件，从而提升读取速度。 尽量使用单个较大的缓冲区读取超大文本文件，从而提升读取速度。 需要注意的是，使用上述方法时可能会带来一些问题，例如内存占用过大，多线程/多进程同步问题等。因此，需要根据实际情况选择适合的方法。 ","date":"2022-12-20","objectID":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:1:2","tags":["文本处理","Python","ChatGPT","Go"],"title":"Python和Golang超大文本文件处理","uri":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["Pandas","Go","Python","ChatGPT"],"content":"python如何正确处理超大文本文件，防止内存吃不消。 在python中，可以使用以下几种方法正确处理超大文本文件，防止内存吃不消： 使用yield关键字和for循环迭代读取超大文本文件，每次读取一定数量的行。这样可以避免将整个文件一次性读取到内存中，从而防止内存吃不消。 使用内存映射文件读取超大文本文件。这样可以避免将数据从磁盘读取到内存中，从而防止内存吃不消。 使用多线程/多进程读取超大文本文件。这样可以分担读取超大文本文件的负担，从而防止内存吃不消。 使用单个较大的缓冲区读取超大文本文件。这样可以减少读取超大文本文件时的系统调用次数，从而提升读取速度，防止内存吃不消。 需要注意的是，使用上述方法时可能会带来一些问题，例如内存占用过大，多线程/多进程同步问题等。因此，需要根据实际情况选择适合的方法。 ","date":"2022-12-20","objectID":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:1:3","tags":["文本处理","Python","ChatGPT","Go"],"title":"Python和Golang超大文本文件处理","uri":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["Pandas","Go","Python","ChatGPT"],"content":"内存映射文件的具体实现方法举例 在python中，可以使用mmap模块来实现内存映射文件。 例如，我们可以使用mmap.mmap()函数将文件映射到内存中： import mmap filename = 'data.txt' # 使用mmap.mmap()函数将文件映射到内存中 with open(filename, 'r+b') as f: mm = mmap.mmap(f.fileno(), 0) # 使用mm对象读取文件内容 print(mm.read()) # 使用mm对象修改文件内容 mm.seek(0) mm.write(b'new data') # 关闭mmap对象 mm.close() 这样就可以使用mmap模块实现内存映射文件了。 ","date":"2022-12-20","objectID":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:1:4","tags":["文本处理","Python","ChatGPT","Go"],"title":"Python和Golang超大文本文件处理","uri":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["Pandas","Go","Python","ChatGPT"],"content":"内存映射处理超大文本举例 在python中，可以使用mmap模块来实现内存映射文件，然后使用for循环迭代读取超大文本文件。 例如，我们可以使用mmap.mmap()函数将文件映射到内存中，然后使用for循环迭代读取超大文本文件： import mmap filename = 'data.txt' # 使用mmap.mmap()函数将文件映射到内存中 with open(filename, 'r+b') as f: mm = mmap.mmap(f.fileno(), 0) # 使用for循环迭代读取超大文本文件 for line in mm: print(line) # 关闭mmap对象 mm.close() 这样就可以使用内存映射处理超大文件了。 另外，我们也可以使用mmap.mmap()函数将文件映射到内存中，然后使用yield关键字和for循环迭代读取超大文本文件，每次读取一定数量的行。例如： import mmap # 下面两个函数二选一 def read_lines_by_num(filename,line_num): with open(filename,'r+b') as f: with mmap.mmap(f.fileno(),0) as mm: lines=[] for line in iter(mm.readline,b\"\"): lines.append(bytes.decode(line)) #使用bytes.decode将byte字符串转为普通字符串 if len(lines)==line_num: yield lines lines=[] # 返回剩余不足line_num的行 yield lines def read_data(file_path,chunk_size): with open(file_path, \"r+\") as f: m = mmap.mmap(f.fileno(), 0) g_index = 0 lines = [] for index, char in enumerate(m): if char == b\"\\n\": lines.append(m[g_index:index + 1].decode()) g_index = index + 1 if len(lines) == chunk_size: yield lines lines = [] # 返回剩余不足chunk_size的行 yield lines filename=r'五亿数据.txt' for lines in read_lines_by_num(filename,1000000): print(lines) # 处理lines中的数据 这样就可以使用内存映射处理超大文本文件，并使用yield关键字和for循环迭代读取超大文本文件，每次读取一定数量的行了。 ","date":"2022-12-20","objectID":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:1:5","tags":["文本处理","Python","ChatGPT","Go"],"title":"Python和Golang超大文本文件处理","uri":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["Pandas","Go","Python","ChatGPT"],"content":"再同时加上多进程和多线程读取技术，注释代码，让我知道是如何解决同步问题的。 在python中，可以使用mmap模块将文件映射到内存中，然后使用多进程和多线程同时读取超大文本文件。 具体实现方法如下： 首先，我们使用mmap.mmap()函数将文件映射到内存中： import mmap filename = 'data.txt' # 使用mmap.mmap()函数将文件映射到内存中 with open(filename, 'r+b') as f: mm = mmap.mmap(f.fileno(), 0) 然后，我们使用多进程和多线程同时读取超大文本文件。在这里，我们使用multiprocessing模块的Queue类和threading模块的Queue类来解决同步问题： import iprocessing import iprocessing.queues import threading import queue def read_lines(q, start, end): \"\"\"读取超大文本文件的函数\"\"\" lines = [] for i, line in enumerate(mm): if i \u003c start: continue if i \u003e= end: break lines.append(line) q.put(lines) # 使用多进程和多线程同时读取超大文本文件 q = queue.Queue() threads = [] for i in range(10): start = i * 1000 end = (i + 1) * 1000 t = threading.Thread(target=read_lines, args=(q, start, end)) t.start() threads.append(t) p = iprocessing.Process(target=read_lines, args=(q, 10000, 20000)) p.start() for t in threads: t.join() p.join() while not q.empty(): lines = q.get() print(lines) # 处理lines中的数据 # 关闭mmap对象 mm.close() ","date":"2022-12-20","objectID":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:1:6","tags":["文本处理","Python","ChatGPT","Go"],"title":"Python和Golang超大文本文件处理","uri":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["Pandas","Go","Python","ChatGPT"],"content":"使用Python从大文件中删除某一行的最快的方法 原文参见： 下面是ChatGPT对的详细注释： import os from mmap import mmap def removeLine(filename, lineno): # 打开文件，并以读写模式打开 # os.O_RDWR 表示以读写模式打开文件 f = os.open(filename, os.O_RDWR) # 创建内存映射文件 # mmap 函数的第一个参数是文件描述符，第二个参数是内存映射文件的大小。 # 当第二个参数设置为 0 时，内存映射文件的大小会自动调整为文件的大小。 m = mmap(f, 0) # 定位要删除的行的位置 # p 是要删除的行的开始位置，q 是要删除的行的结束位置。 p = 0 for i in range(lineno-1): # 使用 m.find 函数定位下一行的开始位置 # 当 p 为 0 时，表示在内存映射文件的开头查找。 # 当 p 不为 0 时，表示在 p 之后查找。 p = m.find('\\n', p) + 1 # 定位要删除的行的结束位置 q = m.find('\\n', p) # 删除行 # 使用 m[p:q] 获取要删除的行的内容，然后将其赋值为空字符串。 m[p:q] = ' ' * (q - p) # 关闭文件 os.close(f) 的注释： # You can have two file objects for the same file at the same time (one for reading, one for writing): # 你可以在同一时间内拥有同一文件的两个文件对象（一个用于读取，一个用于写入）。 def removeLine(filename, lineno): # 以只读模式打开文件 fro = open(filename, \"rb\") # 读取文件的行数 current_line = 0 # 循环，直到读取的行数等于要删除的行数 while current_line \u003c lineno: # 使用 fro.readline() 读取一行 fro.readline() # 读取的行数加 1 current_line += 1 # 记录当前文件指针的位置 seekpoint = fro.tell() # 以读写模式打开文件 frw = open(filename, \"r+b\") # 移动文件指针到 seekpoint 处 frw.seek(seekpoint, 0) # 读取要删除的行 fro.readline() # 将文件中剩余的内容向前移动一行 # 使用 fro.readline() 读取一行 chars = fro.readline() # 循环，直到读取到文件末尾 while chars: # 使用 frw.writelines() 将读取到的内容写入文件 frw.writelines(chars) # 继续读取下一行 chars = fro.readline() # 关闭文件 fro.close() frw.truncate() frw.close() ","date":"2022-12-20","objectID":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:1:7","tags":["文本处理","Python","ChatGPT","Go"],"title":"Python和Golang超大文本文件处理","uri":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["Pandas","Go","Python","ChatGPT"],"content":"Golang ","date":"2022-12-20","objectID":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:2:0","tags":["文本处理","Python","ChatGPT","Go"],"title":"Python和Golang超大文本文件处理","uri":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["Pandas","Go","Python","ChatGPT"],"content":"golang如何优雅的处理超大文本文件 在golang中，可以使用bufio模块的Scanner类来优雅的处理超大文本文件。 具体实现方法如下： 首先，我们使用os.Open()函数打开文本文件： f, err := os.Open(\"data.txt\") if err != nil { fmt.Println(err) return } 然后，我们使用bufio.NewScanner()函数创建Scanner对象： scanner := bufio.NewScanner(f) 接下来，我们使用Scanner.Scan()函数读取文本文件的每一行数据： for scanner.Scan() { line := scanner.Text() fmt.Println(line) // 处理line中的数据 } 最后，我们使用Scanner.Err()函数检查是否出现错误： if err := scanner.Err(); err != nil { fmt.Println(err) } 通过使用Scanner类，我们可以优雅地处理超大文本文件。 此外，我们也可以使用多协程来加速文本文件的读取。在这里，我们可以使用channel来解决协程间同步问题： import ( \"bufio\" \"fmt\" \"os\" ) func readLines(ch chan string, start int, end int) { f, err := os.Open(\"data.txt\") if err != nil { fmt.Println(err) return } defer f.Close() scanner := bufio.NewScanner(f) for i := 0; scanner.Scan(); i++ { if i \u003c start { continue } if i \u003e= end { break } line := scanner.Text() ch \u003c- line } close(ch) } func main() { chs := make([]chan string, 10) for i := range chs { chs[i] = make(chan string) go readLines(chs[i], i*1000, (i+1)*1000) } for _, ch := range chs { for line := range ch { fmt.Println(line) // 处理line中的数据 } } } 上述代码中，我们使用了channel来解决协程间同步问题。每个协程读取超大文本文件的一部分数据，然后将读取的数据存储到channel中。最后，主协程从channel中取出数据，处理完后关闭channel。 ","date":"2022-12-20","objectID":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:2:1","tags":["文本处理","Python","ChatGPT","Go"],"title":"Python和Golang超大文本文件处理","uri":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["Pandas","Go","Python","ChatGPT"],"content":"每次读取一行(上面就是)会增加IO，效率太低，有没有一次读取指定行数的方法。 对于每次读取一行的效率问题，我们可以使用bufio.NewReader()函数创建一个bufio.Reader对象，然后使用bufio.Reader.ReadString()函数读取指定行数的数据。 具体实现方法如下： import ( \"bufio\" \"fmt\" \"os\" ) func readLines(start int, end int) (lines []string, err error) { f, err := os.Open(\"data.txt\") if err != nil { return } defer f.Close() reader := bufio.NewReader(f) for i := 0; i \u003c end; i++ { line, err := reader.ReadString('\\n') if err != nil { return lines, err } if i \u003c start { continue } lines = append(lines, line) } return } func main() { lines, err := readLines(0, 1000) if err != nil { fmt.Println(err) return } for _, line := range lines { fmt.Println(line) // 处理line中的数据 } } 上述代码中，我们使用bufio.Reader.ReadString()函数读取指定行数的数据，并将读取的数据存储到lines列表中。 此外，我们还可以使用多协程加速读取文本文件的速度。在这里，我们可以使用channel来解决协程间同步问题： import ( \"bufio\" \"fmt\" \"os\" ) func readLines(start int, end int) (lines []string, err error) { f, err := os.Open(\"data.txt\") if err != nil { return } defer f.Close() reader := bufio.NewReader(f) for i := 0; i \u003c end; i++ { line, err := reader.ReadString('\\n') if err != nil { return lines, err } if i \u003c start { continue } lines = append(lines, line) } return } func readLinesFromChannel(ch chan []string, start int, end int) { lines, err := readLines(start, end) if err != nil { ch \u003c- nil return } ch \u003c- lines } func main() { chs := make([]chan []string, 10) for i := range chs { chs[i] = make(chan []string) go readLinesFromChannel(chs[i], i*1000, (i+1)*1000) } for _, ch := range chs { lines := \u003c-ch if lines == nil { continue } for _, line := range lines { fmt.Println(line) // 处理line中的数据 } } } 通过使用bufio.Reader.ReadString()函数一次读取指定行数的数据，以及使用多协程加读取文本文件的速度，我们可以大幅提升读取超大文本文件的效率。 希望这次的代码能够满足您的需求。如果您有任何疑问，请随时联系我。 package main import ( \"bufio\" \"io\" \"log\" \"os\" \"strings\" \"syscall\" ) const ( // chunkSize 是每次读取的行数 chunkSize = 1000 // 分隔符 delimiter = \"---\" ) func main() { // 打开文件 f, err := os.Open(\"large.txt\") if err != nil { log.Fatal(err) } defer f.Close() // 获取文件信息 fi, err := f.Stat() if err != nil { log.Fatal(err) } // 内存映射文件 size := fi.Size() prot := syscall.PROT_READ flags := syscall.MAP_PRIVATE fd := int(f.Fd()) offset := 0 b, err := syscall.Mmap(fd, int64(offset), int(size), prot, flags) if err != nil { log.Fatal(err) } defer syscall.Munmap(b) // 创建三个文件用于存储结果 lessThanSeven, err := os.Create(\"less_than_seven.txt\") if err != nil { log.Fatal(err) } defer lessThanSeven.Close() equalSeven, err := os.Create(\"equal_seven.txt\") if err != nil { log.Fatal(err) } defer equalSeven.Close() greaterThanSeven, err := os.Create(\"greater_than_seven.txt\") if err != nil { log.Fatal(err) } defer greaterThanSeven.Close() // 使用bufio包的NewReader函数创建一个带缓冲的读取器 r := bufio.NewReader(f) // 读取文件 for { // 读取chunkSize行 chunk := make([]string, 0, chunkSize) for i := 0; i \u003c chunkSize; i++ { line, err := r.ReadString('\\n') if err == io.EOF { // 文件结尾 break } else if err != nil { log.Fatal(err) } chunk = append(chunk, line) } // 处理读取的行 for _, line := range chunk { columns := strings.Split(line, delimiter) numColumns := len(columns) if numColumns \u003c 7 { // 列数小于7 _, err := lessThanSeven.WriteString(line) if err != nil { log.Fatal(err) } } else if numColumns == 7 { // 列数等于7 _, err := equalSeven.WriteString(line) if err != nil { log.Fatal(err) } } else { // 列数大于7 _, err := greaterThanSeven.WriteString(line) if err != nil { log.Fatal(err) } } } // 如果读取的行数不足chunkSize，说明文件已经读完 if len(chunk) \u003c chunkSize { break } } } ","date":"2022-12-20","objectID":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:2:2","tags":["文本处理","Python","ChatGPT","Go"],"title":"Python和Golang超大文本文件处理","uri":"/python%E5%92%8Cgolang%E8%B6%85%E5%A4%A7%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["Pandas","Python","ChatGPT"],"content":"Pandas 统计出每行非空的列数目 在 pandas 中，可以使用 DataFrame.count() 方法来统计每行非空的列数目。该方法返回一个新的 DataFrame，其中包含每列的非空值的数量。例如： import pandas as pd # 创建一个示例数据帧 df = pd.DataFrame({'A': [1, 2, 3, 4], 'B': [5, 6, 7, 8], 'C': [9, 10, None, 12]}) print(df) # 统计每行非空的列数目 non_null_counts = df.count() print(non_null_counts) 输出结果如下： A B C 0 1 5 9.0 1 2 6 10.0 2 3 7 NaN 3 4 8 12.0 A 4 B 4 C 3 dtype: int64 如果想要将每行的非空列数目添加回原来的数据帧中，可以使用 DataFrame.apply() 方法。例如： import pandas as pd # 创建一个示例数据帧 df = pd.DataFrame({'A': [1, 2, 3, 4], 'B': [5, 6, 7, 8], 'C': [9, 10, None, 12]}) # 将每行的非空列数目添加回原来的数据帧中 df['non_null_counts'] = df.apply(lambda row: row.count(), axis=1) print(df) 输出结果如下： A B C non_null_counts 0 1 5 9.0 3 1 2 6 10.0 3 2 3 7 NaN 2 3 4 8 12.0 3 请注意，DataFrame.count() 方法只会统计非空值，而不会统计 NaN 值。如果想要统计包括 NaN 值在内的每行非空的列数目，可以使用 DataFrame.notnull() 方法来代替 DataFrame.count() 方法。例如： import pandas as pd # 创建一个示例数据帧 df = pd.DataFrame({'A': [1, 2, 3, 4], 'B': [5, 6, 7, 8], 'C': [9, 10, None, 12]}) # 将每行的非空列数目添加回原来的数据帧中，包括 NaN 值 df['non_null_counts'] = df.notnull().sum(axis=1) print(df) 输出结果如下： A B C non_null_counts 0 1 5 9.0 3 1 2 6 10.0 3 2 3 7 NaN 2 3 4 8 12.0 3 请注意，在上面的代码中，我们使用了 DataFrame.notnull() 方法来判断每个值是否为空，并返回一个布尔值。然后，使用 DataFrame.sum() 方法将每行的布尔值求和，以统计每行非空的列数目。 希望这些信息能帮助你。如果你有其他问题，欢迎继续提问。 Pandas 筛选出每行非空的列数目为 7 的行，组成新的 dataframe 可以使用 DataFrame.apply() 方法和 DataFrame.notnull() 方法来筛选出每行非空的列数目为 7 的行，然后使用 DataFrame.loc[] 方法来选择这些行并组成新的数据帧。例如： import pandas as pd # 创建一个示例数据帧 df = pd.DataFrame({'A': [1, 2, 3, 4], 'B': [5, 6, 7, 8], 'C': [9, 10, None, 12], 'D': [None, None, None, None], 'E': [13, 14, 15, 16]}) # 筛选出每行非空的列数目为 7 的行 mask = df.apply(lambda row: row.notnull().sum() == 7, axis=1) print(mask) # 选择筛选出的行并组成新的数据帧 new_df = df.loc[mask] print(new_df)``` 输出结果如下： 0 False 1 False 2 False 3 True dtype: bool A B C D E 3 4 8 12.0 NaN 16 在上面的代码中，我们使用了 DataFrame.apply() 方法和 DataFrame.notnull() 方法来判断每个值是否为空，并返回一个布尔值。然后，使用 DataFrame.sum() 方法将每行的布尔值求和，以统计每行非空的列数目。最后，使用 DataFrame.loc[] 方法选择满足条件的行并组成新的数据帧。 希望这些信息能帮助你。如果你有其他问题，欢迎继续提问。 ","date":"2022-12-20","objectID":"/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["Pandas","ChatGPT"],"title":"Pandas学习笔记","uri":"/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Pandas","Python","ChatGPT"],"content":"数据错位(列)的修复 有如下数据： { 'name': ['rose', 'jack', 3, 'stone'], 'B': [5, 6, 7, 8], 'C': [9, 10, ''handsome'', 12] } “handsome\"应和3互换位置，以上只是样本，数据量大的情况下用pandas如何修复。 首先，我们需要使用pandas读取数据，并将数据转化为pandas的DataFrame格式： import pandas as pd data = {'name': ['rose', 'jack', 3, 'stone'], 'B': [5, 6, 7, 8], 'C': [9, 10, 'handsome', 12]} df = pd.DataFrame(data) ## 然后，我们可以使用pandas的loc和iloc方法来获取和修改位置3的元素： ## 获取位置3的元素 name_3 = df.loc[3, 'name'] c_3 = df.loc[3, 'C'] ## 互换位置3的元素 df.loc[3, 'name'] = c_3 df.loc[3, 'C'] = name_3 或者使用iloc方法： ## 获取位置3的元素 name_3 = df.iloc[3, 0] c_3 = df.iloc[3, 2] ## 互换位置3的元素 df.iloc[3, 0] = c_3 df.iloc[3, 2] = name_3 最后，我们可以使用df.to_dict()方法将修改后的DataFrame转化回字典格式： new_data = df.to_dict() print(new_data) ## 输出：{'name': ['rose', 'jack', 'handsome', 'stone'], 'B': [5, 6, 7, 8], 'C': [9, 10, 3, 12]} 这样就可以在数据量大的情况下使用pandas修复数据了。 ","date":"2022-12-20","objectID":"/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":["Pandas","ChatGPT"],"title":"Pandas学习笔记","uri":"/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Pandas","Python","ChatGPT"],"content":"将行转换成字符串处理(使用逗号作为连接符) 在pandas中，可以使用df.apply()方法将行转换成字符串处理，并使用join()函数将字符串元素连接起来。 例如，对于以下数据： import pandas as pd data = { 'name': ['rose', 'jack', 'stone'], 'age': [20, 25, 30], 'gender': ['female', 'male', 'male'] } df = pd.DataFrame(data) 我们可以使用df.apply()方法将每行数据转化为字符串，然后使用join()函数将字符串元素连接起来： def row_to_str(row): return [str(x) for x in row] df['row_str'] = df.apply(row_to_str, axis=1).apply(', '.join) print(df) ## 输出： ## name age gender row_str ## 0 rose 20 female name: rose, age: 20, gender: female ## 1 jack 25 male name: jack, age: 25, gender: male ## 2 stone 30 male name: stone, age: 30, gender: male 这样就可以使用逗号作为各元素的字符串连接符了。 ","date":"2022-12-20","objectID":"/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":["Pandas","ChatGPT"],"title":"Pandas学习笔记","uri":"/pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["ChatGPT"],"content":"我提问如下 如何使用下面代码，用中文表达: \u003ctemplate\u003e \u003cdiv\u003e \u003cv-form-render :form-json=\"formJson\" :form-data=\"formData\" :option-data=\"optionData\" ref=\"vFormRef\"\u003e \u003c/v-form-render\u003e \u003cel-button type=\"primary\" @click=\"submitForm\"\u003eSubmit\u003c/el-button\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { data() { return { formJson: {\"widgetList\":[{\"type\":\"tab\",\"category\":\"container\",\"icon\":\"tab\",\"displayType\":\"border-card\",\"tabs\":[{\"type\":\"tab-pane\",\"category\":\"container\",\"icon\":\"tab-pane\",\"internal\":true,\"widgetList\":[{\"type\":\"grid\",\"category\":\"container\",\"icon\":\"grid\",\"cols\":[{\"type\":\"grid-col\",\"category\":\"container\",\"icon\":\"grid-col\",\"internal\":true,\"widgetList\":[{\"type\":\"textarea\",\"icon\":\"textarea-field\",\"formItemFlag\":true,\"options\":{\"name\":\"textarea81387\",\"label\":\"待查内容\",\"labelAlign\":\"\",\"rows\":5,\"defaultValue\":\"\",\"placeholder\":\"\",\"columnWidth\":\"200px\",\"size\":\"\",\"labelWidth\":null,\"labelHidden\":false,\"readonly\":false,\"disabled\":false,\"hidden\":false,\"required\":true,\"requiredHint\":\"\",\"validation\":\"\",\"validationHint\":\"\",\"customClass\":[],\"labelIconClass\":null,\"labelIconPosition\":\"rear\",\"labelTooltip\":null,\"minLength\":null,\"maxLength\":null,\"showWordLimit\":false,\"onCreated\":\"\",\"onMounted\":\"\",\"onInput\":\"\",\"onChange\":\"\",\"onFocus\":\"\",\"onBlur\":\"\",\"onValidate\":\"\"},\"id\":\"textarea81387\"}],\"options\":{\"name\":\"gridCol79620\",\"hidden\":false,\"span\":12,\"offset\":0,\"push\":0,\"pull\":0,\"responsive\":false,\"md\":12,\"sm\":12,\"xs\":12,\"customClass\":\"\"},\"id\":\"grid-col-79620\"},{\"type\":\"grid-col\",\"category\":\"container\",\"icon\":\"grid-col\",\"internal\":true,\"widgetList\":[{\"type\":\"textarea\",\"icon\":\"textarea-field\",\"formItemFlag\":true,\"options\":{\"name\":\"textarea113419\",\"label\":\"查询结果\",\"labelAlign\":\"\",\"rows\":5,\"defaultValue\":\"\",\"placeholder\":\"\",\"columnWidth\":\"200px\",\"size\":\"\",\"labelWidth\":null,\"labelHidden\":false,\"readonly\":true,\"disabled\":false,\"hidden\":false,\"required\":false,\"requiredHint\":\"\",\"validation\":\"\",\"validationHint\":\"\",\"customClass\":\"\",\"labelIconClass\":null,\"labelIconPosition\":\"rear\",\"labelTooltip\":null,\"minLength\":null,\"maxLength\":null,\"showWordLimit\":false,\"onCreated\":\"\",\"onMounted\":\"\",\"onInput\":\"\",\"onChange\":\"\",\"onFocus\":\"\",\"onBlur\":\"\",\"onValidate\":\"\"},\"id\":\"textarea113419\"}],\"options\":{\"name\":\"gridCol52302\",\"hidden\":false,\"span\":12,\"offset\":0,\"push\":0,\"pull\":0,\"responsive\":false,\"md\":12,\"sm\":12,\"xs\":12,\"customClass\":[]},\"id\":\"grid-col-52302\"}],\"options\":{\"name\":\"grid114628\",\"hidden\":false,\"gutter\":12,\"colHeight\":null,\"customClass\":[]},\"id\":\"grid114628\"}],\"options\":{\"name\":\"tab1\",\"label\":\"微博手机互查\",\"hidden\":false,\"active\":true,\"disabled\":false,\"customClass\":\"\"},\"id\":\"tab-pane-26648\"},{\"type\":\"tab-pane\",\"category\":\"container\",\"icon\":\"tab-pane\",\"internal\":true,\"widgetList\":[{\"type\":\"grid\",\"category\":\"container\",\"icon\":\"grid\",\"cols\":[{\"type\":\"grid-col\",\"category\":\"container\",\"icon\":\"grid-col\",\"internal\":true,\"widgetList\":[{\"type\":\"textarea\",\"icon\":\"textarea-field\",\"formItemFlag\":true,\"options\":{\"name\":\"textarea52469\",\"label\":\"textarea\",\"labelAlign\":\"\",\"rows\":3,\"defaultValue\":\"\",\"placeholder\":\"\",\"columnWidth\":\"200px\",\"size\":\"\",\"labelWidth\":null,\"labelHidden\":false,\"readonly\":false,\"disabled\":false,\"hidden\":false,\"required\":false,\"requiredHint\":\"\",\"validation\":\"\",\"validationHint\":\"\",\"customClass\":\"\",\"labelIconClass\":null,\"labelIconPosition\":\"rear\",\"labelTooltip\":null,\"minLength\":null,\"maxLength\":null,\"showWordLimit\":false,\"onCreated\":\"\",\"onMounted\":\"\",\"onInput\":\"\",\"onChange\":\"\",\"onFocus\":\"\",\"onBlur\":\"\",\"onValidate\":\"\"},\"id\":\"textarea52469\"}],\"options\":{\"name\":\"gridCol106250\",\"hidden\":false,\"span\":12,\"offset\":0,\"push\":0,\"pull\":0,\"responsive\":false,\"md\":12,\"sm\":12,\"xs\":12,\"customClass\":\"\"},\"id\":\"grid-col-106250\"},{\"type\":\"grid-col\",\"category\":\"container\",\"icon\":\"grid-col\",\"internal\":true,\"widgetList\":[{\"type\":\"textarea\",\"icon\":\"textarea-field\",\"formItemFlag\":true,\"options\":{\"name\":\"textarea71693\",\"label\":\"textarea\",\"labelAlign\":\"\",\"rows\":3,\"defaultValue\":\"\",\"placeholder\":\"\",\"columnWidth\":\"200px\",\"size\":\"\",\"labelWidth\":null,\"labelHidden\":false,\"readonly\":false,\"disabled\":false,\"hidden\":false,\"required","date":"2022-12-16","objectID":"/chatgptformcreat%E7%94%9F%E6%88%90%E7%9A%84vue%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/:1:0","tags":["ChatGPT"],"title":"【ChatGPT】FormCreat生成的vue文件如何使用","uri":"/chatgptformcreat%E7%94%9F%E6%88%90%E7%9A%84vue%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/"},{"categories":["ChatGPT"],"content":"【注释】 上述代码可通过访问http://120.92.142.115/或https://www.vform666.com/，导入下面json获得。 { \"widgetList\": [ { \"type\": \"tab\", \"category\": \"container\", \"icon\": \"tab\", \"displayType\": \"border-card\", \"tabs\": [ { \"type\": \"tab-pane\", \"category\": \"container\", \"icon\": \"tab-pane\", \"internal\": true, \"widgetList\": [ { \"type\": \"grid\", \"category\": \"container\", \"icon\": \"grid\", \"cols\": [ { \"type\": \"grid-col\", \"category\": \"container\", \"icon\": \"grid-col\", \"internal\": true, \"widgetList\": [ { \"type\": \"textarea\", \"icon\": \"textarea-field\", \"formItemFlag\": true, \"options\": { \"name\": \"textarea81387\", \"label\": \"待查内容\", \"labelAlign\": \"\", \"rows\": 5, \"defaultValue\": \"\", \"placeholder\": \"\", \"columnWidth\": \"200px\", \"size\": \"\", \"labelWidth\": null, \"labelHidden\": false, \"readonly\": false, \"disabled\": false, \"hidden\": false, \"required\": true, \"requiredHint\": \"\", \"validation\": \"\", \"validationHint\": \"\", \"customClass\": [], \"labelIconClass\": null, \"labelIconPosition\": \"rear\", \"labelTooltip\": null, \"minLength\": null, \"maxLength\": null, \"showWordLimit\": false, \"onCreated\": \"\", \"onMounted\": \"\", \"onInput\": \"\", \"onChange\": \"\", \"onFocus\": \"\", \"onBlur\": \"\", \"onValidate\": \"\" }, \"id\": \"textarea81387\" } ], \"options\": { \"name\": \"gridCol79620\", \"hidden\": false, \"span\": 12, \"offset\": 0, \"push\": 0, \"pull\": 0, \"responsive\": false, \"md\": 12, \"sm\": 12, \"xs\": 12, \"customClass\": \"\" }, \"id\": \"grid-col-79620\" }, { \"type\": \"grid-col\", \"category\": \"container\", \"icon\": \"grid-col\", \"internal\": true, \"widgetList\": [ { \"type\": \"textarea\", \"icon\": \"textarea-field\", \"formItemFlag\": true, \"options\": { \"name\": \"textarea113419\", \"label\": \"查询结果\", \"labelAlign\": \"\", \"rows\": 5, \"defaultValue\": \"\", \"placeholder\": \"\", \"columnWidth\": \"200px\", \"size\": \"\", \"labelWidth\": null, \"labelHidden\": false, \"readonly\": true, \"disabled\": false, \"hidden\": false, \"required\": false, \"requiredHint\": \"\", \"validation\": \"\", \"validationHint\": \"\", \"customClass\": \"\", \"labelIconClass\": null, \"labelIconPosition\": \"rear\", \"labelTooltip\": null, \"minLength\": null, \"maxLength\": null, \"showWordLimit\": false, \"onCreated\": \"\", \"onMounted\": \"\", \"onInput\": \"\", \"onChange\": \"\", \"onFocus\": \"\", \"onBlur\": \"\", \"onValidate\": \"\" }, \"id\": \"textarea113419\" } ], \"options\": { \"name\": \"gridCol52302\", \"hidden\": false, \"span\": 12, \"offset\": 0, \"push\": 0, \"pull\": 0, \"responsive\": false, \"md\": 12, \"sm\": 12, \"xs\": 12, \"customClass\": [] }, \"id\": \"grid-col-52302\" } ], \"options\": { \"name\": \"grid114628\", \"hidden\": false, \"gutter\": 12, \"colHeight\": null, \"customClass\": [] }, \"id\": \"grid114628\" } ], \"options\": { \"name\": \"tab1\", \"label\": \"微博手机互查\", \"hidden\": false, \"active\": true, \"disabled\": false, \"customClass\": \"\" }, \"id\": \"tab-pane-26648\" }, { \"type\": \"tab-pane\", \"category\": \"container\", \"icon\": \"tab-pane\", \"internal\": true, \"widgetList\": [ { \"type\": \"grid\", \"category\": \"container\", \"icon\": \"grid\", \"cols\": [ { \"type\": \"grid-col\", \"category\": \"container\", \"icon\": \"grid-col\", \"internal\": true, \"widgetList\": [ { \"type\": \"textarea\", \"icon\": \"textarea-field\", \"formItemFlag\": true, \"options\": { \"name\": \"textarea52469\", \"label\": \"textarea\", \"labelAlign\": \"\", \"rows\": 3, \"defaultValue\": \"\", \"placeholder\": \"\", \"columnWidth\": \"200px\", \"size\": \"\", \"labelWidth\": null, \"labelHidden\": false, \"readonly\": false, \"disabled\": false, \"hidden\": false, \"required\": false, \"requiredHint\": \"\", \"validation\": \"\", \"validationHint\": \"\", \"customClass\": \"\", \"labelIconClass\": null, \"labelIconPosition\": \"rear\", \"labelTooltip\": null, \"minLength\": null, \"maxLength\": null, \"showWordLimit\": false, \"onCreated\": \"\", \"onMounted\": \"\", \"onInput\": \"\", \"onChange\": \"\", \"onFocus\": \"\", \"onBlur\": \"\", \"onValidate\": \"\" }, \"id\": \"textarea52469\" } ], \"options\": { \"name\": \"gridCol106250\", \"hidden\": false, \"span\": 12, \"offset\": 0, \"push\": 0, \"pull\": 0, \"responsive\": false, \"md\": 12, \"sm\": 12, \"xs\": 12, \"customClass\": \"\" }, \"id\": \"grid-col-106250\" }, { \"type\": \"grid-col\", \"category\": \"container\", \"icon\": \"grid-col\", \"internal\": true, \"widgetList\": [ { \"type\": \"textarea\", \"icon\": \"textarea-field\", \"formItemFlag\": true, \"options","date":"2022-12-16","objectID":"/chatgptformcreat%E7%94%9F%E6%88%90%E7%9A%84vue%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/:2:0","tags":["ChatGPT"],"title":"【ChatGPT】FormCreat生成的vue文件如何使用","uri":"/chatgptformcreat%E7%94%9F%E6%88%90%E7%9A%84vue%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/"},{"categories":["ChatGPT"],"content":"ChatGPT答复如下 这段代码看起来是一个Vue.js组件的模板和脚本部分。 在模板中，它包含了一个v-form-render组件，这个组件使用了三个 prop：form-json、form-data和option-data，并且给了它一个 ref。这个组件后面跟着一个 el-button 组件，这个组件有一个 type 属性为 primary，并且绑定了一个 click 事件处理函数 submitForm。 在脚本中，这个组件定义了一个对象，这个对象有一个 data 函数，这个函数返回了一个对象，这个对象里有一个 formJson 属性，它的值是一个大型的 JSON 对象。 要使用这个组件，你需要在你的 Vue 应用中引入它，然后在某个模板中使用它。例如，你可以在你的应用中定义一个组件： \u003ctemplate\u003e \u003cdiv\u003e \u003cmy-form-component :form-json=\"formJson\" :form-data=\"formData\" :option-data=\"optionData\"/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import MyFormComponent from './path/to/my-form-component.vue' export default { components: { MyFormComponent }, data() { return { formJson: {...}, formData: {...}, optionData: {...} } } } \u003c/script\u003e 在模板中，你可以使用 my-form-component 组件，并且通过 props 传入相应的数据。 你还可以在脚本中定义一个 submitForm 函数，这个函数会在点击按钮时被调用。你可以通过在组件的 methods 对象中定义这个函数来实现这个功能。 例如： \u003ctemplate\u003e \u003cdiv\u003e \u003cmy-form-component :form-json=\"formJson\" :form-data=\"formData\" :option-data=\"optionData\" @submit=\"submitForm\"/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import MyFormComponent from './path/to/my-form-component.vue' export default { components: { MyFormComponent }, data() { return { formJson: {...}, formData: {...}, optionData: {...} } }, methods: { submitForm(formData) { // 在这里处理提交表单的逻辑 } } } \u003c/script\u003e 在这个例子中，我们在模板中为 my-form-component 绑定了一个 submit 事件，并且在组件的 methods 对象中定义了一个 submitForm 函数。当点击提交按钮时，组件会触发 submit 事件，并且把表单数据作为参数传递给事件处理函数。你可以在事件处理函数中进行相应的逻辑处理。 希望这能帮助你理解这段代码的作用。如果你有其他问题，请随时追问。 ","date":"2022-12-16","objectID":"/chatgptformcreat%E7%94%9F%E6%88%90%E7%9A%84vue%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/:3:0","tags":["ChatGPT"],"title":"【ChatGPT】FormCreat生成的vue文件如何使用","uri":"/chatgptformcreat%E7%94%9F%E6%88%90%E7%9A%84vue%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8/"},{"categories":["排版"],"content":"在横向页面上相同位置（相对纵向页面）设置页眉页脚 参见:https://www.lfhacks.com/tech/header-and-footer-in-landscape/ ","date":"2022-12-11","objectID":"/word%E6%8E%92%E7%89%88%E6%8A%80%E5%B7%A7%E5%A4%87%E5%BF%98/:1:0","tags":["Word","WPS","排版"],"title":"word排版技巧备忘","uri":"/word%E6%8E%92%E7%89%88%E6%8A%80%E5%B7%A7%E5%A4%87%E5%BF%98/"},{"categories":["排版"],"content":"归纳: 进入页眉页脚编辑页面后，插入文本框，并将文本框移动到页面任意位置（当前我们需要移动到相对纵向页面相同位置）。 Word 中直接在文本框中插入当前页码。 WPS 中不支持直接在当前位置插入页码，需要在页眉页脚设置选项卡中的域中选择当前页码（同样也会根据章节不同变化）。 Word文档里面，正式文档经常需要加页眉页脚，用来在每页显示相同的文档信息和页码。但是横向排版的页面内，页眉页脚的默认方向不便于打印。本文提供一种方法。 横向排版的页面内，页眉页脚的默认方向如下图： 从上图里看出，在纵向（Portrait）和横向（Landscape）的页面里，页眉和页脚的方向相同，在Word程序里看起来，都在页面的上部和下部。 但是，在更多的场合里，横向排版的页面仍然采取纵向的装订方式，需要配合与纵向相同的页眉页脚，word这种默认的形式就不切合实际。应该采取下图的样式。 下面介绍怎么实现横向页面的页眉页脚。 首先，进入页眉页脚编辑模式。在工具栏里选择\"插入\"-“页眉”。在出现的下拉预览菜单里，不要选择任何一种预置样式，而要选择下面的\"编辑页眉\"命令。如果选择了预置的样式，word会给你按默认格式画出一条横向的页眉线。 这样就进入了页眉页脚编辑模式。在工具栏里选择\"插入\"-“文本框”。 在想要添加页眉页脚的地方，插入文本框。注意，这两个文本框并没有加在正文里，仍然是在页眉页脚层内。 在文本框内加入所希望的文字，调整文字方向。这个文本框里可以加入和正常页脚一样的总页码和页码编号。 在文本框的样式设置里，去掉两个文本框的边框。为了添加页眉下面的横线，可以选中页眉文字的段落，设置段落的下边框为细实线，这样就实现了横向页面的页眉页脚。 最终实现的效果就是下图这样。 ","date":"2022-12-11","objectID":"/word%E6%8E%92%E7%89%88%E6%8A%80%E5%B7%A7%E5%A4%87%E5%BF%98/:1:1","tags":["Word","WPS","排版"],"title":"word排版技巧备忘","uri":"/word%E6%8E%92%E7%89%88%E6%8A%80%E5%B7%A7%E5%A4%87%E5%BF%98/"},{"categories":["排版"],"content":"跨页的表格在顶端重复出现标题行 选中需要操作的表格的标题行（整行），在上方出现的表格工具中激活标题行重复，如还未设置成功，则在表格属性的行选项卡中激活在各页顶端以标题行形式重复出现 ","date":"2022-12-11","objectID":"/word%E6%8E%92%E7%89%88%E6%8A%80%E5%B7%A7%E5%A4%87%E5%BF%98/:2:0","tags":["Word","WPS","排版"],"title":"word排版技巧备忘","uri":"/word%E6%8E%92%E7%89%88%E6%8A%80%E5%B7%A7%E5%A4%87%E5%BF%98/"},{"categories":["排版"],"content":"手动目录的设置 参见: ","date":"2022-12-11","objectID":"/word%E6%8E%92%E7%89%88%E6%8A%80%E5%B7%A7%E5%A4%87%E5%BF%98/:3:0","tags":["Word","WPS","排版"],"title":"word排版技巧备忘","uri":"/word%E6%8E%92%E7%89%88%E6%8A%80%E5%B7%A7%E5%A4%87%E5%BF%98/"},{"categories":["排版"],"content":"表格后面多出大段空白或空白页面 参见: ","date":"2022-12-11","objectID":"/word%E6%8E%92%E7%89%88%E6%8A%80%E5%B7%A7%E5%A4%87%E5%BF%98/:4:0","tags":["Word","WPS","排版"],"title":"word排版技巧备忘","uri":"/word%E6%8E%92%E7%89%88%E6%8A%80%E5%B7%A7%E5%A4%87%E5%BF%98/"},{"categories":["排版"],"content":"正文当前页注释(脚注) 参见: ","date":"2022-12-11","objectID":"/word%E6%8E%92%E7%89%88%E6%8A%80%E5%B7%A7%E5%A4%87%E5%BF%98/:5:0","tags":["Word","WPS","排版"],"title":"word排版技巧备忘","uri":"/word%E6%8E%92%E7%89%88%E6%8A%80%E5%B7%A7%E5%A4%87%E5%BF%98/"},{"categories":["排版"],"content":"WPS文档中分隔符显示方法 参见: ","date":"2022-12-11","objectID":"/word%E6%8E%92%E7%89%88%E6%8A%80%E5%B7%A7%E5%A4%87%E5%BF%98/:6:0","tags":["Word","WPS","排版"],"title":"word排版技巧备忘","uri":"/word%E6%8E%92%E7%89%88%E6%8A%80%E5%B7%A7%E5%A4%87%E5%BF%98/"},{"categories":["excel","word"],"content":"根据excel生成word 有如下表格共1000行数据: 甲方姓名 甲方身份证号码 甲方电话 乙方姓名 乙方身份证号码 乙方电话 合同编号 签订日期 陈丽丽 150823194101084012 18876426141 徐玉珍 130530197909159360 13735275612 98557687 2021年1月6日 陈莉 230129199207274837 15527748346 席云 440803195304163413 15542051980 56999092 2021年1月9日 唐俊 220802198905222112 13347159392 刘帆 430529197411275992 14785266430 38267280 2021年1月14日 林玉梅 440113199406258694 15287427426 詹畅 610825195011187585 15802996916 78613331 2021年1月20日 贺莹 623024198704055436 13066008578 李晶 370322193408258876 13189489322 64536399 2021年3月14日 尚瑜 330411197704276822 14728721320 黄兰英 623001197411193262 18235199781 61647241 2021年3月24日 该表格使用Python的Faker库进行生成。 from faker import Faker from datetime import datetime my_fake = Faker(\"zh-CN\") for i in range(100): print( my_fake.name(), # 生成随机姓名 my_fake.ssn(), # 生成随机身份证号码 my_fake.phone_number() # 生成随机手机号码 my_fake.name(), # 生成随机姓名 my_fake.ssn(), # 生成随机身份证号码 my_fake.phone_number() # 生成随机手机号码 my_fake.random_int(min=10000000,max=99999999) # 生成随机的8位数 my_fake.date_between_dates(date_start=datetime(2021,1,1), date_end=datetime(2022,12,31)) # 生成日期 ) 以及如下word文档： 使用邮件功能（这功能名称真奇怪，可能是历史遗留下来的）。 操作看下面动图： ","date":"2022-10-30","objectID":"/%E6%A0%B9%E6%8D%AEexcel%E8%A1%A8%E6%A0%BC%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%9B%BA%E5%AE%9A%E6%A0%BC%E5%BC%8Fword%E6%96%87%E6%A1%A3/:1:0","tags":["excel","word"],"title":"根据excel表格自动生成固定格式word文档","uri":"/%E6%A0%B9%E6%8D%AEexcel%E8%A1%A8%E6%A0%BC%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%9B%BA%E5%AE%9A%E6%A0%BC%E5%BC%8Fword%E6%96%87%E6%A1%A3/"},{"categories":["excel","word"],"content":"提取word固定位置内容到excel表格 相当于步奏一的逆过程。https://view.inews.qq.com/k/20220216A0C3QP00?web_channel=wap\u0026openApp=false ","date":"2022-10-30","objectID":"/%E6%A0%B9%E6%8D%AEexcel%E8%A1%A8%E6%A0%BC%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%9B%BA%E5%AE%9A%E6%A0%BC%E5%BC%8Fword%E6%96%87%E6%A1%A3/:2:0","tags":["excel","word"],"title":"根据excel表格自动生成固定格式word文档","uri":"/%E6%A0%B9%E6%8D%AEexcel%E8%A1%A8%E6%A0%BC%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%9B%BA%E5%AE%9A%E6%A0%BC%E5%BC%8Fword%E6%96%87%E6%A1%A3/"},{"categories":null,"content":"一键脚本地址： https://github.com/imajeason/nas_tools/blob/main/NaiveProxy/install.sh 防走失备份如下： #!/bin/bash red='\\e[91m' green='\\e[92m' yellow='\\e[93m' magenta='\\e[95m' cyan='\\e[96m' none='\\e[0m' _red() { echo -e ${red}$*${none}; } _green() { echo -e ${green}$*${none}; } _yellow() { echo -e ${yellow}$*${none}; } _magenta() { echo -e ${magenta}$*${none}; } _cyan() { echo -e ${cyan}$*${none}; } # Root [[ $(id -u) != 0 ]] \u0026\u0026 echo -e \"\\n 哎呀……请使用 ${red}root ${none}用户运行 ${yellow}~(^_^) ${none}\\n\" \u0026\u0026 exit 1 cmd=\"apt-get\" sys_bit=$(uname -m) case $sys_bit in # i[36]86) # v2ray_bit=\"32\" # caddy_arch=\"386\" # ;; 'amd64' | x86_64) v2ray_bit=\"64\" caddy_arch=\"amd64\" ;; # *armv6*) # v2ray_bit=\"arm32-v6\" # caddy_arch=\"arm6\" # ;; # *armv7*) # v2ray_bit=\"arm32-v7a\" # caddy_arch=\"arm7\" # ;; *aarch64* | *armv8*) v2ray_bit=\"arm64-v8a\" caddy_arch=\"arm64\" ;; *) echo -e \" 哈哈……这个 ${red}辣鸡脚本${none} 不支持你的系统。 ${yellow}(-_-) ${none} 备注: 仅支持 Ubuntu 16+ / Debian 8+ / CentOS 7+ 系统 \" \u0026\u0026 exit 1 ;; esac # 笨笨的检测方法 if [[ $(command -v apt-get) || $(command -v yum) ]] \u0026\u0026 [[ $(command -v systemctl) ]]; then if [[ $(command -v yum) ]]; then cmd=\"yum\" fi if [[ $(command -v apt-get) ]]; then apt-get update -y apt-get install curl -y fi else echo -e \" 哈哈……这个 ${red}辣鸡脚本${none} 不支持你的系统。 ${yellow}(-_-) ${none} 备注: 仅支持 Ubuntu 16+ / Debian 8+ / CentOS 7+ 系统 \" \u0026\u0026 exit 1 fi uuid=$(cat /proc/sys/kernel/random/uuid) systemd=true # _test=true _sys_timezone() { IS_OPENVZ= if hostnamectl status | grep -q openvz; then IS_OPENVZ=1 fi echo timedatectl set-timezone Asia/Shanghai timedatectl set-ntp true echo \"已将你的主机设置为Asia/Shanghai时区并通过systemd-timesyncd自动同步时间。\" echo if [[ $IS_OPENVZ ]]; then echo echo -e \"你的主机环境为 ${yellow}Openvz${none} ，建议使用${yellow}v2ray mkcp${none}系列协议。\" echo -e \"注意：${yellow}Openvz${none} 系统时间无法由虚拟机内程序控制同步。\" echo -e \"如果主机时间跟实际相差${yellow}超过90秒${none}，v2ray将无法正常通信，请发ticket联系vps主机商调整。\" fi } _sys_time() { echo -e \"\\n主机时间：${yellow}\" timedatectl status | sed -n '1p;4p' echo -e \"${none}\" [[ $IS_OPENV ]] \u0026\u0026 pause } naive_config() { echo while :; do echo -e \"请输入 \"$yellow\"NaiveProxy\"$none\" 端口 [\"$magenta\"1-65535\"$none\"]，不能选择 \"$magenta\"80\"$none\"端口\" read -p \"$(echo -e \"(默认端口: ${cyan}443$none):\")\" naive_port [ -z \"$naive_port\" ] \u0026\u0026 naive_port=443 case $naive_port in 80) echo echo \" ...都说了不能选择 80 端口了咯.....\" error ;; [1-9] | [1-9][0-9] | [1-9][0-9][0-9] | [1-9][0-9][0-9][0-9] | [1-5][0-9][0-9][0-9][0-9] | 6[0-4][0-9][0-9][0-9] | 65[0-4][0-9][0-9] | 655[0-3][0-5]) echo echo echo -e \"$yellow naive_port 端口 = $cyan$naive_port$none\" echo \"----------------------------------------------------------------\" echo break ;; *) error ;; esac done while :; do echo echo -e \"请输入一个 ${magenta}正确的域名${none}，一定一定一定要正确，不！能！出！错！\" read -p \"(例如：n.abc.com): \" domain [ -z \"$domain\" ] \u0026\u0026 error \u0026\u0026 continue echo echo echo -e \"$yellow 你的域名 = $cyan$domain$none\" echo \"----------------------------------------------------------------\" break done while :; do echo echo -e \"请输入一个 ${magenta}邮箱${none}，邮箱不能乱输，格式要对。\" read -p \"(例如：name@abc.com): \" email [ -z \"$email\" ] \u0026\u0026 error \u0026\u0026 continue echo echo echo -e \"$yellow 你的邮箱 = $cyan$email$none\" echo \"----------------------------------------------------------------\" break done get_ip echo echo echo -e \"$yellow 请将 $magenta$domain$none $yellow 解析到: $cyan$ip$none\" echo echo -e \"$yellow 请将 $magenta$domain$none $yellow 解析到: $cyan$ip$none\" echo echo -e \"$yellow 请将 $magenta$domain$none $yellow 解析到: $cyan$ip$none\" echo \"----------------------------------------------------------------\" echo while :; do read -p \"$(echo -e \"(是否已经正确解析: [${magenta}Y$none]):\") \" record if [[ -z \"$record\" ]]; then error else if [[ \"$record\" == [Yy] ]]; then domain_check echo echo echo -e \"$yellow 域名解析 = ${cyan}我确定已经有解析了$none\" echo \"----------------------------------------------------------------\" echo break else error fi fi done } install_info() { clear echo echo \" ....准备安装了咯..看看有毛有配置正确了...\" echo echo \"---------- 安装信息 -------------\" echo echo -e \"$yellow NaiveProxy 端口 = $cyan$naive_port$none\" echo echo -e \"$yellow 你的域名","date":"2022-10-29","objectID":"/naiveproxy%E6%90%AD%E5%BB%BA/:0:0","tags":null,"title":"NaiveProxy搭建","uri":"/naiveproxy%E6%90%AD%E5%BB%BA/"},{"categories":null,"content":"2023年3月23日更新 naiveproxy一键脚本发布（无须编译caddy，支持多端口复用，自定义伪装网页），演示甲骨文纯IPV4（mack-a）+纯IPV6(X-UI)与naiveproxy共存方式的教程：https://ygkkk.blogspot.com/2022/11/naiveproxy-yg-youtube.html https://gitlab.com/rwkgyg/naiveproxy-yg https://github.com/klzgrad/naiveproxy/releases https://github.com/v2fly/v2ray-core https://github.com/Qv2ray/Qv2ray/releases ","date":"2022-10-29","objectID":"/naiveproxy%E6%90%AD%E5%BB%BA/:1:0","tags":null,"title":"NaiveProxy搭建","uri":"/naiveproxy%E6%90%AD%E5%BB%BA/"},{"categories":null,"content":"背景 拿到一个postgresql数据库导出的SQL备份文件（4.3G大小），需要重新导入数据库中开展后续工作。 ","date":"2022-10-22","objectID":"/postgresql%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/:1:0","tags":null,"title":"postgresql逻辑备份与恢复","uri":"/postgresql%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"弯路 使用postgresql官方管理工具pgAdmin及有名的Navicat进行导入操作，均报错。因工作急需将备份文件恢复到数据库，转而使用emeditor打开，并使用正则匹配的方式提取需要的字段，再导入数据库，因数据量庞大，硬件性能有限，整个过程花费将近3个小时。 ","date":"2022-10-22","objectID":"/postgresql%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/:2:0","tags":null,"title":"postgresql逻辑备份与恢复","uri":"/postgresql%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"解决 虽然走弯路解决了问题，但是备份文件所承载的数据信息仍未完整呈现。于是不停地网上搜索，发现下面链接：https://www.xmmup.com/pgluojibeifenhuifuluojidaochudaoru.html ","date":"2022-10-22","objectID":"/postgresql%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/:3:0","tags":null,"title":"postgresql逻辑备份与恢复","uri":"/postgresql%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"找到psql.exe文件，运行如下命令。 psql --username=postgres --host=192.168.66.35 --port=15433 --dbname=sbtest --file=/bk/sbtest.sql ","date":"2022-10-22","objectID":"/postgresql%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/:3:1","tags":null,"title":"postgresql逻辑备份与恢复","uri":"/postgresql%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"trojan安装 ","date":"2022-10-04","objectID":"/trojan%E6%90%AD%E5%BB%BA/:1:0","tags":["代理"],"title":"trojan搭建","uri":"/trojan%E6%90%AD%E5%BB%BA/"},{"categories":null,"content":"先更新系统证书，否则再申请网站证书时会失败 yum update ca-certificates ","date":"2022-10-04","objectID":"/trojan%E6%90%AD%E5%BB%BA/:1:1","tags":["代理"],"title":"trojan搭建","uri":"/trojan%E6%90%AD%E5%BB%BA/"},{"categories":null,"content":"再拉取运行脚本 source \u003c(curl -sL https://git.io/trojan-install) ","date":"2022-10-04","objectID":"/trojan%E6%90%AD%E5%BB%BA/:1:2","tags":["代理"],"title":"trojan搭建","uri":"/trojan%E6%90%AD%E5%BB%BA/"},{"categories":null,"content":"No route to host错误的解决 症状：客户端能连上，一切正常，但是无法出境浏览网站。 排错：登录服务器查看日志，发现有cannot establish connection to remote server www.google.com:443: No route to ho报错记录。 Google搜索发现是因为VPS同时支持IPV4和IPV6导致的，详情见:https://github.com/trojan-gfw/trojan/issues/327 解决方案：在/etc/gai.conf中增加一行precedence ::ffff:0:0/96 100，然后reboot大法。 ","date":"2022-10-04","objectID":"/trojan%E6%90%AD%E5%BB%BA/:1:3","tags":["代理"],"title":"trojan搭建","uri":"/trojan%E6%90%AD%E5%BB%BA/"},{"categories":null,"content":"xray一键脚本 bash \u003c(curl -sL https://raw.githubusercontent.com/daveleung/hijkpw-scripts-mod/main/xray_mod1.sh) ","date":"2022-10-04","objectID":"/trojan%E6%90%AD%E5%BB%BA/:2:0","tags":["代理"],"title":"trojan搭建","uri":"/trojan%E6%90%AD%E5%BB%BA/"},{"categories":null,"content":"【转载自：https://segmentfault.com/a/1190000039887159】 我的博客使用 GitHub 上的 pages 功能发布的基于 Hugo 生成的静态网站，基本无法正常访问，所以想要同步一份到 gitee 上发布，现在使用 GitHub Actions 提供的计算机资源就可以直接在 GitHub 上进行静态网站的生成，发布，远程刷新 gitee pages，触发条件可以是 push 或者定时等等，可谓十分好用，之后看到可以直接同步到 gitee 仓库，就实现一下试试，以下就是实现步骤，以及踩坑，当然强烈建议看开源代码的官方说明文档。 ","date":"2022-09-05","objectID":"/github-actions-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-hugo-%E5%88%B0-gitee-%E5%90%8C%E6%97%B6%E5%88%B7%E6%96%B0-gitee-pages/:0:0","tags":null,"title":"Github Actions 自动部署 Hugo 到 Gitee 同时刷新 Gitee Pages","uri":"/github-actions-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-hugo-%E5%88%B0-gitee-%E5%90%8C%E6%97%B6%E5%88%B7%E6%96%B0-gitee-pages/"},{"categories":null,"content":"生成公钥和私钥并填入仓库 输入 ssh-keygen -t rsa -C \"user@email.com\"，然后回车几次，会生成 id_rsa.pub 文件和 id_rsa 文件，分别存放公钥和私钥： image Gitee 仓库填入公钥 将公钥 id_rsa.pub 中的数据填入到 gitee 待备份仓库界面下 settings→Deploy keys→add personal public key 这里注意: 要选右上添加 personal public key 才有写入权限 image GitHub 仓库填入私钥 Settings→Secret→New repository secre 用于之后的程序环境配置访问，命名为 GITEE_RSA_PRIVATE_KEY image ","date":"2022-09-05","objectID":"/github-actions-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-hugo-%E5%88%B0-gitee-%E5%90%8C%E6%97%B6%E5%88%B7%E6%96%B0-gitee-pages/:0:1","tags":null,"title":"Github Actions 自动部署 Hugo 到 Gitee 同时刷新 Gitee Pages","uri":"/github-actions-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-hugo-%E5%88%B0-gitee-%E5%90%8C%E6%97%B6%E5%88%B7%E6%96%B0-gitee-pages/"},{"categories":null,"content":"生成 GitHub 账号的 personal access token image 将仓库权限选上就行了，然后将生成的 token，配到私钥配置的地方 仓库→Settings→Secret→New repository secre，命名为 ACCESS_TOKEN image-20210423172942681 ","date":"2022-09-05","objectID":"/github-actions-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-hugo-%E5%88%B0-gitee-%E5%90%8C%E6%97%B6%E5%88%B7%E6%96%B0-gitee-pages/:0:2","tags":null,"title":"Github Actions 自动部署 Hugo 到 Gitee 同时刷新 Gitee Pages","uri":"/github-actions-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-hugo-%E5%88%B0-gitee-%E5%90%8C%E6%97%B6%E5%88%B7%E6%96%B0-gitee-pages/"},{"categories":null,"content":"在仓库 secret 处添加 GITEE_PASSWORD，放入 gitee 账号密码用于刷新 gitee pages 同之前步骤相同，之后用于环境变量的配置，就是以下 3 条 secret，OSS 的是自动部署到阿里 OSS 的脚本使用的，我是放在一个脚本里运行，需要了解可以看我另一篇文章。 ","date":"2022-09-05","objectID":"/github-actions-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-hugo-%E5%88%B0-gitee-%E5%90%8C%E6%97%B6%E5%88%B7%E6%96%B0-gitee-pages/:0:3","tags":null,"title":"Github Actions 自动部署 Hugo 到 Gitee 同时刷新 Gitee Pages","uri":"/github-actions-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-hugo-%E5%88%B0-gitee-%E5%90%8C%E6%97%B6%E5%88%B7%E6%96%B0-gitee-pages/"},{"categories":null,"content":"在 GitHub 仓库创建并编写 Actions 脚本！！！ 文件名随意从这点开就行，下面有模板，点开后修改也行，创建的文件默认放在.github/workflows/ 下 也可以用命令创建 mkdir -p .github/workflows \u0026\u0026 touch .github/workflows/name.yml image 将代码拷入，修改具体变量，比如仓库名等，如果不需要 deploy 直接去掉就行了，不影响： name: deploy blog to gitee on: push: branches: \\- main \\# master 分支 push 的时候触发 jobs: deploy: #执行部署Hugo生成静态代码，默认放在gh-pages分支 runs-on: ubuntu-18.04 steps: \\- uses: actions/checkout@v2 with: submodules: recursive \\# Fetch Hugo themes (true OR recursive) fetch-depth: 0 \\# Fetch all history for .GitInfo and .Lastmod \\- name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: '0.81.0' extended: true #不需要extended版本就可以注释 \\- name: Build run: hugo \\--minify \\- name: Deploypage uses: peaceiris/actions-gh-pages@v3 with: personal\\_token: ${{ secrets.ACCESS\\_TOKEN }} external\\_repository: JohntunLiu/JohntunLiu.github.io publish\\_branch: gh-pages \\# default: gh-pages publish\\_dir: ./public \\- name: Deploygitee uses: peaceiris/actions-gh-pages@v3 with: personal\\_token: ${{ secrets.ACCESS\\_TOKEN }} publish\\_dir: ./public sync: #同步到gitee仓库 needs: deploy runs-on: ubuntu-latest steps: \\- name: Sync to Gitee uses: wearerequired/git-mirror-action@master env: SSH\\_PRIVATE\\_KEY: ${{ secrets.GITEE\\_RSA\\_PRIVATE\\_KEY }} with: \\# 来源仓库 source-repo: \"git@github.com:JohntunLiu/myblog.git\" \\# 目标仓库 destination-repo: \"git@gitee.com:JohntunLiu/JohntunLiu.git\" reload-pages: needs: sync runs-on: ubuntu-latest steps: \\- name: Build Gitee Pages uses: yanglbme/gitee-pages-action@main with: \\# 注意替换为你的 Gitee 用户名 gitee-username: JohntunLiu \\# 注意在 Settings-\u003eSecrets 配置 GITEE\\_PASSWORD gitee-password: ${{ secrets.GITEE\\_PASSWORD }} \\# 注意替换为你的 Gitee 仓库，仓库名严格区分大小写，请准确填写，否则会出错 gitee-repo: JohntunLiu/JohntunLiu \\# 要部署的分支，默认是 master，若是其他分支，则需要指定（指定的分支必须存在） branch: gh-pages 点击 commit changes 提交运行，之后就看得到运行流程了 image ","date":"2022-09-05","objectID":"/github-actions-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-hugo-%E5%88%B0-gitee-%E5%90%8C%E6%97%B6%E5%88%B7%E6%96%B0-gitee-pages/:0:4","tags":null,"title":"Github Actions 自动部署 Hugo 到 Gitee 同时刷新 Gitee Pages","uri":"/github-actions-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-hugo-%E5%88%B0-gitee-%E5%90%8C%E6%97%B6%E5%88%B7%E6%96%B0-gitee-pages/"},{"categories":null,"content":"实际效果和流程 如果是部署其他静态网站，修改 deploy 的代码块就行了，我顺便把部署到 GitHub pages 放在了里面：name: Deploypage 如果是 hugo 的话开源人员还提供了缓存机制，可以提高部署速度，可以去开源部分看，具体怎么看就是复制 - uses: peaceiris/actions-hugo@v2 后面的部分搜索到 GitHub 中看，比如：https://github.com/peaceiris/actions-hugo，readme.md 文档写得相当详实，也会更新说明 image 更多精彩可以关注微信公众号 LiuJohntun，记录并分享我的所见、所学、所想… ","date":"2022-09-05","objectID":"/github-actions-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-hugo-%E5%88%B0-gitee-%E5%90%8C%E6%97%B6%E5%88%B7%E6%96%B0-gitee-pages/:0:5","tags":null,"title":"Github Actions 自动部署 Hugo 到 Gitee 同时刷新 Gitee Pages","uri":"/github-actions-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-hugo-%E5%88%B0-gitee-%E5%90%8C%E6%97%B6%E5%88%B7%E6%96%B0-gitee-pages/"},{"categories":null,"content":"环境 BWG CENTOS 7 with BBR installed 1、yum update ca-certificates不安装这个，为申请域名证书时会报错 2、source \u003c(curl -sL https://git.io/trojan-install) …. ","date":"2022-06-25","objectID":"/trojan%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:0","tags":null,"title":"Trojan搭建记录","uri":"/trojan%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"ss、ssr、v2ray链接解析 ?\u003e 网上有很多人会分享一些免费的 ss、ssr 免费账号，也有少数分享v2ray的；有的会直接把服务、端口、ip、协议等展示出来，直接手动输入相应参数就可以了，有的则直接显示二维码，直接用客户端软件扫一下就可以使用。 不过，也有很多是直接以链接的形式展示出来，比如 ss://xxxxx 或 ssr://xxxx,对于这种链接的方式，复制链接后，直接使用ss 、ssr客户端右键从粘贴板导入url链接即可。 ","date":"2022-05-17","objectID":"/%E7%BF%BB%E5%A2%99%E5%8D%8F%E8%AE%AE%E9%93%BE%E6%8E%A5%E8%A7%A3%E6%9E%90/:1:0","tags":["VPN"],"title":"翻墙协议链接解析","uri":"/%E7%BF%BB%E5%A2%99%E5%8D%8F%E8%AE%AE%E9%93%BE%E6%8E%A5%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"SS链接 以ss链接为例，链接如下： ss://YWVzLTI1Ni1jZmI6S1NYTmhuWnBqd0M2UGM2Q0A1NC4xNjkuMzUuMjI4OjMxNDQ0 用base64解码站长工具（此工具存在和谐因素，仅为演示方便）进行解码 从这两幅图也不难看出格式其实是这样的 ss://method:password@server:port，按照这个格式的写法并进行base64编码，就能将ss分享给对方使用。 若是分享二维码，可以用二维码生成器将ss链接嵌入二维码中扫描分享 ","date":"2022-05-17","objectID":"/%E7%BF%BB%E5%A2%99%E5%8D%8F%E8%AE%AE%E9%93%BE%E6%8E%A5%E8%A7%A3%E6%9E%90/:1:1","tags":["VPN"],"title":"翻墙协议链接解析","uri":"/%E7%BF%BB%E5%A2%99%E5%8D%8F%E8%AE%AE%E9%93%BE%E6%8E%A5%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"SSR链接 再来看ssr的url，链接如下： ssr://NjQuMTM3LjIyOC4zNTo1NzYwOmF1dGhfc2hhMV92NDpjaGFjaGEyMDp0bHMxLjJfdGlja2V0X2F1dGg6Wkc5MVlpNXBieTl6YzNwb1puZ3ZLalUzTmpBLz9yZW1hcmtzPTVweXM1WVdONkxTNTZMU201WS0zNXAybDZJZXFPbVJ2ZFdJdWFXOHZjM042YUdaNEx3 使用base64工具解码 字符串包含–，需在解码前把–这个字符通通替换为+字符 效果如下 再来看ssr链接导入的截图 由此得知，格式如下 ssr://ip:port:protocol:method:blending:password/?remarks=other text 有时也会看到部分解码后，这样的格式 159.65.1.189:5252:auth_sha1_v4:rc4-md5:http_simple:NTJzc3IubmV0/?obfsparam=\u0026protoparam=\u0026group=d3d3LnNzcnNoYXJlLmNvbQ\u0026remarks=RE1fTm9kZQ 这其中obfsparam、protoparam、group、remarks等都是可选的，也可不填。 ","date":"2022-05-17","objectID":"/%E7%BF%BB%E5%A2%99%E5%8D%8F%E8%AE%AE%E9%93%BE%E6%8E%A5%E8%A7%A3%E6%9E%90/:1:2","tags":["VPN"],"title":"翻墙协议链接解析","uri":"/%E7%BF%BB%E5%A2%99%E5%8D%8F%E8%AE%AE%E9%93%BE%E6%8E%A5%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"v2ray链接 其实v2ray链接与相关二维码生成与上述方法是差不多的，只是配置参数格式大同小异而已。v2ray不像ss那样有统一规定的url格式，所以各个v2ray图形客户端的分享链接或是二维码不一定通用 v2ray的链接如下 vmess://ew0KICAicHMiOiAicnVzc2lhbi1jbG91ZCIsDQogICJhZGQiOiAiMTg1LjE3Ny4yMTYuMTM0IiwNCiAgInBvcnQiOiAiMjI1MzUiLA0KICAiaWQiOiAiNTIwNTAwNTctZjVlMS00YjllLWI3OGItNWY0OWI1NDlmZDIxIiwNCiAgImFpZCI6ICI2NCIsDQogICJuZXQiOiAia2NwIiwNCiAgInR5cGUiOiAic3J0cCIsDQogICJob3N0IjogIiIsDQogICJ0bHMiOiAiIg0KfQ== 进行base64解码之后再对比v2ray客户端的参数配置就显得一目了然 可以说大体是这么一个格式 { \"ps\": \"别名\", \"add\": \"ip地址\", \"port\": \"端口\", \"id\": \"uuid\", \"aid\": \"alterid\", \"net\": \"传输协议\", \"type\": \"伪装类型\", \"host\": \" http header参数\", \"tls\": \"底层传输安全\" } 除别名外，可以说服务器与客户端的参数必须要相互对应，别名、留空的是可以省略的。按照这个相关格式生成base64编码。 在base64编码首部加上vmess://协议头 vmess://ewogICJhZGQiOiAiMTg1LjE3Ny4yMTYuMTM0IiwKICAicG9ydCI6ICIyMjUzNSIsCiAgImlkIjogIjUyMDUwMDU3LWY1ZTEtNGI5ZS1iNzhiLTVmNDliNTQ5ZmQyMSIsCiAgImFpZCI6ICI2NCIsCiAgIm5ldCI6ICJrY3AiLAogICJ0eXBlIjogInNydHAiCn0= 将其导入至v2ray客户端，在服务器未作其他相关变更时，即可成功连接服务器。 当然添加别名更好，这样就能v2ray客户端就能自动生成相应的v2ray链接 ","date":"2022-05-17","objectID":"/%E7%BF%BB%E5%A2%99%E5%8D%8F%E8%AE%AE%E9%93%BE%E6%8E%A5%E8%A7%A3%E6%9E%90/:1:3","tags":["VPN"],"title":"翻墙协议链接解析","uri":"/%E7%BF%BB%E5%A2%99%E5%8D%8F%E8%AE%AE%E9%93%BE%E6%8E%A5%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"SSR对SS的兼容 至于ssr与ss兼容性的问题参考逗比的解答 原文：关于Shadowsocks的小白常见问题 作者：逗比 取消协议兼容原版后，当你的ShadowsocksR服务端配置了协议后，只能ShadowsocksR的客户端选择对应的协议才可以连接(SSR客户端选择原版协议也是无法连接)，而使用Shadowsocks原版客户端无法连接。 只有你设置ShadowsocksR服务端的协议为原版(origin)，那么才能ShadowsocksR客户端(选择原版协议)和Shadowsocks客户端都能链接你的ShadowsocksR服务端(账号)。 目前ShadowsocksR服务端是，auth_aes128_* 及以后的协议 都不支持兼容原版了，之前的协议可以兼容原版，混淆也都可以兼容原版。 当然了，这只针对 ShadowsocksR的协议，对于混淆参数是无所谓的，协议和混淆是可以分开的，你可以协议不设置兼容原版，而混淆设置兼容原版，或者不设置协议，而只设置混淆兼容原版，都可以，不存在协议开了，混淆也必须开的问题。 总而言之，ssr可以使用ss的服务器，但ss使用ssr的服务器的话，却未必行得通；顺便也多说一句：ssr是可使用ss链接与扫描二维码的（别没事整什么动态的短链接就行了…），反之则不生效。 我个人认为ssr倒像一个ss的升级版，是这样的一个关系： 在了解这些，那么开始进行演示，打开ssrshare论坛的小工具网页 图中的origin协议、plain混淆都是支持原版ss的，选择其中一个进行复制ss链接 将其解码 由于我们得知ss与ssr的链接格式： ss://method:password@server:port ssr://ip:port:protocol:method:blending:password 将解码后的ss的格式转成ssr的格式 对其编码 加入ssr://链接协议头，再导入至ssr并不成功，原因是密码都套上一层base64编码…因此需要对密码进行一次编码 之后，按照原有格式将部分参数配置粘贴至密码前，进行编码 再加入ssr://链接协议头，导入至ssr即可如： ssr://MTM5LjU5LjE2Ny4yNDY6NjIwMzpvcmlnaW46YWVzLTI1Ni1jZmI6cGxhaW46YVM1M2RYY3VjbVZr ","date":"2022-05-17","objectID":"/%E7%BF%BB%E5%A2%99%E5%8D%8F%E8%AE%AE%E9%93%BE%E6%8E%A5%E8%A7%A3%E6%9E%90/:1:4","tags":["VPN"],"title":"翻墙协议链接解析","uri":"/%E7%BF%BB%E5%A2%99%E5%8D%8F%E8%AE%AE%E9%93%BE%E6%8E%A5%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"v2ray对ss的兼容 ss连接v2ray的服务器，需在v2ray服务端做相应的ss兼容配置；至于v2ray连接其本身兼容ss的服务器，可能需要配置uuid等验证机制。 配置参数摘录自：V2Ray替换shadowsocks服务器详解 作者：大隐中心 \"inboundDetour\": [ { \"protocol\": \"shadowsocks\", // 开启 Shadowsocks \"port\": 30001, // 监听 30001 端口 \"settings\": { \"method\": \"aes-256-cfb\", // 加密方式，支持 aes-256-cfb 和 aes-128-cfb \"password\": \"v2ray\", // 密码，必须和客户端相同 \"udp\": false // 是否开启 UDP 转发 } }, { \"protocol\": \"shadowsocks\", // 开启 Shadowsocks \"port\": 30002, // 监听 30002 端口，由于 Shadowsocks 的限制，多用户的时候只能开多个端口 \"settings\": { // 配置和上述类似 \"method\": \"aes-256-cfb\", \"password\": \"v2ray-2\", \"udp\": false } } ], ","date":"2022-05-17","objectID":"/%E7%BF%BB%E5%A2%99%E5%8D%8F%E8%AE%AE%E9%93%BE%E6%8E%A5%E8%A7%A3%E6%9E%90/:1:5","tags":["VPN"],"title":"翻墙协议链接解析","uri":"/%E7%BF%BB%E5%A2%99%E5%8D%8F%E8%AE%AE%E9%93%BE%E6%8E%A5%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"运行可道云 kodcloud/kodexplorer:latest含arm64架构镜像 docker run -d -p 3563:80 kodcloud/kodexplorer:latest ","date":"2022-05-11","objectID":"/%E5%8F%AF%E9%81%93%E4%BA%91%E6%90%AD%E5%BB%BAamd64/:1:0","tags":["可道云","onlyoffice"],"title":"可道云+onlyoffice搭建【amd64+arm64】","uri":"/%E5%8F%AF%E9%81%93%E4%BA%91%E6%90%AD%E5%BB%BAamd64/"},{"categories":null,"content":"运行onlyoffice docker run -i -t -d --name onlyoffice -p 5646:80 onlyoffice/documentserver 官方只支持amd64 下面是支持arm64的第三方 https://github.com/jiriks74/Docker-DocumentServer-Arm64 对应镜像：jiriks74/onlyoffice-documentserver-arm64 ","date":"2022-05-11","objectID":"/%E5%8F%AF%E9%81%93%E4%BA%91%E6%90%AD%E5%BB%BAamd64/:2:0","tags":["可道云","onlyoffice"],"title":"可道云+onlyoffice搭建【amd64+arm64】","uri":"/%E5%8F%AF%E9%81%93%E4%BA%91%E6%90%AD%E5%BB%BAamd64/"},{"categories":null,"content":"下载’onlyoffice’插件 https://github.com/sit17/kodexplorer_onlyoffice 将下载好的压缩包解压，将onlyoffice目录丢入可道云的plugins目录中，再在插件中心启用。 然后插件中心点击onlyoffice插件进行配置，将onlyoffice地址填入其中。 ","date":"2022-05-11","objectID":"/%E5%8F%AF%E9%81%93%E4%BA%91%E6%90%AD%E5%BB%BAamd64/:3:0","tags":["可道云","onlyoffice"],"title":"可道云+onlyoffice搭建【amd64+arm64】","uri":"/%E5%8F%AF%E9%81%93%E4%BA%91%E6%90%AD%E5%BB%BAamd64/"},{"categories":null,"content":"免费版批量添加用户脚本（先复制好cookies） import requests def add_user(name): cookies = { 'KOD_SESSION_SSO': '3824713901f6ead71c6e2a0ec2feba74', 'HOST': 'http%3A//192.168.1.100%3A3563/', 'APP_HOST': 'http%3A//192.168.1.100%3A3563/', 'kodUserLanguage': 'zh-CN', 'KOD_SESSION_ID_7da51': '94b57f9211f2e95b82425f6c64d727a0', 'X-CSRF-TOKEN': 'iYekIw5nXYfNzpnSkB4t', 'kodUserID': '1', 'kodToken': '75412d60d177626ad7211faf70c806ae', 'kodVersionCheck': 'check-at-1652286052', } headers = { 'Connection': 'keep-alive', 'Pragma': 'no-cache', 'Cache-Control': 'no-cache', 'Accept': 'application/json, text/javascript, */*; q=0.01', 'DNT': '1', 'X-CSRF-TOKEN': 'iYekIw5nXYfNzpnSkB4t', 'X-Requested-With': 'XMLHttpRequest', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36', 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', 'Origin': 'http://192.168.1.100:3563', 'Referer': 'http://192.168.1.100:3563/index.php?setting', 'Accept-Language': 'zh-CN,zh;q=0.9,en-CN;q=0.8,en;q=0.7,zh-HK;q=0.6', # Requests sorts cookies= alphabetically # 'Cookie': 'KOD_SESSION_SSO=3824713901f6ead71c6e2a0ec2feba74; HOST=http%3A//192.168.1.100%3A3563/; APP_HOST=http%3A//192.168.1.100%3A3563/; kodUserLanguage=zh-CN; KOD_SESSION_ID_7da51=94b57f9211f2e95b82425f6c64d727a0; X-CSRF-TOKEN=iYekIw5nXYfNzpnSkB4t; kodUserID=1; kodToken=75412d60d177626ad7211faf70c806ae; kodVersionCheck=check-at-1652286052', } data = { 'name': name, #先url编码 'nickName': name,#先url编码 'password': 'password', 'sizeMax': '2', 'role': '2', 'groupInfo': '%7B%221%22%3A%22write%22%7D', # '{\"1\":\"write\"}', } response = requests.post('http://192.168.1.100:3563/index.php?systemMember/add', cookies=cookies, headers=headers, data=data, verify=False) add_user('555') ","date":"2022-05-11","objectID":"/%E5%8F%AF%E9%81%93%E4%BA%91%E6%90%AD%E5%BB%BAamd64/:4:0","tags":["可道云","onlyoffice"],"title":"可道云+onlyoffice搭建【amd64+arm64】","uri":"/%E5%8F%AF%E9%81%93%E4%BA%91%E6%90%AD%E5%BB%BAamd64/"},{"categories":["Python"],"content":"背景 实践当中，经常需要在Excel表中根据某一列的值去查看另一列对应的值。 比如，根据下表（假设存放在datas.xlsx）中姓名，查找其对应电话号码。 这里顺便记录一下这个网站可以方便的在excel、json、csv、yaml、markdown、xml、html表格之间互转：https://tableconvert.com/excel-to-markdown 序号 姓名 电话号码 年龄 性别 1 张三 4563453 39 男 2 李四 3453453 25 男 3 王五 2323423 18 女 4 李六 2342342 18 男 ","date":"2022-05-04","objectID":"/pandas%E6%9D%A1%E4%BB%B6%E5%AE%9A%E4%BD%8D%E5%8D%95%E5%85%83%E6%A0%BC%E7%B1%BB%E4%BC%BCsql%E6%9F%A5%E8%AF%A2/:1:0","tags":["Python","Pandas"],"title":"Pandas条件定位单元格【类似select 字段 from 表 where 其他字段=某值】","uri":"/pandas%E6%9D%A1%E4%BB%B6%E5%AE%9A%E4%BD%8D%E5%8D%95%E5%85%83%E6%A0%BC%E7%B1%BB%E4%BC%BCsql%E6%9F%A5%E8%AF%A2/"},{"categories":["Python"],"content":"实操 import pandas as pd df = pd.read_excel('datas.xlsx',header=0,encoding='gbk') # header默认为0，即从第1行开始读取数据。 gbk为了支持中文 ","date":"2022-05-04","objectID":"/pandas%E6%9D%A1%E4%BB%B6%E5%AE%9A%E4%BD%8D%E5%8D%95%E5%85%83%E6%A0%BC%E7%B1%BB%E4%BC%BCsql%E6%9F%A5%E8%AF%A2/:2:0","tags":["Python","Pandas"],"title":"Pandas条件定位单元格【类似select 字段 from 表 where 其他字段=某值】","uri":"/pandas%E6%9D%A1%E4%BB%B6%E5%AE%9A%E4%BD%8D%E5%8D%95%E5%85%83%E6%A0%BC%E7%B1%BB%E4%BC%BCsql%E6%9F%A5%E8%AF%A2/"},{"categories":["Python"],"content":"第一步 读取后Pandas默认会根据行数从0开始设置行索引，而不是将第一列作为行索引。 将姓名列设为行索引 df = df.set_index('姓名') ","date":"2022-05-04","objectID":"/pandas%E6%9D%A1%E4%BB%B6%E5%AE%9A%E4%BD%8D%E5%8D%95%E5%85%83%E6%A0%BC%E7%B1%BB%E4%BC%BCsql%E6%9F%A5%E8%AF%A2/:2:1","tags":["Python","Pandas"],"title":"Pandas条件定位单元格【类似select 字段 from 表 where 其他字段=某值】","uri":"/pandas%E6%9D%A1%E4%BB%B6%E5%AE%9A%E4%BD%8D%E5%8D%95%E5%85%83%E6%A0%BC%E7%B1%BB%E4%BC%BCsql%E6%9F%A5%E8%AF%A2/"},{"categories":["Python"],"content":"第二步 使用函数进行定位 at和loc两个函数均可，听说loc更快 df.at['李六','电话号码'] ","date":"2022-05-04","objectID":"/pandas%E6%9D%A1%E4%BB%B6%E5%AE%9A%E4%BD%8D%E5%8D%95%E5%85%83%E6%A0%BC%E7%B1%BB%E4%BC%BCsql%E6%9F%A5%E8%AF%A2/:2:2","tags":["Python","Pandas"],"title":"Pandas条件定位单元格【类似select 字段 from 表 where 其他字段=某值】","uri":"/pandas%E6%9D%A1%E4%BB%B6%E5%AE%9A%E4%BD%8D%E5%8D%95%E5%85%83%E6%A0%BC%E7%B1%BB%E4%BC%BCsql%E6%9F%A5%E8%AF%A2/"},{"categories":["Python"],"content":"列数据转换 列数据转换，比如，将电话号码列数据转换为字符串类型 df[' 电话号码'] = df[' 电话号码'].apply(str) ","date":"2022-05-04","objectID":"/pandas%E6%9D%A1%E4%BB%B6%E5%AE%9A%E4%BD%8D%E5%8D%95%E5%85%83%E6%A0%BC%E7%B1%BB%E4%BC%BCsql%E6%9F%A5%E8%AF%A2/:3:0","tags":["Python","Pandas"],"title":"Pandas条件定位单元格【类似select 字段 from 表 where 其他字段=某值】","uri":"/pandas%E6%9D%A1%E4%BB%B6%E5%AE%9A%E4%BD%8D%E5%8D%95%E5%85%83%E6%A0%BC%E7%B1%BB%E4%BC%BCsql%E6%9F%A5%E8%AF%A2/"},{"categories":["Docker"],"content":"背景 内网环境（与互联网隔离）或者无网络的电脑上已经安装好docker demon，现在需要将互联网中的镜像拷贝到内网主机上运行。操作如下： 最关键的是，学会使用 docker 的 save 命令。 你需要做的主要有 3 步骤： 1.先从一个有网络的电脑下载 docker 镜像 docker pull centos 2.保存镜像到本地文件 docker save -o centos_image.docker centos 3.把镜像拷贝到无网络的电脑，然后通过 docker 加载镜像即可。 docker load -i centos_image.docker 来源：https://blog.csdn.net/wangkai_123456/article/details/78538168 ","date":"2022-04-25","objectID":"/%E5%86%85%E7%BD%91%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8docker%E9%95%9C%E5%83%8F/:0:1","tags":["Docker"],"title":"内网环境中使用Docker镜像","uri":"/%E5%86%85%E7%BD%91%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BD%BF%E7%94%A8docker%E9%95%9C%E5%83%8F/"},{"categories":["编程"],"content":"文章背景 Python 环境安装 package，一般采用 pip 命令在线从 PyPI 是安装，这也是最方便的途径。但在某些情况下，要为一台离线的机器（比如在内网运行的一台生产服务器）安装 package，根本就连不上 PyPI。当然，大厂一般都有内网 PyPI 代理，只要改一下 --index-url 参数即可；但若代理也没有，只能手工将所有依赖到的 package 离线下载下来，放到离线的机器上安装。 下面是说明了整个探索过程。最终总结的方法，直接看文末的 “推荐方法” 即可。 ","date":"2022-03-02","objectID":"/python-pip-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85-package-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%BB%A5-tensorflow-%E4%B8%BA%E4%BE%8B/:1:0","tags":["Python","pip","编程"],"title":"Python pip 离线安装 package 方法总结（以 TensorFlow 为例）","uri":"/python-pip-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85-package-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%BB%A5-tensorflow-%E4%B8%BA%E4%BE%8B/"},{"categories":["编程"],"content":"心路历程 ","date":"2022-03-02","objectID":"/python-pip-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85-package-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%BB%A5-tensorflow-%E4%B8%BA%E4%BE%8B/:2:0","tags":["Python","pip","编程"],"title":"Python pip 离线安装 package 方法总结（以 TensorFlow 为例）","uri":"/python-pip-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85-package-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%BB%A5-tensorflow-%E4%B8%BA%E4%BE%8B/"},{"categories":["编程"],"content":"手工下载 之前我只是傻了吧唧，将要安装的 package（比如 tensorflow）从 PyPI 网站手工下载下来，放到内网机器直接安装，当然立马就会报 xxx 依赖不存在导致安装失败；根据报错提示再到 PyPI 上再下载这个 xxx 的 package 安装。而这个 xxx 可能又依赖另外一个 yyy。如此反复，整个过程有 30 个左右的多层依赖，搞了一下午，痛苦不堪。 ","date":"2022-03-02","objectID":"/python-pip-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85-package-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%BB%A5-tensorflow-%E4%B8%BA%E4%BE%8B/:2:1","tags":["Python","pip","编程"],"title":"Python pip 离线安装 package 方法总结（以 TensorFlow 为例）","uri":"/python-pip-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85-package-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%BB%A5-tensorflow-%E4%B8%BA%E4%BE%8B/"},{"categories":["编程"],"content":"读取 requirement 后来，我发现这些 package 里面都有 requirements 的声明文件，于是我就先解压出来看 requirement，这样至少直接依赖的 package 一下子都知道了。总比根据报错再一个一个下载快了。 但这还是不行，诉诸网络，发现了 pip download 可以解决这个问题，不过实际操作中还是有不少问题，下面以 TensorFlow 的离线安装为例说明。 ","date":"2022-03-02","objectID":"/python-pip-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85-package-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%BB%A5-tensorflow-%E4%B8%BA%E4%BE%8B/:2:2","tags":["Python","pip","编程"],"title":"Python pip 离线安装 package 方法总结（以 TensorFlow 为例）","uri":"/python-pip-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85-package-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%BB%A5-tensorflow-%E4%B8%BA%E4%BE%8B/"},{"categories":["编程"],"content":"pip download 总的思路是: 在 online 机器，通过 pip download tensorflow 命令（与 pip install 的区别就是，前者只下载不安装），将要安装的 xxx_package 以及所有依赖都下载到本地 然后拷贝到目标 offline 机器的某个目录（比如 /offline_package_dir），并通过如下命令安装： pip install --no-index --find-links=file:/offline_package_dir tensorflow 看起来很美好，但如果两台机器架构不一样，则十分痛苦。 根据 online 和 offline 机器的架构是否相同（即 OS 是否一样，Python 版本是否一样），分别如下： online 和 offline 机器架构完全相同 这种情况比较简单： 直接在 online 机器执行如下命令，下载所有依赖 package 到当前目录： pip download tensorflow 将目录内容拷贝到目标 offline 机器（比如 /offline_package_dir），并目标 offline 机器执行 pip install --no-index --find-links=file:/offline_package_dir tensorflow 由于两个机器架构完全一样，因此 download 的 package 在目标机器一定可以安装。 online 和 offline 机器架构不同 这种情况比较复杂，因为机器架构不同，直接用 pip download tensorflow 下载的 package 在目标机器很可能不适用。 以 TensorFlow 为例，PyPI 上看到的 wheel 文件，至少根据 OS、Python 版本以及 CPU 架构做了区分： PyPI 上 package 有好几种格式： 源文件（一般是.tar.gz 或.zip 文件，用 pip 安装，与机器架构无关，但某些 package 可能涉及到 C/C++ 编译） wheel 文件（二进制文件，拓展名为.whl，用 pip 安装，无需编译，但与机器架构相关） .egg 文件（二进制文件，用 easy_install 安装，无需编译，但与机器架构相关） 不幸的是 PiPY 并没有规定一个 package 必须提供的安装格式，有的只有 wheel 没有源文件，有的只有源文件没有 wheel 或 egg。 这也是导致下文 pip download 失败的原因。 首先，根据 pip 官方 Reference Guide，可以在执行 download 命令时，添加参数，指明要下载 package 对应的架构： pip download with the --platform, --python-version, --implementation, and --abi options provides the ability to fetch dependencies for an interpreter and system other than the ones that pip is running on.--only-binary=:all:or --no-deps is required when using any of these options. It is important to note that these options all default to the current system/interpreter, and not to the most restrictive constraints (e.g. platform any, abi none, etc). To avoid fetching dependencies that happen to match the constraint of the current interpreter (but not your target one), it is recommended to specify all of these options if you are specifying one of them. Generic dependencies (e.g. universal wheels, or dependencies with no platform, abi, or implementation constraints) will still match an over- constrained download requirement. 看起来，只要指定 --platform, --python-version, --implementation, and --abi 即可，比如我在 macOS 上，为 offline 的 suse linux 下载 TensorFlow，目标机器安装了 Python 2.7， 64 位机器，则这样： pip download \\ --only-binary=:all: \\ # 只下载二进制package（即wheel或egg） --platform linux_x86_64 \\ # 说明是linux 64位架构 --python-version 27 \\ # Python 2.7 --implementation cp \\ # cpython，一般都是这个 --abi cp27mu tensorflow # 要下载的package名 这些参数含义和可能的值，可参考：PEP 425 – Compatibility Tags for Built Distributions 刚开始都正常，但下载到一半的时候就报错： Could not find a version that satisfies the requirement absl-py\u003e=0.1.6 (from tensorflow) (from versions: ) No matching distribution found for absl-py\u003e=0.1.6 (from tensorflow) 这是因为参数 --only-binary=:all: 只下载二进制版，而 tensorflow 依赖的 absl-py 在 PyPI 中只有.tar.gz 的源码版，没有二进制版。 那能不能不限制 --only-binary=:all:？不行，一旦指定具体的架构，就必须设置 --only-binary=:all:，或者不下载依赖，这是 pip install 用法的规定，可参考官方 Reference： https://pip.pypa.io/en/stable/reference/pip_download/ –only-binary=:all:or –no-deps is required when using any of these options. 这真蛋疼！ 那就干脆不下载二进制 package，用 pip download --only-binary=:none: tensorflow，但坑爹是 tensorflow 只提供二进制包，或者说就算 tensorflow 提供了源码版 package，你也无法保证所有依赖的包都有源码版。所以这条路也行不通，进入了一个死胡同。 这个时候，怎么办呢？那手工将这个包下载下来吧： pip download --no-deps \"absl-py\u003e=0.1.6\" 这里要注意，加上–no-deps，即不下载 absl-py 的依赖。因为即便你下载的依赖也可能是不符合目标架构的。 问题是，重新执行 tensorflow 的下载，还是阻塞在 absl-py 上。所以后面没有下载的 package 都要回退到手工模式。 归根结底，是 pip install 命令，一旦指定了平台相关的参数，就只能下载二进制 package，我很奇怪为什么不能同时下载源代码，至少 install 命令，都是优先选择二进制，没有二进制的时候也能用源代码版。 网上很多办法是，使用 virtualenv 做一个干净的 Python 环境，然后 install 再用 pip freeze \u003e require.txt 导出 requirement 依赖清单，然后再用 pip download -r require.txt 下载。但这个方法还是逃脱不了目标平台架构不一样的问题。 到这个地步，若不想手工做，只有一条路：保证 online 和 offline 机器架构一样。 所谓架构一样，其实就是四个参数一样：--platform, --python-version, --implementation, and --abi platform 即操作系统，这个可以通过虚拟机或 docker 解决 python-version，可以通过 pipenv 解决 implementation，目前一般只考虑 cpython abi，通过虚拟机或 docker 吧 ","date":"2022-03-02","objectID":"/python-pip-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85-package-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%BB%A5-tensorflow-%E4%B8%BA%E4%BE%8B/:2:3","tags":["Python","pip","编程"],"title":"Python pip 离线安装 package 方法总结（以 TensorFlow 为例）","uri":"/python-pip-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85-package-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%BB%A5-tensorflow-%E4%B8%BA%E4%BE%8B/"},{"categories":["编程"],"content":"推荐方法：pyenv+docker 经过上面的分析总结，首先需要让 online 和 offline 机器架构一样。 ","date":"2022-03-02","objectID":"/python-pip-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85-package-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%BB%A5-tensorflow-%E4%B8%BA%E4%BE%8B/:3:0","tags":["Python","pip","编程"],"title":"Python pip 离线安装 package 方法总结（以 TensorFlow 为例）","uri":"/python-pip-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85-package-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%BB%A5-tensorflow-%E4%B8%BA%E4%BE%8B/"},{"categories":["编程"],"content":"1. 如果 online 和 offline 的机器架构完全一样 OS 一样、Python 版本一样，非常简单： 先在 online 机器执行 download，下载所有依赖 package 到当前目录：pip download tensorflow 将目录内容拷贝到目标 offline 机器（比如 /offline_package_dir），并目标 offline 机器执行pip install --no-index --find-links=file:目录路径 tensorflow 如果 online 和 offline 架构不一样 可以先尝试用 download 指定参数试一下是否能成功下载，如果不能再考虑下面的做法。 具体分为两种情况： 仅 Python 版本不一样 通过 pyenv 安装指定版本的 python 2.7.13 curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash pyenv install 2.7.13 切换 Python 版本 pyenv global 2.7.13 接下来同第 1 中情况的步骤 OS 不一样 使用 docker 创建一个和目标机器架构相同的容器，在容器内安装和目标机器一样的 Python 版本，然后在容器内按第 1 种情况处理。 以我的例子: 1. 先启动目标系统的 docker 镜像（这里以 Ubuntu 为例），并映射 package 下载目录 `docker run -it -v /offline_tensorflow_py3:/package ubuntu /bin/bash` 2. 在容器内安装 python `apt-get update \u0026\u0026 apt-get install python python-pip` 3. 接下来同 2.1 步骤一样 ","date":"2022-03-02","objectID":"/python-pip-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85-package-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%BB%A5-tensorflow-%E4%B8%BA%E4%BE%8B/:3:1","tags":["Python","pip","编程"],"title":"Python pip 离线安装 package 方法总结（以 TensorFlow 为例）","uri":"/python-pip-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85-package-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%E4%BB%A5-tensorflow-%E4%B8%BA%E4%BE%8B/"},{"categories":null,"content":"●Preface 服务器很多时候都是部署在 Linux 远程机器上的，我们通常是 SSH 连过去然后用 vim 或者 emacs 去修改源文件。 这种方式对我来说很麻烦，因为我已经习惯了全宇宙最好用的 C++IDE Visual Studio，离开 IDE 写代码实在太痛苦了。 所以我只能借助 samba+sourceinsight 的组合来勉强度日。这个组合其实是比较好的，只不过配置特别麻烦，实在是不想折腾。 这时，微软开发了一个 VSCode 的插件 Remote-SSH，可以说是目前比较完美的解决了在 windows 下开发 linux 程序的问题。 Remote-SSH 配置简单，界面可视化，你可以把他看做是带 IDE 的 Putty。当然你也可以只把他当做一个远程 ssh 的连接工具来代替 putty，xshell。 ","date":"2022-03-02","objectID":"/vscode%E6%8F%92%E4%BB%B6remote-ssh%E9%85%8D%E7%BD%AE/:1:0","tags":["VSCODE"],"title":"VSCODE插件Remote-SSH配置","uri":"/vscode%E6%8F%92%E4%BB%B6remote-ssh%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"●安装 Remote-SSH （1）VSCode 左侧边栏上找到 Extensions 按钮，点击打开扩展插件面板。 （2）在扩展搜索栏中搜索到 Remote-SSH 这个插件，然后点击下载安装这个插件。 （3）此插件安装完毕后，侧边栏会出现一个名为 Remote-SSH 新的图标按钮。 （4）点击 VSCode 左侧边栏上的 Remote-SSH 图标按钮，打开 Remote-SSH 面板。 （5）在 CONNECTIONS 条目右边找到配置按钮图标 [Configure]，点击配置。 （6）此时会弹出一个下拉框，选择 config 配置文件保存路径，比如 C:\\Users\\Administrator\\.ssh\\config （7）点击编辑这个 config 文件，编辑代码如下示例： Host njdaby #远程主机 1 别名 alias，注意主机别名不能包含 @符，否则会连接失败 HostName 117.78.41.7 User root IdentityFile C:\\Users\\Administrator\\.ssh\\id_rsa #IdentityFile 指定秘钥名称路径 ，缺省路径为 `%HOME%\\.ssh\\id_rsa`，其中 %HOME%为用户目录 （8）保存配置文件后，上面保存的远程主机别名就出现在 ‘CONNECTIONS’ 条目的下拉列表中。 （9）在 ‘CONNECTIONS’ 下拉列表中点击需要连接的主机别名，开始连接远程主机。 如果希望连接时，不要输入密码，那么还需要在本地创建密钥，并把公钥复制到远程服务器上。 ","date":"2022-03-02","objectID":"/vscode%E6%8F%92%E4%BB%B6remote-ssh%E9%85%8D%E7%BD%AE/:2:0","tags":["VSCODE"],"title":"VSCODE插件Remote-SSH配置","uri":"/vscode%E6%8F%92%E4%BB%B6remote-ssh%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"●注意事项 ①使用秘钥连接 ssh 时，如果不指定秘钥路径，默认秘钥路径为 ‘% HOME%.ssh\\id_rsa’，如果连接失败，就要检查确认该路径是否正确。 ②vscode 的配置文件 config 中，注意主机别名不能包含 @符，否则会连接失败。 ","date":"2022-03-02","objectID":"/vscode%E6%8F%92%E4%BB%B6remote-ssh%E9%85%8D%E7%BD%AE/:3:0","tags":["VSCODE"],"title":"VSCODE插件Remote-SSH配置","uri":"/vscode%E6%8F%92%E4%BB%B6remote-ssh%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":" https://juejin.cn/post/7015603661225066532 ","date":"2022-02-16","objectID":"/python%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/:0:0","tags":["编程","Python"],"title":"Python执行JS的几种方式","uri":"/python%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["编程"],"content":"1.PyExecJS 经测试，比js2py快5倍多 安装依赖 pip3 install PyExecJS 使用方式 add.js 文件 function add(a,b){ return a+b; } 复制代码 py 文件去调用 import execjs with open('add.js', 'r', encoding='UTF-8') as f: js_code = f.read() context = execjs.compile(js_code) result = context.call(\"add\", 2, 3) // 参数一为函数名，参数二和三为函数的参数 print(result) 复制代码 运行 ","date":"2022-02-16","objectID":"/python%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/:0:1","tags":["编程","Python"],"title":"Python执行JS的几种方式","uri":"/python%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["编程"],"content":"2.js2py 安装依赖库 pip3 install js2py 还是上面的 add.js 文件 python 调用 import js2py with open('add.js', 'r', encoding='UTF-8') as f: js_code = f.read() context = js2py.EvalJs() context.execute(js_code) result = context.add(\"1\", \"2\") print(result) 复制代码 ","date":"2022-02-16","objectID":"/python%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/:0:2","tags":["编程","Python"],"title":"Python执行JS的几种方式","uri":"/python%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["编程"],"content":"3.Node.js 实际上是使用 Python 的 os.popen 执行 node 命令，执行 JS 脚本 首先，确保本地已经安装了 Node.js 环境 对 js 代码添加打印 function add(a,b){ return Number(a)+Number(b); } console.log(add(process.argv[2], process.argv[3])); // 运行脚本传进来的参数 复制代码 用 python 调用控制台方式去使用 import os nodejs = os.popen('node add.js '+'2'+' '+'3') m = nodejs.read() nodejs.close() print(m) 复制代码 或者使用另一种方式 function add(a,b){ return Number(a)+Number(b); } // console.log(add(process.argv[2], process.argv[3])); //新增一个导出函数（node方式） module.exports.init = function (arg1, arg2) { //调用函数，并返回 console.log(add(arg1, arg2)); }; 复制代码 import os cmd = 'node -e \"require(\\\"%s\\\").init(%s,%s)\"' % ('./add.js', 2, 3) pipeline = os.popen(cmd) result = pipeline.read() print(result) 复制代码 ","date":"2022-02-16","objectID":"/python%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/:0:3","tags":["编程","Python"],"title":"Python执行JS的几种方式","uri":"/python%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["编程"],"content":"4.node 服务 用 node 做一个服务，提供 api 还是 add.js 文件 function add(a,b){ return Number(a)+Number(b); } module.exports = { add: function (arg1, arg2) { return add(arg1, arg2); } }; 复制代码 新建 add_api.js 下载 express 和 body-parser 两个包 var express = require('express') var app = express() var func = require('./add.js') // 导入js模块，并命名为func var bodyParser = require('body-parser'); // 导入请求体解析器 // 调整参数大小限制，否则会提示参数过大。 app.use(bodyParser.urlencoded({limit: '50mb', extended: true})); // 设置路由 app.post('/add', function(req, res) { // 获取请求的真实IP var ip = req.headers['x-real-ip'] ? req.headers['x-real-ip'] : req.ip.replace(/::ffff:/, ''); // 获取请求时间 var time = new Date().toString().replace(/+0800.*/, ''); // 打印请求时间、IP、方法、路由 console.log('INFO:', time, ip, req.method, req.originalUrl, '200 OK!'); // 获取POST请求的formdata let result = req.body; // let code = result.code; // let seed = result.seed; // let ts = result.ts; console.log(\"result: \", result); console.log(\"num1: \", result.num1); console.log(\"num2: \", result.num2); // 调用cook模块中的get_cookie方法，该方法需要提前module.exports导出 var response = func.add(result.num1, result.num2); // 设置响应头，如果不设置，通过asyncio_requests请求的res.json()会报错，因为它是根据响应头解析json数据 // 而requests可以直接使用res.json()解析，因为它是根据响应信息解析 res.set('Content-Type', 'application/json') // 将JSON后的数据返回客户端 res.send(JSON.stringify({\"result\": response})); }); app.listen(8919, () =\u003e { console.log(\"开启服务，端口8919\", new Date().toString().replace(/+0800.*/, '')) }) 复制代码 运行，用 python 写个 post 请求 import requests response = requests.post(\"http://127.0.0.1:8919/add\", data={\"num1\": 2, \"num2\": 3}) print(response.text) 复制代码 ","date":"2022-02-16","objectID":"/python%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/:0:4","tags":["编程","Python"],"title":"Python执行JS的几种方式","uri":"/python%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["编程"],"content":"5.实测代码 import execjs,time,js2py sstr = \"76483603481904696764816450136512980\" with open('md5js.js','r') as f:# js脚本下载地址：http://sydwperson.hnsydwpx.cn/template/pc/ckplayer/md5.js js_code = f.read() start = time.time() js=execjs.compile(js_code) result=js.call('md5',sstr) print(result) print(time.time()- start,end = '\\n\\n') # c6652bbf3b665178f231fee20bfb7b99 # 0.023935794830322266 start = time.time() context = js2py.EvalJs() context.execute(js_code) result = context.md5(sstr) print(result) print(time.time()- start) # c6652bbf3b665178f231fee20bfb7b99 # 0.11571598052978516 ","date":"2022-02-16","objectID":"/python%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/:0:5","tags":["编程","Python"],"title":"Python执行JS的几种方式","uri":"/python%E6%89%A7%E8%A1%8Cjs%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["WSA"],"content":"设置代理 \u003c!-- 使用 adb shell 设置 --\u003e \u003c!-- 打开windows terminal --\u003e adb connect WSA的IP和端口 \u003c!-- 设置代理 --\u003e adb shell settings put global http_proxy ip:端口 \u003c!-- 关闭代理(无需重启) --\u003e adb shell settings put global http_proxy :0 ","date":"2022-01-21","objectID":"/wsa%E5%AE%89%E5%8D%93%E5%AD%90%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/:1:0","tags":["WSA"],"title":"(WSA)安卓子系统折腾笔记","uri":"/wsa%E5%AE%89%E5%8D%93%E5%AD%90%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"背景 用Github Actions build 带谷歌框架和root权限的安卓子系统，结果build出来的artifacts有将近4个G，挂代理（US和HK切换都一样）下载只有500K / S的速度，平时release可以跑满10M/S代理速度。 ","date":"2022-01-20","objectID":"/github-actions-artifactsgithub%E5%B7%A5%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F%E6%80%9D%E8%B7%AF/:1:0","tags":["Github"],"title":"Github Actions Artifacts（Github工件）下载加速思路","uri":"/github-actions-artifactsgithub%E5%B7%A5%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F%E6%80%9D%E8%B7%AF/"},{"categories":null,"content":"解决思路 不管是什么原因，思路是先利用国外VPS下载好再从VPS下回来，经过实验，这回可以跑满10M了。 ","date":"2022-01-20","objectID":"/github-actions-artifactsgithub%E5%B7%A5%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F%E6%80%9D%E8%B7%AF/:2:0","tags":["Github"],"title":"Github Actions Artifacts（Github工件）下载加速思路","uri":"/github-actions-artifactsgithub%E5%B7%A5%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F%E6%80%9D%E8%B7%AF/"},{"categories":null,"content":"要解决的问题 wget不能直接下载，原因也不多说，估计是headers或者账号验证之类的。 通过搜索：首先登录网站https://nightly.link，对相应仓库进行授权…. 然后将欲下载工件地址填入，比如： https://github.com/LSPosed/MagiskOnWSA/suites/4908840299/artifacts/141256770 这个网站会自动将链接转换成如下： https://nightly.link/LSPosed/MagiskOnWSA/suites/4998111090/artifacts/146483433 这个转换出来的URL就可以直接在VPS上wget进行下载： wget https://nightly.link/LSPosed/MagiskOnWSA/suites/4998111090/artifacts/146483433 ","date":"2022-01-20","objectID":"/github-actions-artifactsgithub%E5%B7%A5%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F%E6%80%9D%E8%B7%AF/:3:0","tags":["Github"],"title":"Github Actions Artifacts（Github工件）下载加速思路","uri":"/github-actions-artifactsgithub%E5%B7%A5%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F%E6%80%9D%E8%B7%AF/"},{"categories":["编程"],"content":"GO语言教程 - 菜鸟教程 中国最可靠的 Go 模块代理 《365 天深入理解 Go 语言》 《Golang 学习资源大全》 ","date":"2022-01-13","objectID":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/:0:0","tags":["Go","编程"],"title":"GO语言学习历程","uri":"/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/"},{"categories":null,"content":"背景 最近将一台华为系退役手机（荣耀V8标准版）root（通过万能的淘宝），root完毕后，店家嘱咐不能进行系统更新，否则root将消失。下面是操作方法，在华为荣耀V8（已root）和MATE 30（未root）上测试均可行，说明其负责系统更新的软件包名相同。 ","date":"2021-12-20","objectID":"/%E7%A6%81%E7%94%A8%E5%8D%8E%E4%B8%BA%E7%B3%BB%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0/:1:0","tags":null,"title":"禁用华为系手机系统更新","uri":"/%E7%A6%81%E7%94%A8%E5%8D%8E%E4%B8%BA%E7%B3%BB%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0/"},{"categories":null,"content":"禁用系统更新 手机开启开发者模式，并连接电脑。 通过adb命令，将负责系统更新的软件禁用。 adb shell pm disable-user com.huawei.android.hwouc pause ","date":"2021-12-20","objectID":"/%E7%A6%81%E7%94%A8%E5%8D%8E%E4%B8%BA%E7%B3%BB%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0/:2:0","tags":null,"title":"禁用华为系手机系统更新","uri":"/%E7%A6%81%E7%94%A8%E5%8D%8E%E4%B8%BA%E7%B3%BB%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0/"},{"categories":null,"content":"重开系统更新 adb shell pm enable com.huawei.android.hwouc pause ","date":"2021-12-20","objectID":"/%E7%A6%81%E7%94%A8%E5%8D%8E%E4%B8%BA%E7%B3%BB%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0/:3:0","tags":null,"title":"禁用华为系手机系统更新","uri":"/%E7%A6%81%E7%94%A8%E5%8D%8E%E4%B8%BA%E7%B3%BB%E6%89%8B%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0/"},{"categories":null,"content":"0x1 F12 寻找关键点 在播放视频视频的过程过，按 F12 查看网络发送的请求，立刻发现了一个关键的地址 直接浏览器中打开这个地址会下载一个.ev1 的文件，没见过这中文件格式的小刘同学，决定百度搜索一下这是个啥格式： EV1 文件是一种加密文件。下载文件查看器查看文件。 既然需要解密播放工具，那就先在论坛搜搜看。于是机智的刘同学发现了论坛上有这样一个有用的帖子：ev1 百家云视频解密工具、ev1 视频提取工具，支持 Windows、MacOS、Linux 通过使用该工具解密，转为 flv 格式，最终视频成功播放。 这样的话所有的视频只要在播放的时候获取到这个链接复制到浏览器下载最后提取就可以了。 ","date":"2021-12-06","objectID":"/%E6%9F%90%E6%88%90%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%BD%BD%E5%A4%87%E4%BB%BD/:1:0","tags":null,"title":"某成在线获取真实视频地址【转载备份】","uri":"/%E6%9F%90%E6%88%90%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%BD%BD%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"0x2 通过 API 获取视频地址 请求URL：https://www.xxxjiayun.com/vod/video/getAllFormatPlayUrl 请求方法：GET 参数： vid: 73323428 // 这里的vid其实是视频的url属性 sid: render: jsonp client_type: flash ver: 2 token: xxxxxxxx-xxxxxx-xxxxxx// 修饰后 播放器token callback: jQueryxxxxxxxxxxxx_162xxxxx// 修饰后 感觉这个参数没啥用 _: 16270000005// 修饰后 时间戳 返回的数据 (非完整)： jQuery193_1164({ \"code\": 0, \"data\": { \"duration\": \"2055\", \"format\": null, \"definition\": [{ \"type\": \"superHD\", \"name\": \"超清\" }], \"vod_default_definition\": \"superHD\", \"playback_default_definition\": \"superHD\", \"all_format_play_info\": { \"ev1\": { \"superHD\": { \"definition\": \"超清\", \"size\": 70459130, \"cdn_list\": [{ \"cdn\": \"hw4jd\", \"definition\": \"high\", \"duration\": 2055, \"height\": 540, \"oversea\": 0, \"size\": 70459130, \"url\": \"\", \"width\": 960, \"weight\": 9, \"enc_url\": \"bjcloudvod://xxx-xxx\" }, { \"cdn\": \"jd4jd\", \"definition\": \"high\", \"duration\": 2055, \"height\": 540, \"oversea\": 0, \"size\": 70459130, \"url\": \"\", \"width\": 960, \"weight\": 7, \"enc_url\": \"bjcloudvod://xxx-xxx\" }, { \"cdn\": \"al4jd\", \"definition\": \"high\", \"duration\": 2055, \"height\": 540, \"oversea\": 0, \"size\": 70459130, \"url\": \"\", \"width\": 960, \"weight\": 6, \"enc_url\": \"bjcloudvod://xxx-xxx\" }] } }, \"mp4\": { \"superHD\": { \"definition\": \"超清\", \"size\": 68700179, \"cdn_list\": [{ \"cdn\": \"hw4jd\", \"definition\": \"high\", \"duration\": 2055, \"height\": 540, \"oversea\": 0, \"size\": 68700179, \"url\": \"\", \"width\": 960, \"weight\": 9, \"enc_url\": \"bjcloudvod://xxx-xxx\" } }) 观察这个返回的数据我们发现了关键的内容 超清， ev1，mp4 ，里面的 enc_url 又是个加密的内容。凭借多年 ** 的经验，机智的小刘认为这个又是 MP4 又是超清的，加密内容绝对不简单，于是小刘决定尝试解密这个 bjcloudvod 链接。 在 F12 中搜索 bjcloudvod, 找到了解码的关键代码： 这里懒惰的小刘同学决定通过 python 执行这段 js 代码。将代码转换一下写法： import execjs js_code = execjs.compile(\"\"\" function decodeUrl(url) { var prefix = 'bjcloudvod://'; if ('' == url || url.indexOf(prefix) !== 0) { return; } url = url.slice(prefix.length, url.length).replace(/-/g, '+').replace(/_/g, '/'); var pad = url.length % 4; if (pad == 2) { url += '=='; } else if (pad == 3) { url += '='; } url = _decode(url); var factor = url.charCodeAt(0); var c = factor % 8; url = url.slice(1, url.length); var result = []; for (var i = 0, char; char = url[i]; i++) { var step = i % 4 * c + i % 3 + 1; result.push(String.fromCharCode(char.charCodeAt(0) - step)); } return result.join(''); } var _PADCHAR = '=', _ALPHA = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', _VERSION = '1.0'; function _getbyte64(s, i) { var idx = _ALPHA.indexOf(s.charAt(i)); if (idx === -1) { throw 'Cannot decode base64'; } return idx; } function _decode(s) { var pads = 0, i, b10, imax = s.length, x = []; s = String(s); if (imax === 0) { return s; } if (imax % 4 !== 0) { throw 'Cannot decode base64'; } if (s.charAt(imax - 1) === _PADCHAR) { pads = 1; if (s.charAt(imax - 2) === _PADCHAR) { pads = 2; } imax -= 4; } for (i = 0; i \u003c imax; i += 4) { b10 = _getbyte64(s, i) \u003c\u003c 18 | _getbyte64(s, i + 1) \u003c\u003c 12 | _getbyte64(s, i + 2) \u003c\u003c 6 | _getbyte64(s, i + 3); x.push(String.fromCharCode(b10 \u003e\u003e 16, b10 \u003e\u003e 8 \u0026 255, b10 \u0026 255)); } switch (pads) { case 1: b10 = _getbyte64(s, i) \u003c\u003c 18 | _getbyte64(s, i + 1) \u003c\u003c 12 | _getbyte64(s, i + 2) \u003c\u003c 6; x.push(String.fromCharCode(b10 \u003e\u003e 16, b10 \u003e\u003e 8 \u0026 255)); break; case 2: b10 = _getbyte64(s, i) \u003c\u003c 18 | _getbyte64(s, i + 1) \u003c\u003c 12; x.push(String.fromCharCode(b10 \u003e\u003e 16)); break; } return x.join(''); } \"\"\") 尝试用上面的加密内容测试这个解密方法： encodeStr = \"bjcloudvod://xxx-xxxx\" print(js_code.call(\"decodeUrl\", encodeStr)) # 输出： https://dal4jd-video.baijiayun.com/8xxxxd4ca0/60x756/00-x-upload/video/xxxxxx.mp4 居然直接获取到了视频的 MP4 地址！ 机智的小刘可高兴坏了，这样的话通过 getAllFormatPlayUrl 获取视频直连，再用 urllib3 下载到本地就 OK 了。接下来就是构建 getAllFormatPlayUrlAPI 需要的参数就可以批量下载视频了～ ","date":"2021-12-06","objectID":"/%E6%9F%90%E6%88%90%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%BD%BD%E5%A4%87%E4%BB%BD/:2:0","tags":null,"title":"某成在线获取真实视频地址【转载备份】","uri":"/%E6%9F%90%E6%88%90%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%BD%BD%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"0x3 深入探究 getAllFormatPlayUrl 机智的小刘同学认为：能用 F12 解决的问题就坚决不用别的。 再次分析需要传递的参数： vid: 73323428 // 这里的vid其实是视频的url属性 sid: render: jsonp client_type: flash ver: 2 token: xxxxxxxx-xxxxxx-xxxxxx// 修饰后 播放器token callback: jQueryxxxxxxxxxxxx_162xxxxx// 修饰后 感觉这个参数没啥用 _: 16270000005// 修饰后 时间戳 关键的参数就只有两个 vid 和 token，“__” 值为时间戳，可以在发送请求时候再自动生成。 ","date":"2021-12-06","objectID":"/%E6%9F%90%E6%88%90%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%BD%BD%E5%A4%87%E4%BB%BD/:3:0","tags":null,"title":"某成在线获取真实视频地址【转载备份】","uri":"/%E6%9F%90%E6%88%90%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%BD%BD%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"0x3.1 获取 token 通过搜索 token 的值，机智的小刘同学又发现了一个 API： 请求 URL:https://www.xxxxxgkt.com:xxxx/web/bjvod/videoPlayerToken 请求方法: POST 请求参数：{t: 1600000000633, // 时间戳 courseId: “15726cccc6_cxxxxx3-cxxx-xxxx-xxxx-xxxxxxxx”, // 课程 idexpires_in: 0,video_id: “2738000” // 视频 url 参数} 返回： {\"code\":0,\"msg\":\"\",\"ts\":1600000004,\"data\":{\"token\":\"xxxxxxxxxx-xxxxxxxxxxxx-xxxxx\"}} 这里说明一下，这个方法和我当时用的 API 不一样，我用的是 videoPlayerToken 这个 API，但是都可以获取到 token。后续 python 方法我还是使用的 videoPlayerToken。videoPlayerToken 需要购买课程才能调用。 直接通过视频 ID 和时间戳就能获取到 token！机智的小刘同学觉得成功就在咫尺！ ","date":"2021-12-06","objectID":"/%E6%9F%90%E6%88%90%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%BD%BD%E5%A4%87%E4%BB%BD/:3:1","tags":null,"title":"某成在线获取真实视频地址【转载备份】","uri":"/%E6%9F%90%E6%88%90%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%BD%BD%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"0x3.2 构建时间戳 经过简单的百度搜索，小刘同学获取到了 API 中时间戳的构建方法： str(int(round(time.time() * 1000))) ","date":"2021-12-06","objectID":"/%E6%9F%90%E6%88%90%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%BD%BD%E5%A4%87%E4%BB%BD/:3:2","tags":null,"title":"某成在线获取真实视频地址【转载备份】","uri":"/%E6%9F%90%E6%88%90%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%BD%BD%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"0x3.3 用 python 实现 getAllFormatPlayUrl 和 playerToken 自学了一段 python 时间的小刘同学，决定用 python 的 requests 库实现这两个方法。 # 已购买课程可以使用videoPlayerToken，但是我测试时候只能 def videoPlayerToken(courseId, video_id): url = \"https://www.xxxxxx.com:xxxx/web/bjvod/videoPlayerToken\" headers = { 'accept': 'application/json, text/plain, */*', 'accept-encoding': 'gzip, deflate, br', 'accept-language': 'zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6', 'area': '0100000200', 'companynum': '01000002', 'content-length': '120', 'content-type': 'application/json; charset=UTF-8', 'origin': 'https://www.xxxx.cn', 'referer': 'https://www.xxxx.cn/', 'sec-ch-ua': '\" Not;A Brand\";v=\"99\", \"Microsoft Edge\";v=\"91\", \"Chromium\";v=\"91\"', 'sec-ch-ua-mobile': '?0', 'sec-fetch-dest': 'empty', 'sec-fetch-mode': 'cors', 'sec-fetch-site': 'cross-site', 'token': 'xxxxxxxxxxxxxxxxxxxxxxUo2g' } parameter = { \"courseId\": courseId, # 课程ID \"expires_in\": 0, \"t\": str(int(round(time.time() * 1000))), \"video_id\": video_id # 课程url(其实就是视频id号) } r = requests.post(url=url, headers=headers, data=json.dumps(parameter, ensure_ascii=False).encode('utf-8')) json_str = json.loads(r.text) if \"data\" in json_str: return json_str['data']['token'] def getAllFormatPlayUrl(vid, tk): url = \"https://www.xxjiayun.com/vod/video/getAllFormatPlayUrl\" headers = { 'accept': '*/*', 'accept-encoding': 'gzip, deflate, br', 'accept-language': 'zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6', 'referer': 'https://www.sjqhedu.cn/', 'sec-ch-ua': '\" Not;A Brand\";v=\"99\", \"Microsoft Edge\";v=\"91\", \"Chromium\";v=\"91\"', 'sec-ch-ua-mobile': '30', 'sec-fetch-dest': 'script', 'sec-fetch-mode': 'no-cors', 'sec-fetch-site': 'cross-site' } parameter = { \"vid\": vid, # 课程url(其实就是视频id号) \"sid\": \"\", \"render\": \"jsonp\", \"client_type\": \"flash\", \"ver\": 2, \"token\": tk, \"callback\": \"jQuery00000000_10000000009\", \"_\": str(int(round(time.time() * 1000))), } r = requests.get(url=url, headers=headers, params=parameter) dick_str = r.text.replace(\"jQuery00000000_10000000009(\", \"\").replace(\")\", \"\") return json.loads(dick_str) ","date":"2021-12-06","objectID":"/%E6%9F%90%E6%88%90%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%BD%BD%E5%A4%87%E4%BB%BD/:3:3","tags":null,"title":"某成在线获取真实视频地址【转载备份】","uri":"/%E6%9F%90%E6%88%90%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%BD%BD%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"0x4 批量下载 机智的小刘同学认为：如果无法批量实现上面的操作下载视频，那么一切都是白费。 稳妥的小刘同学决定先整理一下现在的思路 获取当前课程全部视频的课程 ID 和 url 通过这两个参数获取 token 通过课程的 url 和 token 获取到加密视频直链 通过解密加密的直链获取到真正的视频直链地址 下载视频 正是因为细心的小刘同学首先发现刚打开课程目录时候，就会返回所有课程的信息，这才有了他批量操作的信心。 刚打开课程首页，通过搜索课程的名称，机智的小刘同学发现了这个关键信息。 懒惰的小刘没有再打算通过 api 获取这个 json 结果，而是直接复制的全部内容保存到了本地 json 文件。通过读取本地的 json 文件加载全部课程。 上面的结果保存到本地后，直接用 python 读取： def getCourseList(): f = open('list1.json', encoding=\"utf8\") t = json.load(f) return t['syllabus'] 到此为止我们就基本完成了全部的关键代码。 让我们最后实现 main 方法吧： http = urllib3.PoolManager() #下载视频使用urllib3库 course_list = getCourseList() # 获取全部课程 # with open(\"test.txt\", \"w\") as f: try: for courses in course_list: # 遍历课程（1级目录） path = courses[\"name\"].strip() if not os.path.isdir(path): os.mkdir(path) # 创建文件夹保存视频 for course in courses[\"list\"]:# 遍历课程（2级目录）/视频 # print(course) if len(course[\"list\"]) == 0: token = videoPlayerToken(courseId=course[\"courseId\"], video_id=course[\"url\"]) # 获取token if token == None: continue json_url = getAllFormatPlayUrl(course[\"url\"], token) # 获取加密的直链 mp4 = json_url[\"data\"][\"all_format_play_info\"][\"mp4\"]# 加密的直链的MP4的内容 if 'superHD' in mp4: d_url = mp4[\"superHD\"][\"cdn_list\"][0][\"enc_url\"] # 获取其中一个加密的地址 r_url = js_code.call(\"decodeUrl\", d_url) # 获取真实直链 f_path = path + \"/\" + course[\"name\"] + \".mp4\" # 下载视频病保存 # wget.download(r_url, path)# 下载 r = http.request('GET', r_url) with open(f_path, 'wb') as f: f.write(r.data) # 下面内容重复就不再有注释了 if 'high' in mp4: d_url = mp4[\"high\"][\"cdn_list\"][0][\"enc_url\"] r_url = js_code.call(\"decodeUrl\", d_url) f_path = path + \"/\" + course[\"name\"] + \".mp4\" # wget.download(r_url, path)# 下载 r = http.request('GET', r_url) with open(f_path, 'wb') as f: f.write(r.data) if '720p' in mp4: d_url = mp4[\"720p\"][\"cdn_list\"][0][\"enc_url\"] r_url = js_code.call(\"decodeUrl\", d_url) f_path = path + \"/\" + course[\"name\"] + \".mp4\" # wget.download(r_url, path)# 下载 r = http.request('GET', r_url) with open(f_path, 'wb') as f: f.write(r.data) else: path = courses[\"name\"].strip() + \"/\" + course[\"name\"].strip() if not os.path.isdir(path): os.mkdir(path) # print(courses[\"name\"].strip()+\"/\"+course[\"name\"].strip()) for c in course[\"list\"]: token = videoPlayerToken(courseId=c[\"courseId\"], video_id=c[\"url\"]) if token == None: continue content = c[\"name\"] + \" \" + c[\"courseId\"] + \" \" + c[\"url\"] + \" \" + token print(content) # worksheet.write(i, 0, label=c[\"name\"]) json_url = getAllFormatPlayUrl(c[\"url\"], token) j = 1 mp4 = json_url[\"data\"][\"all_format_play_info\"][\"mp4\"] print(mp4) if 'superHD' in mp4: d_url = mp4[\"superHD\"][\"cdn_list\"][0][\"enc_url\"] r_url = js_code.call(\"decodeUrl\", d_url) f_path = path + \"/\" + c[\"name\"] + \".mp4\" # wget.download(r_url, path)# 下载 r = http.request('GET', r_url) with open(f_path, 'wb') as f: f.write(r.data) if 'high' in mp4: d_url = mp4[\"high\"][\"cdn_list\"][0][\"enc_url\"] r_url = js_code.call(\"decodeUrl\", d_url) f_path = path + \"/\" + c[\"name\"] + \".mp4\" # wget.download(r_url, path)# 下载 r = http.request('GET', r_url) with open(f_path, 'wb') as f: f.write(r.data) if '720p' in mp4: d_url = mp4[\"720p\"][\"cdn_list\"][0][\"enc_url\"] r_url = js_code.call(\"decodeUrl\", d_url) f_path = path + \"/\" + course[\"name\"] + \".mp4\" # wget.download(r_url, path)# 下载 r = http.request('GET', r_url) with open(f_path, 'wb') as f: f.write(r.data) finally: r.release_conn() 最终，机智的小刘同学下载完成的全部的视频。 ","date":"2021-12-06","objectID":"/%E6%9F%90%E6%88%90%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%BD%BD%E5%A4%87%E4%BB%BD/:4:0","tags":null,"title":"某成在线获取真实视频地址【转载备份】","uri":"/%E6%9F%90%E6%88%90%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%BD%BD%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"0x5 总结 整个过程中最关键的步骤就是获取到视频的加密真实链接的 API。 获取到关键的 API 后，我们需要做的就是凑齐 API 的参数，然后解密。 功夫不负有心人，机智的小刘同学完成了全部的需求。 ","date":"2021-12-06","objectID":"/%E6%9F%90%E6%88%90%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%BD%BD%E5%A4%87%E4%BB%BD/:5:0","tags":null,"title":"某成在线获取真实视频地址【转载备份】","uri":"/%E6%9F%90%E6%88%90%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%BD%BD%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"来源 http://bbss99.xyz/index.php/2021/07/30/某成在线获取真实视频地址/ 另一篇关于在线视频加密的文章：https://blog.csdn.net/PM_605/article/details/80076850?utm_source=blogxgwz0 ","date":"2021-12-06","objectID":"/%E6%9F%90%E6%88%90%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%BD%BD%E5%A4%87%E4%BB%BD/:6:0","tags":null,"title":"某成在线获取真实视频地址【转载备份】","uri":"/%E6%9F%90%E6%88%90%E5%9C%A8%E7%BA%BF%E8%8E%B7%E5%8F%96%E7%9C%9F%E5%AE%9E%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E8%BD%BD%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"https://themes.gohugo.io/themes/blonde/ 卡片式首页，带文章封面，可切换夜间模式 https://themes.gohugo.io/themes/photophobia/ 列表式首页，只有夜间模式 https://themes.gohugo.io/themes/hugo-theme-shell/ shell首页？酷炫 ","date":"2021-12-04","objectID":"/hugo%E4%B8%BB%E9%A2%98%E7%AD%9B%E9%80%89%E8%BF%87%E7%A8%8B/:0:0","tags":null,"title":"Hugo主题筛选过程","uri":"/hugo%E4%B8%BB%E9%A2%98%E7%AD%9B%E9%80%89%E8%BF%87%E7%A8%8B/"},{"categories":null,"content":"来源 https://gist.githubusercontent.com/Integ/bcac5c21de5ea35b63b3db2c725f07ad/raw/a4d5f24f4d0102ce864008a86fdcc6e7888205c0/unwxapkg.py ","date":"2021-12-04","objectID":"/python%E8%A7%A3%E5%8E%8B%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%A4%87%E4%BB%BD/:1:0","tags":null,"title":"Python解压微信小程序代码备份","uri":"/python%E8%A7%A3%E5%8E%8B%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"代码 # coding: utf-8 # py2 origin author lrdcq # usage python3 unwxapkg.py filename __author__ = 'Integ: https://github.com./integ' import sys, os import struct class WxapkgFile(object): nameLen = 0 name = \"\" offset = 0 size = 0 if len(sys.argv) \u003c 2: print('usage: unwxapkg.py filename [output_dir]') exit() with open(sys.argv[1], \"rb\") as f: root = os.path.dirname(os.path.realpath(f.name)) name = os.path.basename(f.name) + '_dir' if len(sys.argv) \u003e 2: name = sys.argv[2] #read header firstMark = struct.unpack('B', f.read(1))[0] print('first header mark = {}'.format(firstMark)) info1 = struct.unpack('\u003eL', f.read(4))[0] print('info1 = {}'.format(info1)) indexInfoLength = struct.unpack('\u003eL', f.read(4))[0] print('indexInfoLength = {}'.format(indexInfoLength)) bodyInfoLength = struct.unpack('\u003eL', f.read(4))[0] print('bodyInfoLength = {}'.format(bodyInfoLength)) lastMark = struct.unpack('B', f.read(1))[0] print('last header mark = {}'.format(lastMark)) if firstMark != 0xBE or lastMark != 0xED: print('its not a wxapkg file!!!!!') f.close() exit() fileCount = struct.unpack('\u003eL', f.read(4))[0] print('fileCount = {}'.format(fileCount)) #read index fileList = [] for i in range(fileCount): data = WxapkgFile() data.nameLen = struct.unpack('\u003eL', f.read(4))[0] data.name = f.read(data.nameLen) data.offset = struct.unpack('\u003eL', f.read(4))[0] data.size = struct.unpack('\u003eL', f.read(4))[0] print('readFile = {} at Offset = {}'.format(str(data.name, encoding = \"utf-8\"), data.offset)) fileList.append(data) #save files for d in fileList: d.name = '/' + name + str(d.name, encoding = \"utf-8\") path = root + os.path.dirname(d.name) if not os.path.exists(path): os.makedirs(path) w = open(root + d.name, 'wb') f.seek(d.offset) w.write(f.read(d.size)) w.close() print('writeFile = {}{}'.format(root, d.name)) f.close() ","date":"2021-12-04","objectID":"/python%E8%A7%A3%E5%8E%8B%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%A4%87%E4%BB%BD/:2:0","tags":null,"title":"Python解压微信小程序代码备份","uri":"/python%E8%A7%A3%E5%8E%8B%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%A4%87%E4%BB%BD/"},{"categories":null,"content":"使用 python wxunpack.py [待解压包] ","date":"2021-12-04","objectID":"/python%E8%A7%A3%E5%8E%8B%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%A4%87%E4%BB%BD/:3:0","tags":null,"title":"Python解压微信小程序代码备份","uri":"/python%E8%A7%A3%E5%8E%8B%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%A4%87%E4%BB%BD/"},{"categories":["Python"],"content":"背景 前段时间在做一个算法测试，需要对源于日志的数据进行分析才能获取到结果；日志文件较大，所以想要获取数据的变化曲线，增量读取是最好的方式。 网上有很多人的技术博客都是写的用for循环readline以及一个计数器去增量读取，假如文件很大，遍历一次太久。而且对于很多大文件的增量读取，如果遍历每一行比对历史记录的输出或者全都加载到内存通过历史记录的索引查找，是非常浪费资源的， 获取文件句柄的基本理论中就包含指针操作。linux的文件描述符的struct里有一个f_pos的这么个属性，里面存着文件当前读取位置，通过这个东东经过vfs的一系列映射就会得到硬盘存储的位置了，所以很直接，很快。 在Python中的读取文件的方法也有类似的属性。 ","date":"2021-12-01","objectID":"/python%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E5%A2%9E%E9%87%8F%E8%AF%BB%E5%8F%96/:1:0","tags":["Python","大文件"],"title":"Python实现对大文件的增量读取","uri":"/python%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E5%A2%9E%E9%87%8F%E8%AF%BB%E5%8F%96/"},{"categories":["Python"],"content":"具体实现 Python中相关方法的核心函数如下： 函数 作用 tell() 返回文件当前位置 seek() 从指定位置开始读取信息 其中seek()有三种模式： f.seek(p,0) 移动当文件第p个字节处，绝对位置 f.seek(p,1) 移动到相对于当前位置之后的p个字节 f.seek(p,2) 移动到相对文章尾之后的p个字节 参考代码： #!/usr/bin/python fd=open(\"test.txt\",'r') #获得一个句柄 for i in xrange(1,3): #读取三行数据 fd.readline() label=fd.tell() #记录读取到的位置 fd.close() #关闭文件 #再次阅读文件 fd=open(\"test.txt\",'r') #获得一个句柄 fd.seek(label,0)# 把文件读取指针移动到之前记录的位置 fd.readline() #接着上次的位置继续向下读取 ","date":"2021-12-01","objectID":"/python%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E5%A2%9E%E9%87%8F%E8%AF%BB%E5%8F%96/:2:0","tags":["Python","大文件"],"title":"Python实现对大文件的增量读取","uri":"/python%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E5%A2%9E%E9%87%8F%E8%AF%BB%E5%8F%96/"},{"categories":["Python"],"content":"拓展 ","date":"2021-12-01","objectID":"/python%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E5%A2%9E%E9%87%8F%E8%AF%BB%E5%8F%96/:3:0","tags":["Python","大文件"],"title":"Python实现对大文件的增量读取","uri":"/python%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E5%A2%9E%E9%87%8F%E8%AF%BB%E5%8F%96/"},{"categories":["Python"],"content":"如何得知这个大文件行数，以及变化 我的想法： 方式1： 遍历\\n字符。 方式2： 开始时就在for循环中对fd.readline()计数，变化的部分（用上文说的seek、tell函数做）再用for循环fd.readline()进行统计。 ","date":"2021-12-01","objectID":"/python%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E5%A2%9E%E9%87%8F%E8%AF%BB%E5%8F%96/:3:1","tags":["Python","大文件"],"title":"Python实现对大文件的增量读取","uri":"/python%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E5%A2%9E%E9%87%8F%E8%AF%BB%E5%8F%96/"},{"categories":["Python"],"content":"如何避免文件读取时，内存溢出 可以通过 read 函数的chunk关键字来指定每次读区数据的大小 使用生成器确保只有在数据被调用时才会生成 具体方法封装如下： def read_in_chunks(file_path, chunk=100 * 100): # 通过chunk指定每次读取文件的大小防止内存占用过大 file_object = open(file_path, \"r\") while True: data = file_object.read(chunk) if not data: file_object.close() break # 使用generator（生成器）使数据只有在被使用时才会迭代时占用内存 yield data ","date":"2021-12-01","objectID":"/python%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E5%A2%9E%E9%87%8F%E8%AF%BB%E5%8F%96/:3:2","tags":["Python","大文件"],"title":"Python实现对大文件的增量读取","uri":"/python%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E5%A2%9E%E9%87%8F%E8%AF%BB%E5%8F%96/"},{"categories":["Python"],"content":"应用 根据博客园一个朋友的实际问题写的一段应用代码，解决程序运行异常、断点再读问题： #! /usr/bin/python # coding:utf-8 \"\"\" @author:Bingo.he @file: 20191129-file.py @time: 2019/11/29 \"\"\" import os import glob class opened(object): def __init__(self, filename): self.filename = filename self.handle = open(filename) if filename in get_read_info().keys(): self.handle.seek(get_read_info()[filename], 0) def __enter__(self): return self.handle def __exit__(self, exc_type, exc_value, exc_trackback): seek_num = self.handle.tell() set_read_info(self.filename, seek_num) self.handle.close() if exc_trackback is None: print(f\"文件【{self.filename}】读取正常退出。\") else: print(f\"文件【{self.filename}】读取退出异常！\") def get_read_info(): \"\"\" 读取已读取的文件的句柄位置 :return: \"\"\" file_info = {} # 如果文件不存在则创建一个空文件 if not os.path.exists(\"temp\"): with open(\"temp\", 'w', encoding=\"utf-8\") as f: pass return file_info with open(\"temp\", 'r', encoding=\"utf-8\") as f: datas = f.readlines() for data in datas: name, line = data.split(\"===\") file_info[name] = int(line) return file_info def set_read_info(filename, seek_num): \"\"\" 设置为已经读取的文件的句柄位置 :param filename: 文件名称 :param seek_num: 句柄位置 :return: \"\"\" flag = True with open(\"temp\", 'r', encoding=\"utf-8\") as f: datas = f.readlines() for num, data in enumerate(datas): if filename in data: flag = False datas[num] = f\"{filename}==={seek_num}\\n\" if flag: datas.append(f\"{filename}==={seek_num}\\n\") # print(datas) with open(\"temp\", 'w', encoding=\"utf-8\") as f: f.writelines(datas) # 测试代码 # 注：文件读完之后，存储在temp文件中的，第二次读取时不会再读，可以以删除temp文件或者修改其中信息 pys = glob.glob(\"*.py\") # 获取当前目录以Py结尾的文件 for py in pys: with opened(py) as fp: # 默认为读模式 for line_data in fp: print(line_data) ","date":"2021-12-01","objectID":"/python%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E5%A2%9E%E9%87%8F%E8%AF%BB%E5%8F%96/:4:0","tags":["Python","大文件"],"title":"Python实现对大文件的增量读取","uri":"/python%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E5%A2%9E%E9%87%8F%E8%AF%BB%E5%8F%96/"},{"categories":["Python"],"content":"来源 https://www.cnblogs.com/Detector/p/8975335.html ","date":"2021-12-01","objectID":"/python%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E5%A2%9E%E9%87%8F%E8%AF%BB%E5%8F%96/:5:0","tags":["Python","大文件"],"title":"Python实现对大文件的增量读取","uri":"/python%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E5%A2%9E%E9%87%8F%E8%AF%BB%E5%8F%96/"},{"categories":["Python"],"content":"如何使用Python快速高效地统计出大文件的总行数, 下面是一些实现方法和性能的比较。 ","date":"2021-12-01","objectID":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/:0:0","tags":["Python","大文件"],"title":"Python计算大文件行数方法及性能比较","uri":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"},{"categories":["Python"],"content":"实现方法 ","date":"2021-12-01","objectID":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/:1:0","tags":["Python","大文件"],"title":"Python计算大文件行数方法及性能比较","uri":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"},{"categories":["Python"],"content":"readlines方法读所有行 def readline_count(file_name): return len(open(file_name).readlines()) ","date":"2021-12-01","objectID":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/:1:1","tags":["Python","大文件"],"title":"Python计算大文件行数方法及性能比较","uri":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"},{"categories":["Python"],"content":"依次读取每行 def simple_count(file_name): lines = 0 for _ in open(file_name): lines += 1 return lines ","date":"2021-12-01","objectID":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/:1:2","tags":["Python","大文件"],"title":"Python计算大文件行数方法及性能比较","uri":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"},{"categories":["Python"],"content":"使用sum函数计数 def sum_count(file_name): return sum(1 for _ in open(file_name)) ","date":"2021-12-01","objectID":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/:1:3","tags":["Python","大文件"],"title":"Python计算大文件行数方法及性能比较","uri":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"},{"categories":["Python"],"content":"enumerate枚举计数 def enumerate_count(file_name): with open(file_name) as f: for count, _ in enumerate(f, 1): pass return count ","date":"2021-12-01","objectID":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/:1:4","tags":["Python","大文件"],"title":"Python计算大文件行数方法及性能比较","uri":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"},{"categories":["Python"],"content":"buff+count每次读取固定大小,然后统计行数 def buff_count(file_name): with open(file_name, 'rb') as f: count = 0 buf_size = 1024 * 1024 buf = f.read(buf_size) while buf: count += buf.count(b'\\n') buf = f.read(buf_size) return count ","date":"2021-12-01","objectID":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/:1:5","tags":["Python","大文件"],"title":"Python计算大文件行数方法及性能比较","uri":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"},{"categories":["Python"],"content":"wc+count调用使用wc命令计算行 def wc_count(file_name): import subprocess out = subprocess.getoutput(\"wc -l %s\" % file_name) return int(out.split()[0]) ","date":"2021-12-01","objectID":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/:1:6","tags":["Python","大文件"],"title":"Python计算大文件行数方法及性能比较","uri":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"},{"categories":["Python"],"content":"partial+count 在buff_count基础上引入partial def partial_count(file_name): from functools import partial buffer = 1024 * 1024 with open(file_name) as f: return sum(x.count('\\n') for x in iter(partial(f.read, buffer), '')) ","date":"2021-12-01","objectID":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/:1:7","tags":["Python","大文件"],"title":"Python计算大文件行数方法及性能比较","uri":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"},{"categories":["Python"],"content":"iter count 在buff_count基础上引入itertools模块 def iter_count(file_name): from itertools import (takewhile, repeat) buffer = 1024 * 1024 with open(file_name) as f: buf_gen = takewhile(lambda x: x, (f.read(buffer) for _ in repeat(None))) return sum(buf.count('\\n') for buf in buf_gen) ","date":"2021-12-01","objectID":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/:1:8","tags":["Python","大文件"],"title":"Python计算大文件行数方法及性能比较","uri":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"},{"categories":["Python"],"content":"效率比较 下面是在4-Core 8GB Python3.6的环境下,分别测试100M、500M、1G、10G大小文件运行的时间，单位:秒： 方法 100M 500M 1G 10G 1.readline_count 0.25 1.82 3.27 45.04 2.simple_count 0.13 0.85 1.58 13.53 3.sum_count 0.15 0.77 1.59 14.07 4.enumerate_count 0.15 0.80 1.60 13.37 5.buff_count 0.13 0.62 1.18 10.21 6.wc_count 0.09 0.53 0.99 9.47 7.partial_count 0.12 0.55 1.11 8.92 8.iter_count 0.08 0.42 0.83 8.33 ","date":"2021-12-01","objectID":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/:2:0","tags":["Python","大文件"],"title":"Python计算大文件行数方法及性能比较","uri":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"},{"categories":["Python"],"content":"来源 https://www.cnblogs.com/jhao/p/13488867.html ","date":"2021-12-01","objectID":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/:3:0","tags":["Python","大文件"],"title":"Python计算大文件行数方法及性能比较","uri":"/python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/"},{"categories":null,"content":"记录下命令，下载所需依赖库，在不能联网的机器上离线安装。 # 查看 pip list # 依赖库信息格式输出 pip freeze \u003e requirements.txt # 仅下载 pip download -r requirements.txt # 安装 pip install --no-index --find-links=dir_path -r requirements.txt ","date":"2021-12-01","objectID":"/pip%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%BA%93-copy/:0:0","tags":null,"title":"pip离线安装依赖库","uri":"/pip%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%BA%93-copy/"},{"categories":["Python"],"content":"记录下命令，下载所需依赖库，在不能联网的机器上离线安装。","date":"2021-12-01","objectID":"/pip%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%BA%93/","tags":["Python"],"title":"pip离线安装依赖库","uri":"/pip%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Python"],"content":"记录下命令，下载所需依赖库，在不能联网的机器上离线安装。 # 查看 pip list # 依赖库信息格式输出 pip freeze \u003e requirements.txt # 仅下载 pip download -r requirements.txt # 安装 pip install --no-index --find-links=dir_path -r requirements.txt ","date":"2021-12-01","objectID":"/pip%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%BA%93/:0:0","tags":["Python"],"title":"pip离线安装依赖库","uri":"/pip%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%BA%93/"},{"categories":["Python"],"content":"我们平时使用Requests的时候，一般是这样写代码的： import requests def parse(html): print('对 html 进行处理') html = requests.get('url') parse(html) 这是一种非常常见的直线性思维，我先请求网站拿到 html，然后我再把 html 传给负责处理的函数。在整个过程中，“我“担任着调度的角色。 在这种思维方式的影响下，有些同学即使在使用aiohttp写异步爬虫，也是这样写的： import aiohttp import asyncio async def request(url): async with aiohttp.ClientSession() as session: resp = await session.get(url) html = await resp.text(encoding='utf-8') def parse(html): print('处理 html') async def main(): url_list = [url1, url2, url3, url4] tasks = [] for url in url_list: tasks.append(request(url)) html_list = await asyncio.gather(*tasks) for html in html_list: parse(html) if __name__ == '__main__': asyncio.run(main()) 确实，这些 URL 的网络请求是异步了，但是却必须等到所有 URL 全部请求完成以后，才能开始处理这些 HTML。假如其中一个 URL 访问只需要1秒钟，其他的 URL 请求需要3秒钟。那么这个1秒钟的请求结束以后，还需要等待2秒，才能开始进行处理。 于是，有些同学会修改代码，多包装一层函数： import aiohttp import asyncio async def request(url): async with aiohttp.ClientSession() as session: resp = await session.get(url) html = await resp.text(encoding='utf-8') def parse(html): print('处理 html') async def get(url): html = await request(url) parse(html) async def main(): url_list = [url1, url2, url3, url4] tasks = [] for url in url_list: tasks.append(get(url)) await asyncio.gather(*tasks) if __name__ == '__main__': asyncio.run(main()) get()函数整体负责获取一个 URL 的源代码并对它进行解析。然后让 get()函数异步。 这样做确实能够解决问题，但是大家如果仔细体会就会发现，在get()函数里面的代码写法，还是用的同步处理的思想。 既然要写异步代码，那么我们脑子里就要一直记住——很多个请求会同时发出，但是我们并不知道他们什么时候完成。与其让我们去等待它完成，然后再把完成结果传给另外一个函数。不如让这些请求在结束的时候，自行主动把结果传给处理函数。 有了这种思想以后，我们再来修改一下上面的代码： import aiohttp import asyncio async def request(url, callback): async with aiohttp.ClientSession() as session: resp = await session.get(url) html = await resp.text(encoding='utf-8') callback(html) def parse(html): print('处理 html: ', html) async def main(): url_list = [ 'http://exercise.kingname.info/exercise_middleware_ip/1', 'http://exercise.kingname.info/exercise_middleware_ip/2', 'http://exercise.kingname.info/exercise_middleware_ip/3', 'http://exercise.kingname.info/exercise_middleware_ip/4', 'http://exercise.kingname.info/exercise_middleware_ip/5', 'http://exercise.kingname.info/exercise_middleware_ip/6', ] tasks = [] for url in url_list: tasks.append(request(url, parse)) await asyncio.gather(*tasks) if __name__ == '__main__': asyncio.run(main()) 运行效果如下图所示： 这种写法，初看起来与用get()函数包装没什么区别，但是他们在思维方式上却完全不一样。 这种不一样，接下来的几篇文章会进一步演示。 ","date":"2021-11-27","objectID":"/aiohttp%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%BE%B9%E8%AF%B7%E6%B1%82%E8%BE%B9%E5%A4%84%E7%90%86/:0:0","tags":["Python","aiohttp","异步"],"title":"aiohttp使用回调函数边请求边处理","uri":"/aiohttp%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%BE%B9%E8%AF%B7%E6%B1%82%E8%BE%B9%E5%A4%84%E7%90%86/"},{"categories":["Python"],"content":"来源 Callback ——从同步思维切换到异步思维 ","date":"2021-11-27","objectID":"/aiohttp%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%BE%B9%E8%AF%B7%E6%B1%82%E8%BE%B9%E5%A4%84%E7%90%86/:1:0","tags":["Python","aiohttp","异步"],"title":"aiohttp使用回调函数边请求边处理","uri":"/aiohttp%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%BE%B9%E8%AF%B7%E6%B1%82%E8%BE%B9%E5%A4%84%E7%90%86/"},{"categories":["aiohttp"],"content":"aiohttp学习笔记","date":"2021-11-27","objectID":"/aiohttp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":["Python","aiohttp","异步"],"title":"aiohttp学习笔记","uri":"/aiohttp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["aiohttp"],"content":"aiohttp中文文档 https://www.cntofu.com/book/127/aiohttp文档/ClientUsage.md ","date":"2021-11-27","objectID":"/aiohttp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["Python","aiohttp","异步"],"title":"aiohttp学习笔记","uri":"/aiohttp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"前言 写这篇文章是受 xinghun85 的这篇博客 的启发, 但是人家后面写的东西跳跃太快, 有点没看懂, 自己在此做一个补充. 我希望能用一个最平易近人的例子, 把 Python 协程中的 async/await 概念讲清楚, 希望能够帮助大家有一个形象化的认识. 注: 所有的讲解都在代码的注释里. from time import sleep, time def demo1(): \"\"\" 假设我们有三台洗衣机, 现在有三批衣服需要分别放到这三台洗衣机里面洗. \"\"\" def washing1(): sleep(3) # 第一台洗衣机, 需要洗3秒才能洗完 (只是打个比方) print('washer1 finished') # 洗完的时候, 洗衣机会响一下, 告诉我们洗完了 def washing2(): sleep(2) print('washer2 finished') def washing3(): sleep(5) print('washer3 finished') washing1() washing2() washing3() \"\"\" 这个还是很容易理解的, 运行 demo1(), 那么需要10秒钟才能把全部衣服洗完. 没错, 大部分时间都花在挨个地等洗衣机上了. \"\"\" def demo2(): \"\"\" 现在我们想要避免无谓的等待, 为了提高效率, 我们将使用 async. washing1/2/3() 本是 \"普通函数\", 现在我们用 async 把它们升级为 \"异步函数\". 注: 一个异步的函数, 有个更标准的称呼, 我们叫它 \"协程\" (coroutine). \"\"\" async def washing1(): sleep(3) print('washer1 finished') async def washing2(): sleep(2) print('washer2 finished') async def washing3(): sleep(5) print('washer3 finished') washing1() washing2() washing3() \"\"\" 从正常人的理解来看, 我们现在有了异步函数, 但是却忘了定义应该什么时候 \"离开\" 一台洗衣 机, 去看看另一个... 这就会导致, 现在的情况是我们一边看着第一台洗衣机, 一边着急地想着 \"是不是该去开第二台洗衣机了呢?\" 但又不敢去 (只是打个比方), 最终还是花了10秒的时间才 把衣服洗完. PS: 其实 demo2() 是无法运行的, Python 会直接警告你: RuntimeWarning: coroutine 'demo2.\u003clocals\u003e.washing1' was never awaited RuntimeWarning: coroutine 'demo2.\u003clocals\u003e.washing2' was never awaited RuntimeWarning: coroutine 'demo2.\u003clocals\u003e.washing3' was never awaited \"\"\" def demo3(): \"\"\" 现在我们吸取了上次的教训, 告诉自己洗衣服的过程是 \"可等待的\" (awaitable), 在它开始洗衣服 的时候, 我们可以去弄别的机器. \"\"\" async def washing1(): await sleep(3) # 注意这里加入了 await print('washer1 finished') async def washing2(): await sleep(2) print('washer2 finished') async def washing3(): await sleep(5) print('washer3 finished') washing1() washing2() washing3() \"\"\" 尝试运行一下, 我们会发现还是会报错 (报错内容和 demo2 一样). 这里我说一下原因, 以及在 demo4 中会给出一个最终答案: 1. 第一个问题是, await 后面必须跟一个 awaitable 类型或者具有 __await__ 属性的 对象. 这个 awaitable, 并不是我们认为 sleep() 是 awaitable 就可以 await 了, 常见的 awaitable 对象应该是: await asyncio.sleep(3) # asyncio 库的 sleep() 机制与 time.sleep() 不 # 同, 前者是 \"假性睡眠\", 后者是会导致线程阻塞的 \"真性睡眠\" await an_async_function() # 一个异步的函数, 也是可等待的对象 以下是不可等待的: await time.sleep(3) x = await 'hello' # \u003cclass 'str'\u003e doesn't define '__await__' x = await 3 + 2 # \u003cclass 'int'\u003e dosen't define '__await__' x = await None # ... x = await a_sync_function() # 普通的函数, 是不可等待的 2. 第二个问题是, 如果我们要执行异步函数, 不能用这样的调用方法: washing1() washing2() washing3() 而应该用 asyncio 库中的事件循环机制来启动 (具体见 demo4 讲解). \"\"\" def demo4(): \"\"\" 这是最终我们想要的实现. \"\"\" import asyncio # 引入 asyncio 库 async def washing1(): await asyncio.sleep(3) # 使用 asyncio.sleep(), 它返回的是一个可等待的对象 print('washer1 finished') async def washing2(): await asyncio.sleep(2) print('washer2 finished') async def washing3(): await asyncio.sleep(5) print('washer3 finished') \"\"\" 事件循环机制分为以下几步骤: 1. 创建一个事件循环 2. 将异步函数加入事件队列 3. 执行事件队列, 直到最晚的一个事件被处理完毕后结束 4. 最后建议用 close() 方法关闭事件循环, 以彻底清理 loop 对象防止误用 \"\"\" # 1. 创建一个事件循环 loop = asyncio.get_event_loop() # 2. 将异步函数加入事件队列 tasks = [ washing1(), washing2(), washing3(), ] # 3. 执行事件队列, 直到最晚的一个事件被处理完毕后结束 loop.run_until_complete(asyncio.wait(tasks)) \"\"\" PS: 如果不满意想要 \"多洗几遍\", 可以多写几句: loop.run_until_complete(asyncio.wait(tasks)) loop.run_until_complete(asyncio.wait(tasks)) loop.run_until_complete(asyncio.wait(tasks)) ... \"\"\" # 4. 如果不再使用 loop, 建议养成良好关闭的习惯 # (有点类似于文件读写结束时的 close() 操作) loop.close() \"\"\" 最终的打印效果: washer2 finished washer1 finished washer3 finished elapsed time = 5.126561641693115 (毕竟切换线程也要有点耗时的) 说句题外话, 我看有的博主的加入事件队列是这样写的: tasks = [ loop.create_task(washing1()), loop.create_task(washing2()), loop.create_task(washing3()), ] 运行的效果是一样的, 暂不清楚为什么他们这样做. \"\"\" if __name__ == '__main__': # 为验证是否真的缩短了时间, 我们计个时 start = time() # demo1() # 需花费10秒 # demo2() # 会报错: RuntimeWarning: coroutine ... was never awaited # demo3() # 会报错: RuntimeWarning: coroutine ... was never awaited demo4() # 需花费5秒多一点点 end = time() print('elapsed time = ' + str(end - start)) ","date":"2021-11-27","objectID":"/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3-python%E4%B8%AD-%E7%9A%84-async-await-%E6%A6%82%E5%BF%B5/:1:0","tags":["编程","异步","aiohttp"],"title":"轻松理解 Python中 的 async-await 概念","uri":"/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3-python%E4%B8%AD-%E7%9A%84-async-await-%E6%A6%82%E5%BF%B5/"},{"categories":["Python"],"content":"参考 Python并发之异步I/O(async,await) - 简书 https://www.jianshu.com/p/db2e5d222bb9 对python async与await的理解 - xinghun85 - 博客园 https://www.cnblogs.com/xinghun85/p/9937741.html Python 的异步 IO：Asyncio 简介-马哥教育官网 http://www.magedu.com/2025.html Python Async/Await入门指南 - _朝晖 - 博客园 https://www.cnblogs.com/dhcn/p/9032461.html ","date":"2021-11-27","objectID":"/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3-python%E4%B8%AD-%E7%9A%84-async-await-%E6%A6%82%E5%BF%B5/:2:0","tags":["编程","异步","aiohttp"],"title":"轻松理解 Python中 的 async-await 概念","uri":"/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3-python%E4%B8%AD-%E7%9A%84-async-await-%E6%A6%82%E5%BF%B5/"},{"categories":["Python"],"content":"来源 https://blog.csdn.net/Likianta/article/details/90123678 ","date":"2021-11-27","objectID":"/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3-python%E4%B8%AD-%E7%9A%84-async-await-%E6%A6%82%E5%BF%B5/:3:0","tags":["编程","异步","aiohttp"],"title":"轻松理解 Python中 的 async-await 概念","uri":"/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3-python%E4%B8%AD-%E7%9A%84-async-await-%E6%A6%82%E5%BF%B5/"},{"categories":["Python"],"content":"转载此文的原因是，此文通俗解释了-事件循环是什么-","date":"2021-11-27","objectID":"/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/","tags":["编程","异步","aiohttp"],"title":"python3异步编程async/await原理解释的比较详细的文章","uri":"/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/"},{"categories":["Python"],"content":"身为Python核心开发组的成员，我对于这门语言的各种细节充满好奇。尽管我很清楚自己不可能对这门语言做到全知全能，但哪怕是为了能够解决各种issue和参与常规的语言设计工作，我也觉得有必要试着接触和理解Python的内核，弄清楚在底层它是怎么工作的。 话虽如此，直到最近我才理解了Python3.5中async/await的工作机制。在此之前，对于async/await语法，我只知道Python3.3中的yield from和Python3.4中的asyncio让这个新语法得以在Python3.5中实现。由于日常工作中没有接触多少网络编程–asyncio的主要应用领域，虽然它可以做的远不止于此–我对async/await并没有关注太多。以代码来说，我知道： yield from iterator (大体)等价于: from x in iterator: yield x 而且我知道asyncio是个事件循环的框架，支持异步编程，还有这些术语所表示的(基本)意义。但未曾真正的深入研究async/await语法，分析从最基础的指令到实现代码语法功能的过程，我觉得并没有理解Python中的异步编程，这一点甚至让我心烦意乱。因此我决定花点时间弄明白这个语法的工作机制。鉴于我听到许多人说他们也不理解异步编程的工作机制，我写出了这篇论文(是的，这篇博文耗费时间之长，字数之多，让我妻子把它叫做论文)。 由于我希望对这个语法的工作机制有一个完整的理解，这篇论文中会出现涉及CPython的底层技术细节。如果你不关心这些细节，或者无法通过这篇文章完全理解这些细节–限于篇幅，我不可能详细解释CPython的每个细节，否则这篇文章就要变成一本书了(例如，如果你不知道代码对象具有标识位，那就别在意代码对象是什么，这不是这篇文章的重点)–那也没什么关系。在每个章节的最后，我都添加了一个概念明确的小结，因此如果你对某个章节的内容不感兴趣，那么可以跳过前面的长篇大论，直接阅读结论。 Python中协程(coroutine)的历史 根据维基百科，“协程是将多个低优先级的任务转换成统一类型的子任务，以实现在多个节点之间停止或唤醒程序运行的程序模块”。这句专业论述翻译成通俗易懂的话就是，“协程就是可以人为暂停执行的函数”。如果你觉得，“这听起来像是生成器(generators)”，那么你是对的。 生成器的概念在Python2.2时的PEP 255中(由于实现了遍历器的协议，生成器也被成为生成器遍历器)第一次被引入。主要受到了Icon语言的影响，生成器允许用户创建一个特殊的遍历器，在生成下一个值时，不会占用额外的内存，并且实现方式非常简单(当然，在自定义类中实现__iter__()和__next__()方法也可以达到不存储遍历器中所有值的效果，但也带来了额外的工作量)。举例来说，如果你想实现自己的range()函数，最直接的方式是创建一个整数数组： def eager_range(up_to): \"\"\"创建一个从0到变量up_to的数组，不包括up_to\"\"\" sequence = [] index = [] while index \u003c up_to: sequence.append(index) index += 1 return sequence 简单直白，但这个函数的问题是，如果你需要的序列很大，比如0到一百万，你必须创建一个包含了所有整数的长度是一百万的数组。如果使用生成器，你就可以毫不费力的创建一个从0到上限前一个整数的生成器。所占用的内存也只是每次生成的一个整数。 def lazy_range(up_to): \"\"\"一个从0到变量up_to，不包括up_to的生成器\"\"\" index = 0 while index \u003c up_to: yield index index += 1 函数可以在遇到yield表达式时暂停执行–尽管yield直到Python2.5才出现–然后在下次被调用时继续执行，这种特性对于节约内存使用有意义深远，可以用于实现无限长度的序列。 也许你已经注意到了，生成器所操作的都是遍历器。多一种更好的创建遍历器的语法的确不错(当你为一个对象定义__iter__()方法作为生成器时，也会收到类似的提升)，但如果我们把生成器的“暂停”功能拿出来，再加上“把事物传进去”的功能，Python就有了自己的协程功能(暂且把这个当成Python的一个概念，真正的Python中的协程会在后面详细讨论)。Python 2.5中引入了把对象传进一个被暂停的生成器的功能，这要归功于PEP 342。抛开与本文无关的内容不看，PEP 342引入了生成器的send()方法。这样就不光可以暂停生成器，更可以在生成器停止时给它传回一个值。在上文range()函数的基础上更近一步，你可以让函数产生的序列前进或后退： def jumping_range(up_to): \"\"\"一个从0到变量up_to，不包括up_to的生成器 传入生成器的值会让序列产生对应的位移 \"\"\" index = 0 while index \u003c up_to: jump = yield index if jump is None: ##原文这里是 if jump is Not None, 应该是笔误，此处已做修改 jump = 1 index += jump if __name__ == '__main__': iterator = jumping_range(5) print(next(iterator)) # 0 print(iterator.send(2)) # 2 print(next(iterator)) # 3 print(iterator.send(-1)) # 2 for x in iterator: print(x) # 3, 4 直到Python 3.3中PEP 380引入yield from之前，生成器都没有太大的变化。严格的说，yield from让用户可以轻松便捷的从遍历器(生成器最常见的应用场景)里提取每一个值，进而重构生成器。 def lazy_range(up_to): \"\"\"一个从0到变量up_to，不包括up_to的生成器\"\"\" index = 0 def gratuitous_refactor(): nonlocal index while index \u003c up_to: yield index index += 1 yield from gratuitous_refactor() 同样出于简化重构操作的目的，yield from也支持将生成器串连起来，这样再不同的调用栈之间传递值时，不需要对原有代码做太大的改动。 def bottom(): \"\"\"返回yield表达式来允许值通过调用栈进行传递\"\"\" return (yield 42) def middle(): return (yield from bottom()) def top(): return (yield from middle()) # 获取生成器 gen = top() value = next(gen) print(value) # Prints '42' try: value = gen.send(value * 2) except StopIteration as exc: print(\"Error!\") # Prints 'Error!' value = exc.value print(value) # Prints '84' 总结 Python2.2引入的生成器使代码的执行可以被暂停。而在Python2.5中引入的允许传值给被暂停的生成器的功能，则让Python中协程的概念成为可能。在Python3.3中引入的yield from让重构和连接生成器变得更加简单。 ","date":"2021-11-27","objectID":"/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/:0:0","tags":["编程","异步","aiohttp"],"title":"python3异步编程async/await原理解释的比较详细的文章","uri":"/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/"},{"categories":["Python"],"content":"事件循环是什么？ 如果你想理解async/await语法，那么理解事件循环的定义，知道它如何支持的异步编程，是不可或缺的基础知识。如果你曾经做过GUI编程–包括网页前端工作–那么你已经接触过事件循环了。但在Python的语言体系中，异步编程的概念还是第一次出现，所以如果不知道事件循环是什么，也情有可原。 让我们回到维基百科，事件循环是“在程序中等待、分发事件或消息的编程结构”。简而言之，事件循环的作用是，“当A发生后，执行B”。最简单的例子可能是每个浏览器中都有的JavaScript事件循环，当你点击网页某处(“当A发生后”)，点击事件被传递给JavaScript的事件循环，然后事件循环检查网页上该位置是否有注册了处理这次点击事件的onclick回调函数(“执行B”)。如果注册了回调函数，那么回调函数就会接收点击事件的详细信息，被调用执行。事件循环会不停的收集发生的事件，循环已注册的事件操作来找到对应的操作，因此被称为“循环”。 Python标准库中的asyncio库可以提供事件循环。asyncio在网络编程里的一个重要应用场景，就是以连接到socket的I/O准备好读/写(通过selector模块实现)事件作为事件循环中的“当A发生后”事件。除了GUI和I/O，事件循环也经常在执行多线程或多进程代码时充当调度器(例如协同式多任务处理)。如果你知道Python中的GIL(General Interpreter Lock)，事件循环在规避GIL限制方面也有很大的作用。 总结 事件循环提供了一个让你实现“当事件A发生后，执行事件B”功能的循环。简单来说，事件循环监视事件的发生，如果发生的是事件循环关心(“注册”过)的事件，那么事件循环会执行所有被关联到该事件的操作。在Python3.4中加入标准库的asyncio使Python也有了事件循环。 ","date":"2021-11-27","objectID":"/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/:0:1","tags":["编程","异步","aiohttp"],"title":"python3异步编程async/await原理解释的比较详细的文章","uri":"/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/"},{"categories":["Python"],"content":"async和await是怎么工作的 在Python3.4中的工作方式 在Python3.3推动生成器的发展和Python3.5中事件循环以asyncio的形式出现之间，Python3.4以并发编程的形式实现了异步编程。从本质上说，异步编程就是无法预知执行时间的计算机程序(也就是异步，而非同步)。并发编程的代码即使运行在同一个线程中，执行时也互不干扰(并发不是并行)。例如，以下Python3.4的代码中，并发两个异步的函数调用，每秒递减计数，互不干扰。 import asyncio # Borrowed from http://curio.readthedocs.org/en/latest/tutorial.html. def countdown(number, n): while n \u003e 0: print('T-minus', n, '({})'.format(number)) yield from asyncio.sleep(1) n -= 1 loop = asyncio.get_event_loop() tasks = [ asyncio.ensure_future(countdown('A', 2)), asyncio.ensure_future(countdown('B', 3)) ] loop.run_until_complete(asyncio.wait(tasks)) loop.close() 在Python3.4中，asyncio.coroutine装饰器被用于修饰使用asyncio库并且作为协程在它的事件循环中运行的函数。这是Python中第一次出现明确的协程定义：一种实装了PEP 342中添加给生成器的方法，基类是抽象类collections.abc.Coroutine的对象。这个定义让那些原本没有异步执行意图的生成器也带上了协程的特征。而为了解决这种混淆，asyncio规定所有作为协程执行的函数都需要以asyncio.coroutine装饰器进行修饰。 有了这样一个明确的协程的定义(同时符合生成器的接口规范)，你可以使用yield from将任何asyncio.Future对象传入事件循环，在等待事件发生时暂停程序执行(future对象是asyncio中的一种对象，此处不再详述)。future对象进入事件循环后就处于事件循环的监控之下，一旦future对象完成了自身任务，事件循环就会唤醒原本被暂停的协程继续执行，future对象的返回结果则通过send()方法由事件循环传递给协程。 以上文代码为例，事件循环启动了两个调用call()函数的协程，运行到某个协程中包含yield from和asyncio.sleep()语句处，这条语句将一个asyncio.Future对象返回事件循环，暂停协程的执行。这时事件循环会为future对象等待一秒(并监控其他程序，例如另外一个协程)，一秒后事件循环唤醒传出了future对象的被暂停的countdown()协程继续执行，并把future对象的执行结果归还给原协程。这个循环过程会持续到countdown()协程结束执行，事件循环中没有被监控的事件为止。稍后我会用一个完整的例子详细解释协程/事件循环结构的工作流程，但首先，我要解释一下async和await是如何工作的。 从yield from到Python3.5中的await 在Python3.4中，一个用于异步执行的协程代码会被标记成以下形式： # 这种写法在Python3.5中同样有效 @asyncio.coroutine def py34_coro(): yield from stuff() Python3.5也添加了一个作用和asyncio.coroutine相同，用于修饰协程函数的装饰器types.coroutine。也可以使用async def语法定义协程函数，但是这样定义的协程函数中不能使用yield语句，只允许使用return或await语句返回数据。 async def py35_coro(): await stuff() 对同一个协程概念添加的不同语法，是为了规范协程的定义。这些陆续补充的语法使协程从抽象的接口变成了具体的对象类型，让普通的生成器和协程用的生成器有了明显的区别(inspect.iscoroutine()方法的判断标准则比async还要严格)。 另外，除了async，Python3.5也引入了await语法(只能在async def定义的函数中使用)。虽然await的使用场景与yield from类似，但是await接收的对象不同。作为由于协程而产生的语法，await接收协程对象简直理所当然。但是当你对某个对象使用await语法时，技术上说，这个对象必须是可等待对象(awaitable object)：一种定义了__await__()方法(返回非协程本身的遍历器)的对象。协程本身也被视作可等待对象(体现在Python语言设计中，就是collections.abc.Coroutine继承了collections.abc.Awaitable抽象类)。可等待对象的定义沿用了Python中将大多数语法结构在底层转换成方法调用的传统设计思想，例如a + b等价于a.__add__(b)或b.__radd__(a)。 那么在编译器层面，yield from和await的运行机制有什么区别(例如types.coroutine修饰的生成器和async def语法定义的函数)呢？让我们看看上面两个例子在Python3.5环境下执行时的字节码细节有什么不同，py34_coro()执行时的字节码是： In [31]: dis.dis(py34_coro) 3 0 LOAD_GLOBAL 0 (stuff) 3 CALL_FUNCTION 0 (0 positional, 0 keyword pair) 6 GET_YIELD_FROM_ITER 7 LOAD_CONST 0 (None) 10 YIELD_FROM 11 POP_TOP 12 LOAD_CONST 0 (None) 15 RETURN_VALUE py35_coro()执行时的字节码是： In [33]: dis.dis(py35_coro) 2 0 LOAD_GLOBAL 0 (stuff) 3 CALL_FUNCTION 0 (0 positional, 0 keyword pair) 6 GET_AWAITABLE 7 LOAD_CONST 0 (None) 10 YIELD_FROM 11 POP_TOP 12 LOAD_CONST 0 (None) 15 RETURN_VALUE 除了py34_coro代码中多了一行装饰器而导致的行号不同，两组字节码的区别集中在GET_YIELD_FROM_ITER操作符和GET_AWAITABLE操作符。两个函数都是以协程的语法声明的。对于GET_YIELD_FROM_ITER，编译器只检查参数是否生成器或者协程，如果不是，就调用iter()函数遍历参数(types.coroutine装饰器修饰了生成器，让代码对象在C代码层面附带了CO_ITERABLE_COROUTINE标识，因此yield from语句可以在协程中接收协程对象)。 GET_AWAITABLE则是另外一番光景。虽然同GET_YIELD_FROM_ITER操作符一样，字节码也接收协程对象，但它不会接收没有协程标记的生成器。而且，正如前文所述，字节码不止接收协程对象，也可以接收可等待对象。这样，yield from语句和await语句都可以实现协程概念，但一个接收的是普通的生成器，另一个是可等待对象。 也许你会好奇，为什么基于async的协程和基于生成器的协程在暂停时接收的对象会不同？这种设计的主要目的是让用户不至于混淆两种类型的协程实现，或者不小心弄错类似的API的参数类型，甚而影响Python最重要的特性的使用体验。例如生成器继承了协程的API，在需要协程时很容易犯使用了普通的生成器的错误。生成器的使用场景不限于通过协程实现流程控制的情况，因此很容易的辨别普通生成器和协程也非常重要。可是，Python不是需要预编译的静态语言，在使用基于生成器的协程时编译器只能做到在运行时进行检查。换句话说，就算使用了types.coroutine装饰器，编译器也无法确定生成器会充当本职工作还是扮演协程的角色(记住，即使代码中明明白白使用了types.coroutine装饰器，依然有在之前的代码中类似types = spam这样的语句存在的可能)，编译器会根据已知的信息，在不同的上下文环境下调用不同的操作符。 对于基于生成器的协程和async定义的协程的区别，我的一个非常重要的观点是，只有基于生成器的协程可以真正的暂停程序执行，并把外部对象传入事件循环。当你使用事件循环相关的函数，如asyncio.sleep()时，这些函数与事件循环的交互所用的是框架内部的API，事件循环究竟如何变化，并不需要用户操心，因此也许你很少看到这种关注底层概念的说法。我们大多数人其实并不需要真正实现一个事件循环，而只需要使用async这样的语法来通过事件循环实现某个功能。但如果你像我一样，好奇为什么我们不能使用async协程实现类似asnycio.sleep()的功能，那么答案就在这里。 总结 让我们总结一下这两个相似的术语，使用async def可以定义协程，使用types.coroutine装饰器可以将一个生成器–返回一个不是协程本身的遍历器–声明为协程。await语句只能用于可等待","date":"2021-11-27","objectID":"/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/:0:2","tags":["编程","异步","aiohttp"],"title":"python3异步编程async/await原理解释的比较详细的文章","uri":"/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/"},{"categories":["Python"],"content":"请把async/await视为异步编程的API David Bzazley的Python Brasil 2015 keynote让我发现自己忽略了一件很重要的事。在那个演讲中，David指出，async/await其实是一种异步编程的API(他在Twitter上对我说过同样的话)。我想David的意思是，我们不应该把async/await当成asnycio的一种别名，而应该利用async/await，让asyncio成为异步编程的通用框架。 David对将async/await作为异步编程API的想法深信不疑，甚至在他的curio项目中实现了自己的事件循环。这也侧面证明了Python中async/await作为异步编程语法的作用(不像其他集成了事件循环的语言那样，用户需要自己实现事件循环和底层细节)。async/await语法让像curio这样的项目可以进行不同的底层操作(asyncio使用future对象与事件循环进行交互，而curio使用元祖对象)，还让它们可以有不同的侧重和性能优化(为了更广泛的适用性，asyncio实现了完整的传输和协议层框架，而相对简单的curio则需要用户实现那些框架，但也因此获得了更快的运行速度)。 看完了Python中异步编程的(简略)历史，很容易得出async/await == asyncio的结论。我想说的是，asyncio导致了Python3.4中异步编程的出现，并且对Python3.5中async/await的产生居功至伟，但是，async/await的灵活的设计，甚至到了可以_不使用_asyncio的地步，也不需要为了应用asyncio框架而修改架构。简而言之，async/await语法延续了Python在保证实用性的同时尽可能的让设计灵活的传统。 ","date":"2021-11-27","objectID":"/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/:0:3","tags":["编程","异步","aiohttp"],"title":"python3异步编程async/await原理解释的比较详细的文章","uri":"/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/"},{"categories":["Python"],"content":"一个例子 看到这里，你的脑子里应该已经装满了各种新术语和新概念，但对于这些新事物如何实现异步编程却仍一知半解。为了加深理解，以下是一个(略显做作的)异步编程的例子，包括完整的从事件循环到相关业务函数的代码。在这个例子中，协程的用途是实现独立的火箭发射倒计时器，产生的效果是同步进行的倒计时。这是通过异步编程而实现的函数并发，程序执行是有三个协程运行在在同一个线程中，却可以彼此互不干扰。 import datetime import heapq import types import time class Task: \"\"\"Represent how long a coroutine should wait before starting again. Comparison operators are implemented for use by heapq. Two-item tuples unfortunately don't work because when the datetime.datetime instances are equal, comparison falls to the coroutine and they don't implement comparison methods, triggering an exception. Think of this as being like asyncio.Task/curio.Task. \"\"\" def __init__(self, wait_until, coro): self.coro = coro self.waiting_until = wait_until def __eq__(self, other): return self.waiting_until == other.waiting_until def __lt__(self, other): return self.waiting_until \u003c other.waiting_until class SleepingLoop: \"\"\"An event loop focused on delaying execution of coroutines. Think of this as being like asyncio.BaseEventLoop/curio.Kernel. \"\"\" def __init__(self, *coros): self._new = coros self._waiting = [] def run_until_complete(self): # Start all the coroutines. for coro in self._new: wait_for = coro.send(None) heapq.heappush(self._waiting, Task(wait_for, coro)) # Keep running until there is no more work to do. while self._waiting: now = datetime.datetime.now() # Get the coroutine with the soonest resumption time. task = heapq.heappop(self._waiting) if now \u003c task.waiting_until: # We're ahead of schedule; wait until it's time to resume. delta = task.waiting_until - now time.sleep(delta.total_seconds()) now = datetime.datetime.now() try: # It's time to resume the coroutine. wait_until = task.coro.send(now) heapq.heappush(self._waiting, Task(wait_until, task.coro)) except StopIteration: # The coroutine is done. pass @types.coroutine def sleep(seconds): \"\"\"Pause a coroutine for the specified number of seconds. Think of this as being like asyncio.sleep()/curio.sleep(). \"\"\" now = datetime.datetime.now() wait_until = now + datetime.timedelta(seconds=seconds) # Make all coroutines on the call stack pause; the need to use `yield` # necessitates this be generator-based and not an async-based coroutine. actual = yield wait_until # Resume the execution stack, sending back how long we actually waited. return actual - now async def countdown(label, length, *, delay=0): \"\"\"Countdown a launch for `length` seconds, waiting `delay` seconds. This is what a user would typically write. \"\"\" print(label, 'waiting', delay, 'seconds before starting countdown') delta = await sleep(delay) print(label, 'starting after waiting', delta) while length: print(label, 'T-minus', length) waited = await sleep(1) length -= 1 print(label, 'lift-off!') def main(): \"\"\"Start the event loop, counting down 3 separate launches. This is what a user would typically write. \"\"\" loop = SleepingLoop(countdown('A', 5), countdown('B', 3, delay=2), countdown('C', 4, delay=1)) start = datetime.datetime.now() loop.run_until_complete() print('Total elapsed time is', datetime.datetime.now() - start) if __name__ == '__main__': main() 正如前文所说，这个例子是有意为之，如果在Python3.5下运行，你会发现虽然三个协程在同一线程中互不干扰，但总运行时间是5秒左右。你可以把Task，SleepingLoop和sleep()看成asyncio和curio这样生成事件循环的框架提供的接口函数，对普通用户来说，只有countdown()和main()函数才需要关注。到此为止，你应该已经明白，async，await语句，甚至整个异步编程，都不是完全无法理解的魔术，async/await只是Python为了让异步编程更简便易用而添加的API。 ","date":"2021-11-27","objectID":"/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/:0:4","tags":["编程","异步","aiohttp"],"title":"python3异步编程async/await原理解释的比较详细的文章","uri":"/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/"},{"categories":["Python"],"content":"我对未来的愿景 我已经理解了Python中的异步编程，我想把它用到所有地方！这个精巧高效的概念完全可以替代原本线程的作用。问题是，Python3.5和async/await都是面世不久的新事物，这就意味着支持异步编程的库数量不会太多。例如，要发送HTTP请求，你要么手动构造HTTP请求对象(麻烦透顶)，然后用一个类似aiohttp的框架把HTTP放进另外的事件循环(对于aiohttp，是asyncio)开始操作；要么就等着哪天出现一个像hyper这样的项目对HTTP这类I/O进行抽象，让你可以使用任意的I/O库(遗憾的是，到目前为止hyper只支持HTTP/2)。 我的个人观点是希望像hyper这样的项目可以继续发展，分离从I/O获取二进制数据和解析二进制数据的逻辑。Python中大部分的I/O库都是包揽进行I/O操作和处理从I/O接收的数据，因此对操作分离进行抽象意义重大。Python标准库的http包也存在同样的问题，有处理I/O的连接对象，却没有HTTP解析器。而如果你希望requests库支持异步编程，那么你可能要失望了，因为requests从设计上就是同步编程。拥有异步编程能力让Python社区有机会弥补Python语言中没有多层网络栈抽象的缺点。现在Python的优势是可以像运行同步代码那样运行异步代码，因此填补异步编程空白的工具，可以应用在同步异步两种场景中。 我还希望Python可以增加async协程对yield语句的支持。这可能需要一个新的关键字(也许是anticipate?)，但只使用async语法就不能实现事件循环的情况实在不尽人意。幸运的是，在这一点上我不是一个人，PEP 492的作者与我观点相同，我觉得这个愿望很有可能成为现实。 总结 总而言之，async和await出现的目的就是为了协程，顺便支持可等待对象，也可以把普通生成器转换成协程。所有这些都是为了实现并发操作，来提升Python中的异步编程体验。相比使用多线程的编程体验，协程功能强大并且更为易用–只用了包括注释在内的不到100行代码就实现了一个完整的异步编程实例–兼具良好的适用性和运行效率(curio的FAQ里说它的运行速度比twisted快30-40%，比gevent慢10-15%，别忘了，在Python2+版本中，Twisted用的内存更少而且调试比Go简单，想想我们可以做到什么程度！)。能在Python 3中看到async/await的引入，我非常高兴，并且期待Python社区接纳这个新语法，希望有更多的库和框架支持async/await语法，让所有的Python开发者都可以从异步编程中受益。 来源 https://blog.csdn.net/permike/article/details/110821246 ","date":"2021-11-27","objectID":"/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/:0:5","tags":["编程","异步","aiohttp"],"title":"python3异步编程async/await原理解释的比较详细的文章","uri":"/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/"},{"categories":["逆向"],"content":" import requests,random,time def register(): deviceid = ''.join(random.sample('abcdefghijklmnopqrstuvwxyz1234567890',20)+random.sample('abcdefghijklmnopqrstuvwxyz1234567890',20)) headers = { 'User-Agent': 'okhttp/3.10.0', 'device': deviceid, 'platform': 'android', 'device_id': deviceid, 'token': '', 'channel': '1', 'Content-Length': '0', 'Host': 'and.feiniaojiasu.com:10000', 'Connection': 'Keep-Alive', 'Accept-Encoding': 'gzip', } params = ( ('device_id', deviceid), ('channel', '1'), ) response = requests.post('http://and.feiniaojiasu.com:10000/api/user/tourist', headers=headers, params=params) # print(response.json()) try: token=response.json()[\"data\"][\"token\"] print('device_id:\\t',deviceid) print('token:\\t',token) return deviceid,token except: print(response.json()) def nodes_detail(device_id,token,_id): headers = { 'User-Agent': 'okhttp/3.10.0', 'device': device_id, 'platform': 'android', 'device_id': device_id, 'token': token, 'channel': '1', 'Content-Length': '0', 'Host': 'and.feiniaojiasu.com:10000', 'Connection': 'Keep-Alive', 'Accept-Encoding': 'gzip', } params = ( ('id', _id), ('token', token), ) url = 'http://and.feiniaojiasu.com:10000/api/mine/serviceDetail' r= requests.post(url, headers=headers, params=params) try: print(r.json()['data']['name']+r.json()['data']['bandwidth'],r.json()['data']['service_str']) except: print(r.json()) def get_nodes(device_id,token): headers = { 'User-Agent': 'okhttp/3.10.0', 'device': device_id, 'platform': 'android', 'device_id': device_id, 'token': token, 'channel': '1', 'Content-Length': '0', 'Host': 'and.feiniaojiasu.com:10000', 'Connection': 'Keep-Alive', 'Accept-Encoding': 'gzip', } params = ( ('vip', '1'), ('token', token), ) response = requests.get('http://and.feiniaojiasu.com:10000/api/mine/service', headers=headers, params=params) return response.json()['data'] device_id,token = register() nodes = {\"status\":1,\"message\":\"成功\",\"data\":[{\"id\":266,\"name\":\"超级线路（Tw11）\",\"type\":1,\"pro\":76,\"vip\":1,\"ip_num\":228,\"bandwidth\":600,\"ip_max\":300,\"created_at\":\"2021-11-17 15:04:12\"},{\"id\":267,\"name\":\"超级线路（Tw10）\",\"type\":1,\"pro\":70,\"vip\":1,\"ip_num\":210,\"bandwidth\":600,\"ip_max\":300,\"created_at\":\"2021-11-21 10:03:44\"},{\"id\":257,\"name\":\"超级线路（Tw）\",\"type\":1,\"pro\":71,\"vip\":1,\"ip_num\":250,\"bandwidth\":600,\"ip_max\":350,\"created_at\":\"2021-10-01 18:12:59\"},{\"id\":246,\"name\":\"超级线路（Tw7）\",\"type\":1,\"pro\":70,\"vip\":1,\"ip_num\":246,\"bandwidth\":600,\"ip_max\":350,\"created_at\":\"2021-09-04 13:57:02\"},{\"id\":252,\"name\":\"超级线路（Tw0）\",\"type\":1,\"pro\":71,\"vip\":1,\"ip_num\":250,\"bandwidth\":600,\"ip_max\":350,\"created_at\":\"2021-09-04 14:12:01\"},{\"id\":237,\"name\":\"超级线路（Tw1）\",\"type\":1,\"pro\":72,\"vip\":1,\"ip_num\":255,\"bandwidth\":600,\"ip_max\":350,\"created_at\":\"2021-09-04 13:36:32\"},{\"id\":238,\"name\":\"超级线路（Tw3）\",\"type\":1,\"pro\":71,\"vip\":1,\"ip_num\":251,\"bandwidth\":600,\"ip_max\":350,\"created_at\":\"2021-09-04 13:39:27\"},{\"id\":239,\"name\":\"超级线路（Tw5）\",\"type\":1,\"pro\":71,\"vip\":1,\"ip_num\":251,\"bandwidth\":600,\"ip_max\":350,\"created_at\":\"2021-09-04 13:39:45\"},{\"id\":250,\"name\":\"超级线路（Tw8）\",\"type\":1,\"pro\":72,\"vip\":1,\"ip_num\":254,\"bandwidth\":600,\"ip_max\":350,\"created_at\":\"2021-09-04 14:05:26\"},{\"id\":249,\"name\":\"超级线路（Tw9）\",\"type\":1,\"pro\":69,\"vip\":1,\"ip_num\":243,\"bandwidth\":600,\"ip_max\":350,\"created_at\":\"2021-09-04 14:04:22\"},{\"id\":245,\"name\":\"超级线路（Tw6）\",\"type\":1,\"pro\":52,\"vip\":1,\"ip_num\":185,\"bandwidth\":600,\"ip_max\":350,\"created_at\":\"2021-09-04 13:56:57\"},{\"id\":240,\"name\":\"超级线路（Tw4）\",\"type\":1,\"pro\":44,\"vip\":1,\"ip_num\":154,\"bandwidth\":600,\"ip_max\":350,\"created_at\":\"2021-09-04 13:41:02\"},{\"id\":243,\"name\":\"超级线路（Hk1）\",\"type\":2,\"pro\":48,\"vip\":1,\"ip_num\":170,\"bandwidth\":50,\"ip_max\":350,\"created_at\":\"2021-09-04 13:47:06\"},{\"id\":236,\"name\":\"超级线路（Hk3）\",\"type\":1,\"pro\":0,\"vip\":1,\"ip_num\":0,\"bandwidth\":600,\"ip_max\":350,\"created_at\":\"2021-09-04 13:36:21\"},{\"id\":255,\"name\":\"超级线路（Us1）\",\"type\":2,\"pro\":8,\"vip\":1,\"ip_num\":29,\"bandwidth\":100,\"ip_max\":350,\"created_at\":\"2021-09-12 22:24:02\"},{\"id\":242,\"name\":\"超级线路（Us2）\",\"type\":1,\"pro\":2,\"vip\":1,\"ip_num\":6,\"bandwidth\":1000,\"ip_max\":300","date":"2021-11-22","objectID":"/%E6%92%B8%E9%A3%9E%E9%B8%9F%E5%8A%A0%E9%80%9F%E5%99%A8/:0:0","tags":null,"title":"撸飞鸟加速器","uri":"/%E6%92%B8%E9%A3%9E%E9%B8%9F%E5%8A%A0%E9%80%9F%E5%99%A8/"},{"categories":["代理"],"content":"来源：https://www.jianshu.com/p/49c444d9a435 \u003e 声明下：不同于网络上千百篇方法，下文是经过各种严格测试都通过的，同时也是一个实验的过程，排除了各种不靠谱的方法。有需要的可以评论来讨论，想要源码和相关参考文献或笔记的，也可以找我。 ","date":"2021-11-18","objectID":"/python%E4%BF%AE%E6%94%B9windows%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/:0:0","tags":["Python","代理"],"title":"Python修改Windows系统代理的方法","uri":"/python%E4%BF%AE%E6%94%B9windows%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["代理"],"content":"思路及启发 先说一下我这一路实验的思路吧，这个至关重要。之前一直在用Python做爬虫抓取数据，发现本机IP的问题不解决，爬虫相当于白费了。然后各种百度，不管是用urllib2还是requests的代理设置，都不管用。然后又各种搜索Python更改windows代理的设置，还需要接触windos底层API，有复杂又不好实现。于是爬虫的学习就放弃了好长一段时间。 最近因为一直在用AutoHotkey大大加快电脑操作效率，各种快捷键和代替手动操作一些常规系统设置。突发奇想，想让它自动打开IE的Internet设置，然后自动点击“局域网设置”，在自动在代理框里输入IP地址，按回车完成设置。这真是个好主意~ 不过失败了。。。因为AHK在IE设置弹出的框框中选择某一个输入框，很麻烦，我也没法实现。所以就在想另一个办法，因为AHK操作Windows的cmd命令很方便，所以在想能不能用它打开cmd然后用命令设置IE呢？ 然后又各种百度。发现这是可以通过reg add注册表设置来实现的！于是，就开启了reg命令的百度之旅。 按照网上各种方法，都指向了注册表的这个地方: HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings 大家都说在这个路径下，有这么3个项非常重要： ProxyEnable - 使用代理 ProxyServer - 代理IP的地址及端口号 AutoConfigURL - 自动配置脚本（PAC）的地址 于是试着用reg add命令操作： reg add \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\" /v ProxyEnable /tREG_DWORD /d 1 /f reg add \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\" /v ProxyServer /d\"192.168.1.1:8080\" /f 这两句第一个是打开“代理”，第二个是设置代理的IP地址。 先在命令行里敲了下命令，然后打开regedit注册表，刷新下看，还真改了！ 然后手动打开IE设置，发现里面的内容也确实改变了。然后再打开浏览器，打开IP查询的网址，自己的IP真的变了！ 至此以为大功告成了。结果再用时，发现大错特错—— 再次用命令行改我指定的IP地址后，网页打不开了。。。 来回反复调试查错之后，我发现一个“大秘密”：如果不手动打开IE设置里的局域网设置窗口的话，所有代理设置是不生效的。这是为什么呢？ 百度里搜索不到。 于是我就用英文到Stackoverflow去搜，结果发现实际影响本机代理的注册表项目并不是之前的那几个！（真怀疑网上那些人说自己用这个项达到定时设置代理的人是不是玩真的。。。） 而是这个位置的项： HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections 其中的DefaultConnectionSettings才是真正需要改的东西。打开以后各种乱码，原来是二进制值。 不过用编辑器看二进制值，确实发现代理IP地址和自动配置脚本的地址都在里面。 那怎么办呢？AHK可不会操作二进制，也没什么方法能用reg add命令行直接把二进制值注入。 然后又进入无尽的百度模式。 ","date":"2021-11-18","objectID":"/python%E4%BF%AE%E6%94%B9windows%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/:1:0","tags":["Python","代理"],"title":"Python修改Windows系统代理的方法","uri":"/python%E4%BF%AE%E6%94%B9windows%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["代理"],"content":"注册表的二进制项修改方式的突发奇想 忘了什么启发的我吧，好像是自己无聊到在注册表上乱点，发现我刻意导出注册表。 然后导出了下试试，发现是个.reg文件。然后无聊双击一下，发现可以把这个文件导入到注册表！ 于是灵光一闪，赶紧用文本编辑器打开这个.reg文件，发现里面是文字画的十六进制码，类似这样的： Windows Registry Editor Version 5.00 [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections] \"DefaultConnectionSettings\"=hex:46,00,00,00,03,00,00,00,07,00,00,00,0e,00,00,\\ 00,31,39,32,2e,31,36,38,2e,31,2e,31,3a,38,30,00,00,00,00,21,00,00,00,68,74,\\ 74,70,3a,2f,2f,78,64,75,6f,74,61,69,2e,63,6f,6d,2f,70,52,73,4f,33,4e,47,52,\\ 33,2d,2e,70,61,63,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\\ 00,00,00,00,00,00,00,00,00,00,00,00,00 \"SavedLegacySettings\"=hex:46,00,00,00,c1,0c,00,00,07,00,00,00,0e,00,00,00,31,\\ 39,32,2e,31,36,38,2e,31,2e,31,3a,38,30,00,00,00,00,21,00,00,00,68,74,74,70,\\ 3a,2f,2f,78,64,75,6f,74,61,69,2e,63,6f,6d,2f,70,52,73,4f,33,4e,47,52,33,2d,\\ 2e,70,61,63,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,\\ 00,00,00,00,00,00,00,00,00,00,00 ","date":"2021-11-18","objectID":"/python%E4%BF%AE%E6%94%B9windows%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/:2:0","tags":["Python","代理"],"title":"Python修改Windows系统代理的方法","uri":"/python%E4%BF%AE%E6%94%B9windows%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["代理"],"content":"于是最终答案就出来了（这里开始有Python介入） 这个时候我还不知道这是正确答案，只是想试一试： 用Python组成一段有效的二进制码（其实是十六进制） -\u003e 把注册表值封装为reg文件 -\u003e 通过命令行的reg import命令导入reg文件 -\u003e 成功！ 然后问题就在于怎么安装正确的格式组成 ","date":"2021-11-18","objectID":"/python%E4%BF%AE%E6%94%B9windows%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/:2:1","tags":["Python","代理"],"title":"Python修改Windows系统代理的方法","uri":"/python%E4%BF%AE%E6%94%B9windows%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["代理"],"content":"DefaultConnectionSettings十六进制值的分析 于是继续到Stackoverflow上搜索DefaultConnectionSettings这个项中十六进制的读取问题。 发现有一个人大概总结了每一位字节是代表什么，不过不够详细。地址在这里【How to set ‘automatic configuration script’ for a dial-up connection programmatically?】 然后开始做笔记： 接着开始尝试对照着那段二进制值看一看。于是我把这段十六进制码做成PDF，方便做笔记，大概是这样的： 实际的十六进制值果然和网上的不同。经过实验，后面一大段画删除线的，都是没用的，删除也没关系。实际上，它只有在你手动打开IE设置面板时，才自动加上的。不管它，实际上有用的十六进制并不长。总结下也就这么几位： 46 00 00 00 00 00 00 00 开关 00 00 00 IP长度 00 00 00 IP地址 00 00 00 是否跳过本地代理 21 00 00 00 PAC地址 其中，通过规律发现每个信息的分隔符是三个00，即00 00 00。上面有7个00的，因为没什么用我就不讲了（其实第四个代表自增数，直接为00就好了） 当然，其中汉字的部分是十六进制格式的。 这几个汉字，是其中最重要的信息，具体如下： 开关(switcher): 主要代表IE设置中复选框的选中情况，你可以打开IE设置看看。以下是所有可用的值（括号中是我用的别名）： 0F全部开启(ALL)；01全部禁用(Off) 03使用代理服务器(ProxyOnly)；05使用自动脚本(PacOnly)； 07使用脚本和代理(ProxyAndPac)；09打开自动检测设置(D)； 0B打开自动检测并使用代理(DIP)；0D打开自动检测并使用脚本(DS)； IP长度：必须是十六进制的，0就是00，7就是07,10就是0a,11是0b。在Python中，格式是0xa，所以需要把格式统一为注册表的标准。 IP地址：直接把IP安装每个字符转十六进制就好了。如果IP为空的话，就直接为00。这时会看到switcher后面跟了11个00。。。 是否跳过本地代理：这段有点复杂，实际上我们几乎不用。如果不用的话直接为00就好了。但是用的话，就必须写为：附加信息长度00 00 00 附加信息这样的。 附加信息：只能是这句话：\u003clocal\u003e 附加信息长度：因为附加信息是固定的，所以共7位，写为07就好了。 PAC地址：这个简单，直接把PAC地址翻译为十六进制就好了。如果没有则什么都不写。 至此这段十六进制值就全部解析完毕了。 剩下的就是把你需要的代理IP地址和PAC地址作为参数传进去就好了。然后把这段值封装到reg文件中的对应位置就完全ok了~这步太简单，就不用多说了。 ","date":"2021-11-18","objectID":"/python%E4%BF%AE%E6%94%B9windows%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/:3:0","tags":["Python","代理"],"title":"Python修改Windows系统代理的方法","uri":"/python%E4%BF%AE%E6%94%B9windows%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["代理"],"content":"增加更方便的功能 各种测试成功后，非常高兴。但是还有点余味不足，就想着多添加点方便的功能。 这个Python文件的最后成品可以做到这些事： 直接通过命令行传参数达到各种设置代理的效果。这个很自豪~第一次用系统参数功能，哈哈哈！ 在文件夹中直接双击达到效果 在别的Python文件中（如爬虫）作为模块被使用 被AHK调用 ","date":"2021-11-18","objectID":"/python%E4%BF%AE%E6%94%B9windows%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/:4:0","tags":["Python","代理"],"title":"Python修改Windows系统代理的方法","uri":"/python%E4%BF%AE%E6%94%B9windows%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["代理"],"content":"在Autohotkey中调用——极其方便极其傻瓜式操作！ 不忘初心嘛~ python处理一切完成后，又回到了AHK中。 这一步可能也就写了几分钟，让AHK直接带参数打开python脚本就做到了。比如设置一个代理IP地址： path = \"D:\\setRegProxy.py\" ;这里是python脚本的地址，随便放哪都行。 key = \"0.0.0.0:80\" ;这里根据需要设置为代理地址 Run % path \" -o ProxyOnly \" key 这样就齐活了~ 当然，我的AHK脚本实现的功能比这个还要爽快——弹出一个小输入框，直接粘贴一个ip地址，按回车就能实现代理设置。 ","date":"2021-11-18","objectID":"/python%E4%BF%AE%E6%94%B9windows%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/:5:0","tags":["Python","代理"],"title":"Python修改Windows系统代理的方法","uri":"/python%E4%BF%AE%E6%94%B9windows%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["代理"],"content":"Python脚本的源码(setProxy.py) 只要机器上安装了Python 2.x版本就行，不需要依赖安装和设置其他任何东西。 # coding:utf-8 ''' # Title : setRegProxy # Author : Solomon Xie # Utility : Via Registry key of windows, change proxy settings of IE on Windows. # Require : Python 2.x, Windows 7 # Reg Path: HKUC\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections # Anlysis : 注册表的二进制值(及关键信息)如下：\"46 00 00 00 00 00 00 00 开关 00 00 00 IP长度 00 00 00 IP地址 00 00 00 是否跳过本地代理 21 00 00 00 PAC地址\" # Method : 通过在cmd中导入reg文件的方式执行并立即生效。 # Notes : - 二进制值的设置选项在代码中已经体现了。本代码可以根据需要自动设置代理。 # switcher: 开关：0F全部开启(ALL)；01全部禁用(Off) 03使用代理服务器(ProxyOnly)；05使用自动脚本(PacOnly)； 07使用脚本和代理(ProxyAndPac)；09自动检测设置(D)； 0B自动检测并使用代理(DIP)；0D自动检测并使用脚本(DS)； ''' import os, sys, re, getopt def regIESettings(op, noLocal=False, ip='', pac=''): ''' # 根据需求生成Windows代理设置注册表的.reg文件内容 # DefaultConnectionSettings项是二进制项 # 而具体这个二进制文件怎么解析，在收藏的PDF中有详细解释。 ''' if not op : return # 如果是设置IP代理的模式 则检查IP地址的有效性(允许为空，但不允许格式错误) if 'Proxy' in op and not ip == '': # if len(extractIp(ip))==0 if 1 \u003e len(re.findall('([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3})\\s*:{0,1}\\s*([0-9]{1,5}){0,1}',ip)) : print '---Unexpected IP Address:%s---'%ip return options = {'On':'0F','Off':'01','ProxyOnly':'03','PacOnly':'05','ProxyAndPac':'07','D':'09','DIP':'0B','DS':'0D'} if op == 'Off': reg_value = '46,00,00,00,00,00,00,00,01' else: switcher = options.get(op) if not switcher: print('\\n---Unexpected Option. Please check the value after [-o]---\\n') return skipLocal = '07,00,00,00,%s'%__toHex('\u003clocal\u003e') if noLocal else '00' reg_value = '46,00,00,00,00,00,00,00,%(switcher)s,00,00,00,%(ipLen)s,00,00,00,%(ip)s00,00,00,%(skipLocal)s,21,00,00,00%(pac)s' % ({ 'switcher':switcher,'ipLen':__toHex(len(ip)),'ip':__toHex(ip)+',' if ip else '','infoLen':__toHex(len('\u003clocal\u003e')),'skipLocal':skipLocal,'pac':','+__toHex(pac) if pac else '' }) settings = 'Windows Registry Editor Version 5.00\\n[HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Connections]\\n\"DefaultConnectionSettings\"=hex:%s' % reg_value # print 'Using proxy address: %s' % ip print(op, ip, pac) print(options[op] +'\\n'+ __toHex(ip) +'\\n'+ __toHex(pac)) print(settings) # === 生成reg文件并导入到注册表中 === filePath = '%s\\DefaultConnectionSettings.reg'%os.getcwd() with open(filePath, 'w') as f: f.write( settings ) cmd = 'reg import \"%s\"' %filePath result = os.popen(cmd) if len(result.readlines()) \u003c 2 : print('---Successfully import proxy into Registry on this machine.---') return def __toHex(obj): if obj == '': return '' elif obj == 0 or obj == '0' or obj == '00': return '00' if isinstance(obj, str): rehex = [str(hex(ord(s))).replace('0x','') for s in obj] return ','.join(rehex) elif isinstance(obj, int): num = str(hex(obj)).replace('0x', '') return num if len(num)\u003e1 else '0'+num # 如果是一位数则自动补上0，7为07，e为0e if __name__ == '__main__': # 获取文件外部参数 # 用法：在命令行中输入setRegProxy.py -o \"ProxyOnly\" -l --proxy\"0.0.0.0:80\" -l opts, args = getopt.getopt(sys.argv[1:], 'o:p:a:l',['option=','proxy=','pac=','local']) print(opts, args) #调试用 if len(opts) \u003e 0: op, ip, pac = '', '', '' noLocal = False for o,a in opts: if o == '-o' or o == '--option': op = a elif o == '-p' or o == '--proxy' : ip = a elif o == '-a' or o == '--pac' : pac = a elif o == '-l' or o == '--local' : noLocal = False pac = 'http://xduotai.com/pRsO3NGR3-.pac' if not pac else pac if op == 'ProxyOff': regIESettings(op='Off', ip=ip, pac=pac, noLocal=noLocal) regIESettings(op='PacOnly', ip=ip, pac=pac, noLocal=noLocal) elif op == 'PacOff': regIESettings(op='Off', ip=ip, pac=pac, noLocal=noLocal) regIESettings(op='ProxyOnly', ip=ip, pac=pac, noLocal=noLocal) else: regIESettings(op=op, ip=ip, pac=pac, noLocal=noLocal) ","date":"2021-11-18","objectID":"/python%E4%BF%AE%E6%94%B9windows%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/:6:0","tags":["Python","代理"],"title":"Python修改Windows系统代理的方法","uri":"/python%E4%BF%AE%E6%94%B9windows%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["代理"],"content":"Autohotkey源码 Autohotkey怎么用呢？太简单了，傻到爆！ 直接官网下载安装一个Autohotkey软件，也就几M。然后呢，新建一个文本文件，把下面内容粘贴进去。把文件名后缀改为.ahk，然后双击就启动了脚本哈哈！ 这时你试着按一下键盘上的ScrollLock键，就会弹出来一个对话框。效果是这样的： 你可以在这里输入改代理的命令~ 我设计的命令都非常简单，如下： 输入proxy，就会打开IE设置的窗口 输入proxy 192.168.1.1:8080 ，就会把代理设置为这个IP 输入proxy on，就会打开代理（但是IP为空） 输入proxy off，就会关闭代理 输入pac http://abc.com/123.pac，就开启某自动代理设置脚本 输入pac off，就会关闭自动脚本 注意： 我这里注册的键是键盘上的ScrollLock按钮，按一下就有了。也可以自己设定一个。 下面的代码是处理过的，实际上这个按键远比它要方便的多：它是我的快速操作杀手锏，一条命令实现巨多功能。如有感兴趣的可以联系我讨论，或者看我的下一篇专门针对AHK的文章（如果我不犯懒写了的话）。 我设定的指令是proxy ??这样的，如果嫌长或者不方便，可以改为别的自己用着舒服的。甚至不用弹出框，直接按一下F1之类的就完成设置都可以。不过这就需要稍微了解下AHK语法啦~（也不难） ScrollLock:: { ; --- 获取指令及关键词 --- InputBox, fullCommand, (Command Line Interface), Please give me a command:, , 600, 130 ;获取命令 if (fullcommand = \"\") Return ; -- 解析命令 --- split := \" \" StringGetPos , posi, fullCommand, %split% if (posi \u003e 0) { StringMid, eng, fullCommand, 0 , posi ; StringMid, key, fullCommand, posi+2 , StrLen(fullCommand) } else { eng := fullCommand key := \"\" } ; === 打开IE设置窗口的命令 === ieSettings := \"rundll32.exe shell32.dll, Control_RunDLL inetcpl.cpl, ,4L\" ; === python脚本的地址 === path := \"D:\\Solomon Xie\\Workspace\\setRegProxy.py\" ;Python设置代理脚本，可接收命令行参数 ; ---开始执行操作--- if (eng = \"\" and fullcommand != \"\") Run % ieSettings else if (eng = \"Proxy\"){ if (key = \"\") Return else if (key = \"Off\") Run % path \" -o Off \" else{ if (key = \"On\") key := \"\" ;“获取”历史IP值太麻烦 先为空吧 else key = \"--proxy \" %key% Run % path \" -o ProxyOnly \" key } } else if (eng = \"Pac\" and key != \"\") { if (key = \"\" or key = \"On\") key = \"http://xduotai.com/pRsO3NGR3-.pac\" if (key = \"Off\") Run % path \" -o Off \" else { key = \"%key%\" Run % path \" -o PacOnly --pac \" key } } Return } 63人点赞 __Python学习笔记 ","date":"2021-11-18","objectID":"/python%E4%BF%AE%E6%94%B9windows%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/:7:0","tags":["Python","代理"],"title":"Python修改Windows系统代理的方法","uri":"/python%E4%BF%AE%E6%94%B9windows%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["代理"],"content":"来源：https://zhuanlan.zhihu.com/p/350015032 最近遇到的一个问题，在搞清楚之后才发现这么多年的 HTTPS_PROXY 都配置错了！ ","date":"2021-11-18","objectID":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:0:0","tags":["Python","代理"],"title":"【转载】Python遭遇代理错误的解决办法","uri":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["代理"],"content":"起因 想用 Python 在网上下载一些图片素材，结果 requests 报 requests.exceptions.ProxyError，具体的错误信息见下面。当然第一时间是把系统代理关了，结果访问就正常了。 如果只是这样，可能我就觉得是代理有问题，然后关了用就行了，但是偏偏想要下载的资源里是必须要走代理的，所以只能想办法解决。 下面先介绍一下具体的情况： ","date":"2021-11-18","objectID":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:1:0","tags":["Python","代理"],"title":"【转载】Python遭遇代理错误的解决办法","uri":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["代理"],"content":"解决过程 操作系统：Windows 10 Python: 3.8（有虚拟环境） requests 通过代理访问外网时报错如下： Traceback (most recent call last): File \"E:\\code\\Python\\.venv\\smalltools\\lib\\site-packages\\urllib3\\connectionpool.py\", line 696, in urlopen self._prepare_proxy(conn) File \"E:\\code\\Python\\.venv\\smalltools\\lib\\site-packages\\urllib3\\connectionpool.py\", line 964, in _prepare_proxy conn.connect() File \"E:\\code\\Python\\.venv\\smalltools\\lib\\site-packages\\urllib3\\connection.py\", line 359, in connect conn = self._connect_tls_proxy(hostname, conn) File \"E:\\code\\Python\\.venv\\smalltools\\lib\\site-packages\\urllib3\\connection.py\", line 496, in _connect_tls_proxy return ssl_wrap_socket( File \"E:\\code\\Python\\.venv\\smalltools\\lib\\site-packages\\urllib3\\util\\ssl_.py\", line 432, in ssl_wrap_socket ssl_sock = _ssl_wrap_socket_impl(sock, context, tls_in_tls) File \"E:\\code\\Python\\.venv\\smalltools\\lib\\site-packages\\urllib3\\util\\ssl_.py\", line 474, in _ssl_wrap_socket_impl return ssl_context.wrap_socket(sock) File \"C:\\Users\\Davy\\AppData\\Local\\Programs\\Python\\python8\\lib\\ssl.py\", line 500, in wrap_socket return self.sslsocket_class._create( File \"C:\\Users\\Davy\\AppData\\Local\\Programs\\Python\\python8\\lib\\ssl.py\", line 1041, in _create self.do_handshake() File \"C:\\Users\\Davy\\AppData\\Local\\Programs\\Python\\python8\\lib\\ssl.py\", line 1310, in do_handshake self._sslobj.do_handshake() OSError: [Errno 0] Error 因为浏览器访问是没有问题的，代理本身应该没有问题。 按照这个错误信息在网上搜了一下，比较接近的帖子给的解决方案有安装 ssl 模块之类，都照着检查了一遍，问题还是没有解决。 因为网上的内容有些年头了，并且我觉得使用代理是非常常见的场景，既然没多少人报这个问题，那么很可能只是偶然的 bug，于是想着把版本再升级试试。 升级到 python 3.9 ，错误仍然存在，提示略有变化： Traceback (most recent call last): File \"C:\\Users\\Davy\\AppData\\Local\\Programs\\Python\\python9\\lib\\site-packages\\urllib3\\connectionpool.py\", line 696, in urlopen self._prepare_proxy(conn) File \"C:\\Users\\Davy\\AppData\\Local\\Programs\\Python\\python9\\lib\\site-packages\\urllib3\\connectionpool.py\", line 964, in _prepare_proxy conn.connect() File \"C:\\Users\\Davy\\AppData\\Local\\Programs\\Python\\python9\\lib\\site-packages\\urllib3\\connection.py\", line 359, in connect conn = self._connect_tls_proxy(hostname, conn) File \"C:\\Users\\Davy\\AppData\\Local\\Programs\\Python\\python9\\lib\\site-packages\\urllib3\\connection.py\", line 496, in _connect_tls_proxy return ssl_wrap_socket( File \"C:\\Users\\Davy\\AppData\\Local\\Programs\\Python\\python9\\lib\\site-packages\\urllib3\\util\\ssl_.py\", line 432, in ssl_wrap_socket ssl_sock = _ssl_wrap_socket_impl(sock, context, tls_in_tls) File \"C:\\Users\\Davy\\AppData\\Local\\Programs\\Python\\python9\\lib\\site-packages\\urllib3\\util\\ssl_.py\", line 474, in _ssl_wrap_socket_impl return ssl_context.wrap_socket(sock) File \"C:\\Users\\Davy\\AppData\\Local\\Programs\\Python\\python9\\lib\\ssl.py\", line 500, in wrap_socket return self.sslsocket_class._create( File \"C:\\Users\\Davy\\AppData\\Local\\Programs\\Python\\python9\\lib\\ssl.py\", line 1040, in _create self.do_handshake() File \"C:\\Users\\Davy\\AppData\\Local\\Programs\\Python\\python9\\lib\\ssl.py\", line 1309, in do_handshake self._sslobj.do_handshake() ssl.SSLEOFError: EOF occurred in violation of protocol (_ssl.c:1122) 好歹错误信息有点变化，于是按照最下面 ssl.SSLEOFError: EOF occurred in violation of protocol (_ssl.c:1122) 去谷歌，并没有找到解决办法，但是发现有人在不久前遇到了相同的问题，并且通过降级 Python 3.7 解决了。 参见：https://v2ex.com/t/738031 先重新安装 Python 3.7 试了一下果然可行，并且意外地发现在 Python 3.8 环境下也是可行的，也就是可以排除 Python 版本的问题，那么自然就怀疑是某个包引发的。 通过简单地对比和排除，很快就发现了问题所在： 模块 urllib3 的版本，报错的是 1.26.3，没报错的是 1.25.11 在原报错环境中使用下面命令重装低版本 urllib3： pip install urllib3==1.25.11 然后测试果然就没问题了。 ","date":"2021-11-18","objectID":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:2:0","tags":["Python","代理"],"title":"【转载】Python遭遇代理错误的解决办法","uri":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["代理"],"content":"问题根源 先查了一下 urllib3 的更新日志，应该是 1.26.0 的修改导致的： 按照这个更新日志，明明应该是增加了 HTTPS 的支持，怎么反而让它失效了呢？ 我一时搞不明白这个问题，但是想起了我最近遭遇到了另一个问题，然后意外地找到了真相： ","date":"2021-11-18","objectID":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:3:0","tags":["Python","代理"],"title":"【转载】Python遭遇代理错误的解决办法","uri":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["代理"],"content":"同样遭遇代理错误的 pip 同样是在这个环境中，其实在一开始我就遭遇了 pip install 安装包失败的问题，报错信息是： ​ ‘ProxyError(‘Cannot connect to proxy.’, FileNotFoundError(2, ‘No such file or directory’))’ 同样是取消系统代理就能正常安装，就没太在意了。 但是在降级 urllib3 解决了 requests 的 ProxyError 之后，我开始怀疑 pip 安装是不是也是这个问题呢？ 直接在降级了 urllib3 的环境中测试了一下，错误仍然存在，但是版本整体较低的环境中，是没有问题的！ 于是继续对比版本包，结果在 pip 包的路径下发现有一个 _vendor\\urllib3 目录，原来 pip 是直接把 urllib3 集成到了自己的包里面，不受系统安装包的影响。检查其中的 _version.py 里的版本信息，果然也是 1.26.x。 出错的 pip 的版本是 20.3，把 pip 也降级到 20.2 以下，就没有问题了。 显然，鉴于 pip 的高频使用，这种致命的问题不可能没人报，所以在 pip 项目的 issue 列表里很快就找到了相关讨论： https://github.com/pypa/pip/issues/9216​ ","date":"2021-11-18","objectID":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:3:1","tags":["Python","代理"],"title":"【转载】Python遭遇代理错误的解决办法","uri":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["代理"],"content":"urllib3 更新了啥 根据 https://github.com/pypa/pip/issues/9216#issuecomment-741836058 所说，更改代理配置可以解决问题： 绕了好大一圈大概明白是怎么回事了： 以前 urllib3 其实并不支持 https 代理，也就是说代理服务器的地址虽然大家配置的是 https，但是一直都是悄无声息地就按照 http 连接的，刚好代理服务器确实也只支持 http，所以皆大欢喜。 现在 urllib3 要支持 https 代理了，那么既然配置代理是 https 就尝试用 https 的方式去连接，但是由于代理服务器其实只支持 http，所以没法处理请求，ssl 握手阶段就出错了。 注意，这里的 https 是指代理服务器自己的，和我们要访问的目标网站无关。 因为目标网站的协议和代理服务器的协议并不要求一样，所以只需要更改代理配置 ，将访问 https 网站的代理服务器地址改为 http 即可，也就是这样： HTTPS_PROXY=http://proxy_ip:proxy_port 前面的 HTTPS_ 表示，如果访问的站点是 https 的，需要走这里配置的代理服务器；后面的 http:// 则表示这个代理服务器自己只支持 http。 而我们一直以来看到的配置建议，这两者前后通常都是保持一致的： HTTP_PROXY=http://proxy_ip:proxy_port HTTPS_PROXY=https://proxy_ip:proxy_port 这个是错误的！ ","date":"2021-11-18","objectID":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:3:2","tags":["Python","代理"],"title":"【转载】Python遭遇代理错误的解决办法","uri":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["代理"],"content":"代理到底该咋配 Windows 10 中的代理服务器设置如下，并没有区分什么 http 和 https: ","date":"2021-11-18","objectID":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:4:0","tags":["Python","代理"],"title":"【转载】Python遭遇代理错误的解决办法","uri":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["代理"],"content":"手动给 requests 传入代理配置 requests 的请求参数中是支持指定代理服务器的，刚开始的代码没有指定： url = 'https://github.com/' r = requests.get(url) 前面在尝试解决问题的时候，也试过了传入代理服务器配置： proxies={ 'http': 'http://127.0.0.1:7890', 'https': 'https://127.0.0.1:7890' } r = requests.get(url, proxies=proxies) 上面两种写法的效果其实是差不多一样的，结果当然也是一样出错。 按照上面 issue 中的修改建议改为： proxies={ 'http': 'http://127.0.0.1:7890', 'https': 'http://127.0.0.1:7890' # https -\u003e http } r = requests.get(url, proxies=proxies) 运行结果就 OK 了。 好了，现在我们可以不用降级版本了，但是却要多出一段配置，要改代码，总归还是不爽。 其实，如果是 Linux 系统是没这个问题的，本来代理配置就是通过环境变量 HTTP_PROXY 和 HTTPS_PROXY 来设置的，改一下环境变量的值就可以了，麻烦还是在 Windows 系统中。 要搞明白 Python 代码是如何获取 Windows 系统中的代理服务器设置的。 ","date":"2021-11-18","objectID":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:4:1","tags":["Python","代理"],"title":"【转载】Python遭遇代理错误的解决办法","uri":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["代理"],"content":"谁解析的系统代理配置 在代码中不难发现，当用户有传入 proxies 参数时，requests 是通过标准库提供的 getproxies 函数来获取系统代理服务器配置的： \u003e\u003e\u003e # 如果是 python 2，则是 from urllib import getproxies \u003e\u003e\u003e from urllib.request import getproxies \u003e\u003e\u003e getproxies() {'http': 'http://127.0.0.1:7890', 'https': 'https://127.0.0.1:7890', 'ftp': 'ftp://127.0.0.1:7890'} 上面显示的结果就是对应到截图中的代理配置。 注意，urllib 和 urllib3 不是一个库，前者是 Python 标准库自带。 继续看代码： elif os.name == 'nt': def getproxies(): \"\"\"Return a dictionary of scheme -\u003e proxy server URL mappings. Returns settings gathered from the environment, if specified, or the registry. \"\"\" return getproxies_environment() or getproxies_registry() 在 Windows 系统中，先从环境变量获取，如果没有则从注册表获取。 getproxies_environment 的逻辑比较简单，基本和 Linux 系统是一致的，就是环境变量配置成啥样就是啥样。这里我并没有配置环境变量，自然结果是空，最终的结果要看 getproxies_registry。按照其中的代码，从注册表中获取的配置如下： 代码里有两个处理逻辑： proxyServer = str(winreg.QueryValueEx(internetSettings, 'ProxyServer')[0]) if '=' in proxyServer: # Per-protocol settings for p in proxyServer.split(';'): protocol, address = p.split('=', 1) # See if address has a type:// prefix if not re.match('(?:[^/:]+)://', address): address = '%s://%s' % (protocol, address) proxies[protocol] = address else: # Use one setting for all protocols if proxyServer[:5] == 'http:': proxies['http'] = proxyServer else: proxies['http'] = 'http://%s' % proxyServer proxies['https'] = 'https://%s' % proxyServer proxies['ftp'] = 'ftp://%s' % proxyServer 其中第一种是「每种协议各自配置」，下面第二种情况是「所有协议一个配置」。 在第二种情况中，如果带了 http: 就只配置 http 协议，否则（也就是我们现在的场景），针对同一个 proxyServer，添加 3 种协议。 ","date":"2021-11-18","objectID":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:4:2","tags":["Python","代理"],"title":"【转载】Python遭遇代理错误的解决办法","uri":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["代理"],"content":"在 Windows 中如何配置代理 第一种方法：通过环境变量设置： 结果： \u003e\u003e\u003e getproxies() {'https': 'http://127.0.0.1:7890', 'http': 'http://127.0.0.1:7890'} 一旦设置了环境变量，程序就直接从环境变量获取，系统的配置也就失效了。 第二种方法：按照上面的代码倒推出来系统配置： 其中的地址框里的内容是： http=http://127.0.0.1:1080;https=http://127.0.0.1 其中最后的端口只对最后面的那个地址有效，分号前面的地址需要加上端口。 对应的注册表中的值是： 显然这种方式有点诡异和麻烦，目前也没看到有相关的说明，不确定是否会影响其它程序的判断。 如此看来，还是第一种方法比较靠谱，就是不能利用系统配置有点遗憾。 ","date":"2021-11-18","objectID":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:4:3","tags":["Python","代理"],"title":"【转载】Python遭遇代理错误的解决办法","uri":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["代理"],"content":"我的疑惑 那么，在用户只给出了代理服务器的 IP 和 端口的情况下，原有的处理逻辑是不是错误，我也不敢断言。 回到最初犯错的地方： HTTP_PROXY=http://proxy_ip:proxy_port HTTPS_PROXY=https://proxy_ip:proxy_port 我现在还有一个疑惑点是，真的会存在一个代理服务器，能够在同一个端口同时支持 http 和 https 么？如果是那样的话，为啥平常的 web 服务器还要有 80 和 443 两个端口对应不同的服务。 反过来，如果一个端口不可以同时支持两个协议的话，那么上面的配置的错误则更加明显，处理逻辑也就很有问题。 你对此有什么看法和理解，欢迎在评论区讨论！ ","date":"2021-11-18","objectID":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:4:4","tags":["Python","代理"],"title":"【转载】Python遭遇代理错误的解决办法","uri":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["代理"],"content":"总结 通过解决代理服务器错误，对 Python 是如何处理代理服务器配置有了更深入的了解。 ","date":"2021-11-18","objectID":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/:5:0","tags":["Python","代理"],"title":"【转载】Python遭遇代理错误的解决办法","uri":"/%E8%BD%AC%E8%BD%BD-python%E9%81%AD%E9%81%87%E4%BB%A3%E7%90%86%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"categories":["Python"],"content":"官方文档：https://cloud.tencent.com/document/product/583/39780 通过官方文档可知，在云函数在线编辑器那里可以启动终端并在终端中进行包的安装…….下文可以忽略了 ","date":"2021-11-08","objectID":"/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0python%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AE%89%E8%A3%85%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/:0:0","tags":["Python","云函数","SCF"],"title":"腾讯云函数Python依赖包安装打包过程","uri":"/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0python%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AE%89%E8%A3%85%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/"},{"categories":["Python"],"content":"背景 腾讯云函数运行环境提供的库有限，有些库需要自行打包好后上传才能使脚本正常运行，而本地打包时又对打包所处的环境有要求，因为腾讯云函数运行环境为centos7+python3.6.1，所以本地如果是windows+python3.8等非centos7+python3.6.1环境，可能会导致脚本不能运行，故需要临时使用centos7+python3.6.1环境来打包。 ","date":"2021-11-08","objectID":"/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0python%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AE%89%E8%A3%85%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/:1:0","tags":["Python","云函数","SCF"],"title":"腾讯云函数Python依赖包安装打包过程","uri":"/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0python%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AE%89%E8%A3%85%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/"},{"categories":["Python"],"content":"第一步：使用docker安装centos7+python3.6环境 来源：docker学习2-快速搭建centos7-python3.6环境 docker search python ","date":"2021-11-08","objectID":"/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0python%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AE%89%E8%A3%85%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/:1:1","tags":["Python","云函数","SCF"],"title":"腾讯云函数Python依赖包安装打包过程","uri":"/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0python%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AE%89%E8%A3%85%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/"},{"categories":["Python"],"content":"此命令用来搜索与python有关的docker镜像 结果如下： [root@yoyo ~]# docker search python NAME DESCRIPTION STARS OFFICIAL AUTOMATED python Python is an interpreted, interactive, objec… 4288 [OK] django Django is a free web application framework, … 847 [OK] …..（人工省略） centos/python-36-centos7 Platform for building and running Python 3.6… 17 …..（人工省略） python 3.6.5 with requirements last update s… 0 openshift/python-33-centos7 DEPRECATED: A Centos7 based Python v3.3 imag… 0 [root@yoyo ~]# 上面找的想要下载的镜像centos/python-36-centos7,接下来下载到自己本地 docker pull centos/python-36-centos7 二、运行交互式的容器——可以直接在宿主机的终端进入并操作docker容器系统的终端（下称 docker 终端） 1、进入docker终端（宿主机终端） docker run -i -t centos/python-36-centos7 /bin/bash 2、在docker容器里面安装pipreqs（docker 终端） 为避免国内网络环境下载速度慢，临时使用-i参数，指定国内下载源。 pip3 install pipreqs -i https://pypi.tuna.tsinghua.edu.cn/simple 3、将脚本从宿主机复制到docker容器里面（宿主机终端）。 docker cp 本地文件路径 ID全称:容器路径 其中查看容器ID全称的命令为（宿主机终端）： docker ps -a 4、然后在定位到复制进来的脚本所在目录，使用pipreqs来生成当前目录中脚本运行所需的requirements.txt（docker 终端） pipreqs ./ ","date":"2021-11-08","objectID":"/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0python%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AE%89%E8%A3%85%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/:2:0","tags":["Python","云函数","SCF"],"title":"腾讯云函数Python依赖包安装打包过程","uri":"/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0python%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AE%89%E8%A3%85%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/"},{"categories":["Python"],"content":"如果是Windows系统，会报编码错误： ","date":"2021-11-08","objectID":"/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0python%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AE%89%E8%A3%85%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/:3:0","tags":["Python","云函数","SCF"],"title":"腾讯云函数Python依赖包安装打包过程","uri":"/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0python%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AE%89%E8%A3%85%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/"},{"categories":["Python"],"content":"(UnicodeDecodeError: ‘gbk’ codec can’t decode byte 0xa8 in position 24: illegal multibyte sequence) ","date":"2021-11-08","objectID":"/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0python%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AE%89%E8%A3%85%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/:4:0","tags":["Python","云函数","SCF"],"title":"腾讯云函数Python依赖包安装打包过程","uri":"/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0python%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AE%89%E8%A3%85%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/"},{"categories":["Python"],"content":"使用时，指定编码格式 pipreqs ./ –encoding=utf8 5、使用pip3将requirements.txt中的库安装到到当前目录（docker 终端） pip3 install -r requirements.txt -t ./ -i https://pypi.tuna.tsinghua.edu.cn/simple 经过步骤4-5，可能还是会有一些库文件没有被pipreqs识别，比如pymongo需要dnspython库不会被pipreqs识别，此时只要用pip3单独安装缺失的库到当前目录即可。 pip3 install dnspython -t ./ -i https://pypi.tuna.tsinghua.edu.cn/simple 6、将当前目录下所有内容打包成zip压缩文件——腾讯云函数只认zip格式的压缩包（docker 终端） zip -r 压缩包文件名.zip ./* 7、将压缩包从docker容器复制到宿主机（宿主机终端） docker cp ID全称:容器路径 本地文件路径 三、上传zip文件到云函数 （完）……… ","date":"2021-11-08","objectID":"/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0python%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AE%89%E8%A3%85%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/:5:0","tags":["Python","云函数","SCF"],"title":"腾讯云函数Python依赖包安装打包过程","uri":"/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0python%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AE%89%E8%A3%85%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/"},{"categories":["Python"],"content":"来源：https://iximiuz.com/en/posts/flask-gevent-tutorial/ Disclaimer: I wrote this tutorial because gevent saved our project a few years ago and I still see steady gevent-related search traffic on my blog. So, the way gevent helped us may be useful for somebody else as well. Since I still have some handy knowledge I decided to make this note on how to set up things. However, I’d not advise starting a new project in 2020 using this technology. IMHO, it’s aging and losing the traction._ TL;DR: check out code samples on GitHub. Python is booming and Flask is a pretty popular web-framework nowadays. Probably, quite some new projects are being started in Flask. But people should be aware, it’s synchronous by design and ASGI is not a thing yet. So, if someday you realize that your project really needs asynchronous I/O but you already have a considerable codebase on top of Flask, this tutorial is for you. The charming gevent library will enable you to keep using Flask while start benefiting from all the I/O being asynchronous. In the tutorial we will see: How to monkey patch a Flask app to make it asynchronous w/o changing its code. How to run the patched application using gevent.pywsgi application server. How to run the patched application using Gunicorn application server. How to run the patched application using uWSGI application server. How to configure Nginx proxy in front of the application server. [Bonus] How to use psycopg2 with psycogreen to make PostgreSQL access non-blocking. ","date":"2021-11-08","objectID":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/:0:0","tags":["Python","Flask"],"title":"How to use Flask with gevent (uWSGI and Gunicorn editions)","uri":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/"},{"categories":["Python"],"content":"When do I need asynchronous I/O The answer is somewhat naive - you need it when the application’s workload is I/O bound, i.e. it maxes out on latency SLI due to over-communicating to external services. It’s a pretty common situation nowadays due to the enormous spread of microservice architectures and various 3rd-party APIs. If an average HTTP handler in your application needs to make 10+ network requests to build a response, it’s highly likely that you will benefit from asynchronous I/O. On the other hand, if your application consumes 100% of CPU or RAM handling requests, migrating to asynchronous I/O probably will not help. ","date":"2021-11-08","objectID":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/:1:0","tags":["Python","Flask"],"title":"How to use Flask with gevent (uWSGI and Gunicorn editions)","uri":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/"},{"categories":["Python"],"content":"What is gevent From the official site description: gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level synchronous API on top of the libev or libuv event loop. The description is rather obscure for those who are unfamiliar with the mentioned dependencies like greenlet, libev, or libuv. You can check out my previous attempt to briefly explain the nature of this library, but among other things it allows you to monkey patch normal-looking Python code and make the underlying I/O happening asynchronously. The patching introduces what’s called cooperative multitasking into the Python standard library and some 3rd-party modules but the change stays almost completely hidden from the application and the existing code keeps its synchronous-alike outlook while gains the ability to serve requests asynchronously. There is an obvious downside of this approach - the patching doesn’t change the way every single HTTP request is being served, i.e. the I/O within each HTTP handler still happens sequentially, even though it becomes asynchronous. Well, we can start using something similar to asyncio.gather() and parallelize some requests to external resources, but it would require the modification of the existing application code. However, now we can easily scale up the limit of concurrent HTTP requests for our application. After the patching, we don’t need a dedicated thread (or process) per request anymore. Instead, each request handling now happens in a lightweight green thread. Thus, the application can serve tens of thousands of concurrent requests, probably increasing this number by 1-2 orders of magnitude from the previous limit. However, while the description sounds extremely promising (at least to me), the project and the surrounding eco-system is steadily losing traction (in favor of asyncio and aiohttp?): ","date":"2021-11-08","objectID":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/:2:0","tags":["Python","Flask"],"title":"How to use Flask with gevent (uWSGI and Gunicorn editions)","uri":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/"},{"categories":["Python"],"content":"Create simple Flask application The standard tutorial format always seemed boring to me. Instead, we will try to make a tiny playground here. We will try to create a simple Flask application dependant on a sleepy 3rd party API endpoint. The only route of our application will be responding with some hard-coded string concatenated with the API response text. Having such a workload, we will play with different methods of achieving high concurrency in the Flask’s handling of HTTP requests. First, we need to emulate a slow 3rd party API. We will use aiohttp to implement it because it’s based on the asyncio library and provides high concurrency for I/O-bound HTTP requests handling out of the box: # ./slow_api/api.py import os import asyncio from aiohttp import web async def handle(request): delay = float(request.query.get('delay') or 1) await asyncio.sleep(delay) return web.Response(text='slow api response') app = web.Application() app.add_routes([web.get('/', handle)]) if __name__ == '__main__': web.run_app(app, port=os.environ['PORT']) We can launch it in the following Docker container: # ./slow_api/Dockerfile FROM python:3.8 RUN pip install aiohttp COPY api.py /api.py CMD [\"python\", \"/api.py\"] Now, it’s time to create the target Flask application: # ./flask_app/app.py import os import requests from flask import Flask, request api_port = os.environ['PORT_API'] api_url = f'http://slow_api:{api_port}/' app = Flask(__name__) @app.route('/') def index(): delay = float(request.args.get('delay') or 1) resp = requests.get(f'{api_url}?delay={delay}') return 'Hi there! ' + resp.text As promised, it’s fairly simple. ","date":"2021-11-08","objectID":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/:3:0","tags":["Python","Flask"],"title":"How to use Flask with gevent (uWSGI and Gunicorn editions)","uri":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/"},{"categories":["Python"],"content":"Deploy Flask application using Flask dev server The easiest way to run a Flask application is to use a built-in development server. But even this beast supports two modes of request handling. In the single-threaded mode, a Flask application can handle no more than one HTTP request at a time. I.e. the request handling becomes sequential. Experience 🤦 This mode can be dangerous. If an application needs to send a request to itself it may get stuck in a deadlock. In the multi-threaded mode, Flask spawns a thread for every incoming HTTP request. The maximal concurrency, i.e. the highest possible number of simultaneous threads doesn’t seem configurable though. We will use the following Dockerfile to run the Flask dev server: # ./flask_app/Dockerfile-devserver FROM python:3.8 RUN pip install Flask requests COPY app.py /app.py ENV FLASK_APP=app CMD flask run --no-reload \\ --$THREADS-threads \\ --host 0.0.0.0 --port $PORT_APP Let’s spin up the first playground using handy Docker Compose: # ./sync-devserver.yml version: \"3.7\" services: flask_app: init: true build: context: ./flask_app dockerfile: Dockerfile-devserver environment: - PORT_APP=3000 - PORT_API=4000 - THREADS=without ports: - \"127.0.0.1:3000:3000\" depends_on: - slow_api flask_app_threaded: # extends: flask_app init: true build: context: ./flask_app dockerfile: Dockerfile-devserver environment: - PORT_APP=3001 - PORT_API=4000 - THREADS=with ports: - \"127.0.0.1:3001:3001\" depends_on: - slow_api slow_api: init: true build: ./slow_api environment: - PORT=4000 expose: - \"4000\" After running docker-compose build and docker-compose up we will have two instances of our application running. The single-threaded version is bound to the host’s 127.0.0.1:3000, the multi-threaded - to 127.0.0.1:3001. # Build and start app served by Flask dev server $ docker-compose -f sync-devserver.yml build $ docker-compose -f sync-devserver.yml up It’s time to serve the first portion of HTTP requests (using lovely ApacheBench). We will start from the single-threaded version and only 10 requests: # Test single-threaded deployment $ ab -r -n 10 -c 5 http://127.0.0.1:3000/?delay=1 \u003e Concurrency Level: 5 \u003e Time taken for tests: 10.139 seconds \u003e Complete requests: 10 \u003e Failed requests: 0 \u003e Requests per second: 0.99 [#/sec] (mean) As expected, we observed no concurrency. Even though we asked ab to simulate 5 simultaneous clients using -c 5, it took ~10 seconds to finish the scenario with an effective request rate close to 1 per second. If you execute top -H in the server container to check the number of running threads, the picture will be similar to this: docker exec -it flask-gevent-tutorial_flask_app_1 top -H Let’s proceed to the multi-threaded version alongside with increasing the payload up to 2000 requests being produced by 200 simultaneous clients: # Test multi-threaded deployment $ ab -r -n 2000 -c 200 http://127.0.0.1:3001/?delay=1 \u003e Concurrency Level: 200 \u003e Time taken for tests: 16.040 seconds \u003e Complete requests: 2000 \u003e Failed requests: 0 \u003e Requests per second: 124.69 [#/sec] (mean) The effective concurrency grew to the mean of 124 requests per second, but a sample from top -H shows, that at some point of time we had 192 threads and 190 of them were sleeping: docker exec -it flask-gevent-tutorial_flask_app_threaded_1 top -H ","date":"2021-11-08","objectID":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/:4:0","tags":["Python","Flask"],"title":"How to use Flask with gevent (uWSGI and Gunicorn editions)","uri":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/"},{"categories":["Python"],"content":"Deploy Flask application using gevent.pywsgi The fastest way to unleash the power of gevent is to use its built-in WSGI-server called gevent.pywsgi. We need to create an entrypoint: # ./flask_app/pywsgi.py from gevent import monkey monkey.patch_all() import os from gevent.pywsgi import WSGIServer from app import app http_server = WSGIServer(('0.0.0.0', int(os.environ['PORT_APP'])), app) http_server.serve_forever() Notice, how it patches our Flask application. Without monkey.patch_all() there would be no benefit from using gevent here because all the I/O in the application stayed synchronous. The following Dockerfile can be used to run the pywsgi server: # ./flask_app/Dockerfile-gevent-pywsgi FROM python:3.8 RUN pip install Flask requests gevent COPY app.py /app.py COPY pywsgi.py /pywsgi.py CMD python /pywsgi.py Finally, let’s prepare the following playground: # ./async-gevent-pywsgi.yml version: \"3.7\" services: flask_app: init: true build: context: ./flask_app dockerfile: Dockerfile-gevent-pywsgi environment: - PORT_APP=3000 - PORT_API=4000 - THREADS=without ports: - \"127.0.0.1:3000:3000\" depends_on: - slow_api slow_api: init: true build: ./slow_api environment: - PORT=4000 expose: - \"4000\" And launch it using: # Build and start app served by gevent.pywsgi $ docker-compose -f async-gevent-pywsgi.yml build $ docker-compose -f async-gevent-pywsgi.yml up We expect a decent concurrency level with very few threads (if any) in the server container: $ ab -r -n 2000 -c 200 http://127.0.0.1:3000/?delay=1 \u003e Concurrency Level: 200 \u003e Time taken for tests: 17.536 seconds \u003e Complete requests: 2000 \u003e Failed requests: 0 \u003e Requests per second: 114.05 [#/sec] (mean) Executing top -H shows that we DO have some python threads (around 10). Seems like gevent employs a thread pool to implement the asynchronous I/O: docker exec -it flask-gevent-tutorial_flask_app_1 top -H ","date":"2021-11-08","objectID":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/:5:0","tags":["Python","Flask"],"title":"How to use Flask with gevent (uWSGI and Gunicorn editions)","uri":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/"},{"categories":["Python"],"content":"Deploy Flask application using Gunicorn Gunicorn is one of the recommended ways to run Flask applications. We will start from Gunicorn because it has slightly fewer parameters to configure before going than uWSGI. Gunicorn uses the worker process model to serve HTTP requests. But there are multiple types of workers: synchronous, asynchronous, tornado workers, and asyncio workers. In this tutorial, we will cover only the first two types - synchronous and gevent-based asynchronous workers. Let’s start from the synchronous model: # ./flask_app/Dockerfile-gunicorn FROM python:3.8 RUN pip install Flask requests gunicorn COPY app.py /app.py CMD gunicorn --workers $WORKERS \\ --threads $THREADS \\ --bind 0.0.0.0:$PORT_APP \\ app:app Notice that we reuse the original app.py entrypoint without any changes. The synchronous Gunicorn playground looks as follows: # ./sync-gunicorn.yml version: \"3.7\" services: flask_app_gunicorn: init: true build: context: ./flask_app dockerfile: Dockerfile-gunicorn environment: - PORT_APP=3000 - PORT_API=4000 - WORKERS=4 - THREADS=50 ports: - \"127.0.0.1:3000:3000\" depends_on: - slow_api slow_api: init: true build: ./slow_api environment: - PORT=4000 expose: - \"4000\" Let’s build and start the server using 4 workers x 50 threads each (i.e. 200 threads in total): # Build and start app served by Gunicorn $ docker-compose -f sync-gunicorn.yml build $ docker-compose -f sync-gunicorn.yml up Obviously, we expect a high number of requests being served concurrently: $ ab -r -n 2000 -c 200 http://127.0.0.1:3000/?delay=1 \u003e Concurrency Level: 200 \u003e Time taken for tests: 13.427 seconds \u003e Complete requests: 2000 \u003e Failed requests: 0 \u003e Requests per second: 148.95 [#/sec] (mean) But if we compare the samples from top -H before and after the test, we can notice an interesting detail: docker exec -it flask-gevent-tutorial_flask_app_gunicorn_1 top -H (before test) Gunicorn starts workers on the startup, but the workers spawn the threads on-demand: docker exec -it flask-gevent-tutorial_flask_app_gunicorn_1 top -H (during test) Now, let’s switch to gevent workers. For this setup we need to make a new entrypoint to apply the monkey patching: # ./flask_app/patched.py from gevent import monkey monkey.patch_all() # we need to patch very early from app import app # re-export The Dockerfile to run Gunicorn + gevent: # ./flask_app/Dockerfile-gevent-gunicorn FROM python:3.8 RUN pip install Flask requests gunicorn gevent COPY app.py /app.py COPY patched.py /patched.py CMD gunicorn --worker-class gevent \\ --workers $WORKERS \\ --bind 0.0.0.0:$PORT_APP \\ patched:app The playground: # ./async-gevent-gunicorn.yml version: \"3.7\" services: flask_app: init: true build: context: ./flask_app dockerfile: Dockerfile-gevent-gunicorn environment: - PORT_APP=3000 - PORT_API=4000 - WORKERS=1 ports: - \"127.0.0.1:3000:3000\" depends_on: - slow_api slow_api: init: true build: ./slow_api environment: - PORT=4000 expose: - \"4000\" Let’s start it: # Build and start app served by Gunicorn + gevent $ docker-compose -f async-gevent-gunicorn.yml build $ docker-compose -f async-gevent-gunicorn.yml up And conduct the test: $ ab -r -n 2000 -c 200 http://127.0.0.1:3000/?delay=1 \u003e Concurrency Level: 200 \u003e Time taken for tests: 17.839 seconds \u003e Complete requests: 2000 \u003e Failed requests: 0 \u003e Requests per second: 112.11 [#/sec] (mean) We observe similar behavior - only worker processes are alive before the test: docker exec -it flask-gevent-tutorial_flask_app_gunicorn_1 top -H (before test) But during the test, we see 10 new threads spawned. Notice, how it resembles the number of threads used by pywsgi: docker exec -it flask-gevent-tutorial_flask_app_gunicorn_1 top -H (during test) ","date":"2021-11-08","objectID":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/:6:0","tags":["Python","Flask"],"title":"How to use Flask with gevent (uWSGI and Gunicorn editions)","uri":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/"},{"categories":["Python"],"content":"Deploy Flask application using uWSGI uWSGI is a production-grade application server written in C. It’s very fast and supports different execution models. Here we will again compare only two modes: synchronous (N worker processes x K threads each) and gevent-based (N worker processes x M async cores each). First, the synchronous setup: # ./flask_app/Dockerfile-uwsgi FROM python:3.8 RUN pip install Flask requests uwsgi COPY app.py /app.py CMD uwsgi --master \\ --workers $WORKERS \\ --threads $THREADS \\ --protocol $PROTOCOL \\ --socket 0.0.0.0:$PORT_APP \\ --module app:app We use an extra parameters --protocol and the playground sets it to http: # ./sync-uwsgi.yml version: \"3.7\" services: flask_app_uwsgi: init: true build: context: ./flask_app dockerfile: Dockerfile-uwsgi environment: - PORT_APP=3000 - PORT_API=4000 - WORKERS=4 - THREADS=50 - PROTOCOL=http ports: - \"127.0.0.1:3000:3000\" depends_on: - slow_api slow_api: init: true build: ./slow_api environment: - PORT=4000 expose: - \"4000\" We again limit the concurrency by 200 simultaneous HTTP requests (4 workers x 50 threads each): # Build and start app served by uWSGI $ docker-compose -f sync-uwsgi.yml build $ docker-compose -f sync-uwsgi.yml up Let’s send a bunch of HTTP requests: $ ab -r -n 2000 -c 200 http://127.0.0.1:3000/?delay=1 \u003e Concurrency Level: 200 \u003e Time taken for tests: 12.685 seconds \u003e Complete requests: 2000 \u003e Failed requests: 0 \u003e Requests per second: 157.67 [#/sec] (mean) uWSGI spaws workers and threads beforehand: docker exec -it flask-gevent-tutorial_flask_app_uwsgi_1 top -H (before test) So, only the load changes during the test: docker exec -it flask-gevent-tutorial_flask_app_uwsgi_1 top -H (during test) Let’s proceed to the gevent mode. We can reuse the patched.py entrypoint from the Gunicorn+gevent scenario: # ./flask_app/Dockerfile-gevent-uwsgi FROM python:3.8 RUN pip install Flask requests uwsgi gevent COPY app.py /app.py COPY patched.py /patched.py CMD uwsgi --master \\ --single-interpreter \\ --workers $WORKERS \\ --gevent $ASYNC_CORES \\ --protocol $PROTOCOL \\ --socket 0.0.0.0:$PORT_APP \\ --module patched:app One extra parameter the playground sets here is the number of async cores used by gevent: # ./async-gevent-uwsgi.yml version: \"3.7\" services: flask_app: init: true build: context: ./flask_app dockerfile: Dockerfile-gevent-uwsgi environment: - PORT_APP=3000 - PORT_API=4000 - WORKERS=2 - ASYNC_CORES=2000 - PROTOCOL=http ports: - \"127.0.0.1:3000:3000\" depends_on: - slow_api slow_api: init: true build: ./slow_api environment: - PORT=4000 expose: - \"4000\" Let’s start the uWSGI+gevent server: # Build and start app served by uWSGI + gevent $ docker-compose -f async-gevent-uwsgi.yml build $ docker-compose -f async-gevent-uwsgi.yml up And do the test: $ ab -r -n 2000 -c 200 http://127.0.0.1:3000/?delay=1 \u003e Time taken for tests: 13.164 seconds \u003e Complete requests: 2000 \u003e Failed requests: 0 \u003e Requests per second: 151.93 [#/sec] (mean) However, if we check the number of workers before and during the test we will notice a discrepancy with the previous method: docker exec -it flask-gevent-tutorial_flask_app_1 top -H (before test) Before the test, uWSGI had the master and worker processes only, but during the test, threads were started, somewhat around 10 threads per worker process. This number resembles the numbers from gevent.pywsgi and Gunicorn+gevent cases: docker exec -it flask-gevent-tutorial_flask_app_1 top -H (during test) ","date":"2021-11-08","objectID":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/:7:0","tags":["Python","Flask"],"title":"How to use Flask with gevent (uWSGI and Gunicorn editions)","uri":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/"},{"categories":["Python"],"content":"Use Nginx reverse proxy in front of application server Usually, uWSGI and Gunicorn servers reside behind a load balancer and one of the most popular choices is Nginx. ","date":"2021-11-08","objectID":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/:8:0","tags":["Python","Flask"],"title":"How to use Flask with gevent (uWSGI and Gunicorn editions)","uri":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/"},{"categories":["Python"],"content":"Nginx + Gunicorn + gevent Nginx configuration for Gunicorn upstream is just a standard proxy setup: # ./flask_app/nginx-gunicorn.conf server { listen 80; location / { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_pass http://flask_app:3000; } } We can try it out using the following playground: # ./nginx-gunicorn.yml version: \"3.7\" services: ingress: image: nginx:1.17.6 ports: - \"127.0.0.1:8080:80\" volumes: - ./flask_app/nginx-gunicorn.conf:/etc/nginx/conf.d/default.conf depends_on: - flask_app flask_app: init: true build: context: ./flask_app dockerfile: Dockerfile-gevent-gunicorn environment: - PORT_APP=3000 - PORT_API=4000 - WORKERS=1 expose: - \"3000\" depends_on: - slow_api slow_api: init: true build: ./slow_api environment: - PORT=4000 expose: - \"4000\" And then: $ docker-compose -f nginx-gunicorn.yml build $ docker-compose -f nginx-gunicorn.yml up $ ab -r -n 2000 -c 200 http://127.0.0.1:8080/?delay=1 \u003e ... ","date":"2021-11-08","objectID":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/:8:1","tags":["Python","Flask"],"title":"How to use Flask with gevent (uWSGI and Gunicorn editions)","uri":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/"},{"categories":["Python"],"content":"Nginx + uWSGI + gevent uWSGI setup is very similar, but there is a subtle improvement. uWSGI provides a special binary protocol (called uWSGI) to communicate with the reverse proxy in front of it. This makes the joint slightly more efficient. And Nginx kindly supports it: # ./flask_app/nginx-uwsgi.conf server { listen 80; location / { include uwsgi_params; uwsgi_pass uwsgi://flask_app:3000; } } Notice the environment variable PROTOCOL=uwsgi in the following playground: # ./nginx-uwsgi.yml version: \"3.7\" services: ingress: image: nginx:1.17.6 ports: - \"127.0.0.1:8080:80\" volumes: - ./flask_app/nginx-uwsgi.conf:/etc/nginx/conf.d/default.conf depends_on: - flask_app flask_app: init: true build: context: ./flask_app dockerfile: Dockerfile-gevent-uwsgi environment: - PORT_APP=3000 - PORT_API=4000 - WORKERS=1 - ASYNC_CORES=2000 - PROTOCOL=uwsgi expose: - \"3000\" depends_on: - slow_api slow_api: init: true build: ./slow_api environment: - PORT=4000 expose: - \"4000\" We can test the playground using: $ docker-compose -f nginx-uwsgi.yml build $ docker-compose -f nginx-uwsgi.yml up $ ab -r -n 2000 -c 200 http://127.0.0.1:8080/?delay=1 \u003e ... ","date":"2021-11-08","objectID":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/:8:2","tags":["Python","Flask"],"title":"How to use Flask with gevent (uWSGI and Gunicorn editions)","uri":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/"},{"categories":["Python"],"content":"Bonus: make psycopg2 gevent-friendly with psycogreen When asked, gevent patches only modules from the Python standard library. If we use 3rd party modules, like psycopg2, corresponding IO will remain blocking. Let’s consider the following application: # ./psycopg2/app.py from gevent import monkey monkey.patch_all() import os import psycopg2 import requests from flask import Flask, request api_port = os.environ['PORT_API'] api_url = f'http://slow_api:{api_port}/' app = Flask(__name__) @app.route('/') def index(): conn = psycopg2.connect(user=\"example\", password=\"example\", host=\"postgres\") delay = float(request.args.get('delay') or 1) resp = requests.get(f'{api_url}?delay={delay/2}') cur = conn.cursor() cur.execute(\"SELECT NOW(), pg_sleep(%s)\", (delay/2,)) return 'Hi there! {} {}'.format(resp.text, cur.fetchall()[0]) We extended the workload by adding intentionally slow database access. Let’s prepare the Dockerfile: # ./psycopg2/Dockerfile FROM python:3.8 RUN pip install Flask requests psycopg2 psycogreen uwsgi gevent COPY app.py /app.py COPY patched.py /patched.py CMD uwsgi --master \\ --single-interpreter \\ --workers $WORKERS \\ --gevent $ASYNC_CORES \\ --protocol http \\ --socket 0.0.0.0:$PORT_APP \\ --module $MODULE:app And the playground: # ./bonus-psycopg2-gevent.yml version: \"3.7\" services: flask_app: init: true build: context: ./psycopg2 dockerfile: Dockerfile environment: - PORT_APP=3000 - PORT_API=4000 - WORKERS=1 - ASYNC_CORES=2000 - MODULE=app ports: - \"127.0.0.1:3000:3000\" depends_on: - slow_api - postgres slow_api: init: true build: ./slow_api environment: - PORT=4000 expose: - \"4000\" postgres: image: postgres environment: POSTGRES_USER: example POSTGRES_PASSWORD: example expose: - \"5432\" Ideally, we expect ~2 seconds to perform 10 one-second-long HTTP requests with concurrency 5. But the test shows more than 6 seconds due to the blocking behavior of psycopg2 calls: $ docker-compose -f bonus-psycopg2-gevent.yml build $ docker-compose -f bonus-psycopg2-gevent.yml up $ ab -r -n 10 -c 5 http://127.0.0.1:3000/?delay=1 \u003e Concurrency Level: 5 \u003e Time taken for tests: 6.670 seconds \u003e Complete requests: 10 \u003e Failed requests: 0 \u003e Requests per second: 1.50 [#/sec] (mean) To bypass this limitation, we need to use psycogreen module to patch psycopg2: The psycogreen package enables psycopg2 to work with coroutine libraries, using asynchronous calls internally but offering a blocking interface so that regular code can run unmodified. Psycopg offers coroutines support since release 2.2. Because the main module is a C extension it cannot be monkey-patched to become coroutine-friendly. Instead it exposes a hook that coroutine libraries can use to install a function integrating with their event scheduler. Psycopg will call the function whenever it executes a libpq call that may block. psycogreen is a collection of “wait callbacks” useful to integrate Psycopg with different coroutine libraries. Let’s create an entrypoint: # ./psycopg2/patched.py from psycogreen.gevent import patch_psycopg patch_psycopg() from app import app # re-export And extend the playground: # ./bonus-psycopg2-gevent.yml services: # ... flask_app_2: init: true build: context: ./psycopg2 dockerfile: Dockerfile environment: - PORT_APP=3001 - PORT_API=4000 - WORKERS=1 - ASYNC_CORES=2000 - MODULE=patched ports: - \"127.0.0.1:3001:3001\" depends_on: - slow_api - postgres If we test the new instance of the application with ab -n 10 -c 5, the observed performance will be much close to the theoretical one: $ docker-compose -f bonus-psycopg2-gevent.yml build $ docker-compose -f bonus-psycopg2-gevent.yml up $ ab -r -n 10 -c 5 http://127.0.0.1:3001/?delay=1 \u003e Concurrency Level: 5 \u003e Time taken for tests: 3.148 seconds \u003e Complete requests: 10 \u003e Failed requests: 0 \u003e Requests per second: 3.18 [#/sec] (mean) ","date":"2021-11-08","objectID":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/:9:0","tags":["Python","Flask"],"title":"How to use Flask with gevent (uWSGI and Gunicorn editions)","uri":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/"},{"categories":["Python"],"content":"Instead of conclusion Make code, not war! ","date":"2021-11-08","objectID":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/:10:0","tags":["Python","Flask"],"title":"How to use Flask with gevent (uWSGI and Gunicorn editions)","uri":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/"},{"categories":["Python"],"content":"Related articles ","date":"2021-11-08","objectID":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/:11:0","tags":["Python","Flask"],"title":"How to use Flask with gevent (uWSGI and Gunicorn editions)","uri":"/how-to-use-flask-with-gevent-uwsgi-and-gunicorn-editions/"},{"categories":["LeanCloud"],"content":"https://leancloud.cn/docs/leanengine_webhosting_guide-python.html#hash891049750 ","date":"2021-11-08","objectID":"/web%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BAleancloud/:0:0","tags":["LeanCloud","Python"],"title":"利用LeanCloud搭建WEB服务","uri":"/web%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BAleancloud/"},{"categories":null,"content":"部署教程 ","date":"2021-11-07","objectID":"/jd%E7%AD%BE%E5%88%B0%E9%83%A8%E7%BD%B2%E8%87%AA%E5%8A%A8ck%E6%9C%8D%E5%8A%A1/:1:0","tags":null,"title":"JD签到部署自动CK服务","uri":"/jd%E7%AD%BE%E5%88%B0%E9%83%A8%E7%BD%B2%E8%87%AA%E5%8A%A8ck%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"1、安装必要的运行环境 yum install wget unzip -y ","date":"2021-11-07","objectID":"/jd%E7%AD%BE%E5%88%B0%E9%83%A8%E7%BD%B2%E8%87%AA%E5%8A%A8ck%E6%9C%8D%E5%8A%A1/:1:1","tags":null,"title":"JD签到部署自动CK服务","uri":"/jd%E7%AD%BE%E5%88%B0%E9%83%A8%E7%BD%B2%E8%87%AA%E5%8A%A8ck%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"2、下载工具使用的相关文件 # 首先进入我们上篇文章将的docker目录（以下教程我们将从root目录开始） cd .. cd docker # 创建目录放配置以及chromium mkdir nolanjdc \u0026\u0026 cd nolanjdc # 下载config.json 配置文件 并且修改自己的配置 不能缺少（以下二选一即可） # 魔法网络环境 wget -O Config.json https://raw.githubusercontent.com/NolanHzy/nvjdc/main/Config.json #大陆网络环境 wget -O Config.json https://ghproxy.com/https://raw.githubusercontent.com/NolanHzy/nvjdc/main/Config.json # 创建chromium文件夹并进入 mkdir -p .local-chromium/Linux-884014 \u0026\u0026 cd .local-chromium/Linux-884014 # 下载chromium文件 wget https://mirrors.huaweicloud.com/chromium-browser-snapshots/Linux_x64/884014/chrome-linux.zip \u0026\u0026 unzip chrome-linux.zip # 删除刚刚下载的压缩包 rm -f chrome-linux.zip # 回到刚刚创建的nolanjdc目录 cd .. cd .. # 拉镜像（目前最新0.5版本） docker pull nolanhzy/nvjdc:0.5 # 博主在拉取的时候失败了好几次，大家失败了也可以多拉取几次 ","date":"2021-11-07","objectID":"/jd%E7%AD%BE%E5%88%B0%E9%83%A8%E7%BD%B2%E8%87%AA%E5%8A%A8ck%E6%9C%8D%E5%8A%A1/:1:2","tags":null,"title":"JD签到部署自动CK服务","uri":"/jd%E7%AD%BE%E5%88%B0%E9%83%A8%E7%BD%B2%E8%87%AA%E5%8A%A8ck%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"3、修改配置文件 # 使用vi修改配置文件，修改方法参考文件内的注释 vi Config.json 配置文件参考： { ///浏览器最多几个网页 \"MaxTab\": \"4\", //网站标题 \"Title\": \"京东自动签到登录\", //网站公告 \"Announcement\": \"本项目脚本收集于互联网。为了您的财产安全，请关闭京东免密支付！\", ///XDD PLUS Url http://IP地址:端口/api/login/smslogin \"XDDurl\": \"\", ///xddToken \"XDDToken\": \"\", ///青龙配置 注意 如果不要青龙 Config :[] \"Config\": [ { //序号必填从1 开始 \"QLkey\": 1, //服务器名称 \"QLName\": \"XX之家\", //青龙地址，末尾不能是 '/'，此处因为和青龙面板在同一个主机，并且使用--link到了青龙面板，所以使用本地地址 \"QLurl\": \"http://ql:5700\", //青龙2,9 OpenApi Client ID \"QL_CLIENTID\": \"2puJ\", //青龙2,9 OpenApi Client Secret \"QL_SECRET\": \"lEfJqbe2OKG\", //CK最大数量 \"QL_CAPACITY\": 40, \"QRurl\": \"\" } ] } clientid与secret获取方式如下图： ","date":"2021-11-07","objectID":"/jd%E7%AD%BE%E5%88%B0%E9%83%A8%E7%BD%B2%E8%87%AA%E5%8A%A8ck%E6%9C%8D%E5%8A%A1/:1:3","tags":null,"title":"JD签到部署自动CK服务","uri":"/jd%E7%AD%BE%E5%88%B0%E9%83%A8%E7%BD%B2%E8%87%AA%E5%8A%A8ck%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"4、启动NVJDC # Docker启动命令 docker run --name nolanjdc -p 5679:80 -d -v /userdatas/Sandisk/jd/nolanjdc/Config.json:/app/Config/Config.json:ro -v /userdatas/Sandisk/jd/nolanjdc/.local-chromium:/app/.local-chromium --link=qinglong:ql -itd --privileged=true nolanhzy/nvjdc:0.5 # 启动完成后使用以下命令查看输出日志 docker logs -f nolanjdc 转载自：https://6b7.org/391.html 参考：https://www.kejiwanjia.com/jiaocheng/32627.html ","date":"2021-11-07","objectID":"/jd%E7%AD%BE%E5%88%B0%E9%83%A8%E7%BD%B2%E8%87%AA%E5%8A%A8ck%E6%9C%8D%E5%8A%A1/:1:4","tags":null,"title":"JD签到部署自动CK服务","uri":"/jd%E7%AD%BE%E5%88%B0%E9%83%A8%E7%BD%B2%E8%87%AA%E5%8A%A8ck%E6%9C%8D%E5%8A%A1/"},{"categories":["Python"],"content":"转载自：https://binbla.com/?p=339 import asyncio import logging import socks import telethon.tl.types from aiofile import AIOFile, Writer from telethon import TelegramClient, events from telethon.tl.types import PeerChannel \"\"\" -\u003e 这是一个Telegram机器人项目 -\u003e 实现的功能：爬取Telegram中频道的图片 -\u003e 注意：由于机器人无法加入其他人的频道，所以扒频道的图只能交给主体账户来进行（不会影响主账户的登录） \"\"\" # 网友反馈：申请需要填个人网站，应该是随便填一个能正常访问的网址就行 # your telegram api id api_id = xxxxxxx # your telegram api hash api_hash = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxx' # get form https://my.telegram.org/apps # your chat id admin_id = xxxxxxxx # get from https://telegram.me/getidsbot # 暂时不用填 # your bot_token bot_token = 'xxxxxxxxxxxxxxxxxxxxxxxxxxx' # get from https://telegram.me/botfather # file save path save_path = '/home/admin/Telegram/' # proxy proxy_type = socks.SOCKS5 proxy_addr = 'localhost' proxy_port = 20170 # 要监视下载的频道,名字（键名）无实际代码作用，不要重复就行 channel = { \"少女情怀总是诗\": 1336617732, \"咸鱼的杂货铺 ASWL\": 1445018107, \"白丝即正义\": 1088679595, \"For world|精选|收集器\": 1109579085, \"奇闻异录 与 沙雕时刻\": 1214996122 } # 接受监视的媒体格式(tg里面直接发送gif最后是mp4格式！) accept_file_format = [\"image/jpeg\", \"image/gif\", \"image/png\"] # Mirai机器人插件的地址和端口 target_addr = \"localhost\" target_port = 13131 # bot登陆：留作将来开发控制程序 # bot = TelegramClient('transferBot', api_id, api_hash, proxy=(proxy_type, proxy_addr, proxy_port)).start( # bot_token=bot_token).start() # 用户登陆 client = TelegramClient('transfer', api_id, api_hash, proxy=(proxy_type, proxy_addr, proxy_port)).start() # client = TelegramClient('transfer', api_id, api_hash).start() # 列表推导式 获取频道对象列表 channel_list = [PeerChannel(channel[channel_name]) for channel_name in channel] # 过滤出监视下载的频道，如果有媒体消息就下载 @client.on(events.NewMessage(from_users=channel_list)) async def event_handler(event): # 获取对话 # chat = await event.get_chat() # 获取message内容 message = event.message # 判断是否有媒体 if message.media is not None: print(\"发现媒体\") await download_image(message) # 下载媒体的具体方法 async def download_image(message): # 如果是网页 is_webpage = isinstance(message.media,telethon.tl.types.MessageMediaWebPage) # 如果媒体是照片则直接下载 is_photo = isinstance(message.media, telethon.tl.types.MessageMediaPhoto) # 如果媒体是文件则检查是否是可接受的文件格式，这里用的否定表达，不好读！建议跳过或者自己写一个 is_doc = isinstance(message.media, telethon.tl.types.MessageMediaDocument) if not (is_photo or is_webpage): if is_doc: is_accept_media = message.media.document.mime_type in accept_file_format if not is_accept_media: print(\"不可接受\") return # 这里由于download_media()可以自动命名 # 所以，判断重复有点难搞，不过频道应该不怎么发重复内容 # 那就这样吧!不写了 # if os.path.exists(filename): # print(\"文件已存在\") # return # 这个方法下载成功后会返回文件的保存名 filename = await client.download_media(message, save_path) if filename is None: print(\"下载失败\") return print(\"下载完成\") # 下面注释的代码不知道什么原因无法在文件不存在的情况下新建文件 # async with async_open(save_path + \"1.txt\", \"a\") as f: # await f.write(filename + \"\\n\") print(message.sender.id,message.raw_text) # 通知mirai机器人干活，没有mirai机器人就注释下下面一行代码 await send_to_mirai(message.sender.id,message.sender.title, message.raw_text, filename) #socket通信通知QQ机器人（机器人插件见另一篇） async def send_to_mirai(from_id, from_title, raw_text, filename): msg = str(from_id)+\"\\t\"+filename+\"\\t\"+from_title+\"\\t\"+raw_text try: reader, writer = await asyncio.open_connection(target_addr, target_port) writer.write(msg.encode(\"utf-8\")) writer.close() print(\"已通知mirai干活\") print(\"-----*****-----\") except Exception as e: print(e) print('socket通信失败！') await write_to_list(msg) async def write_to_list(msg): async with AIOFile(save_path + \"unprocessed_list.txt\", \"a\") as list_file: write = Writer(list_file) await write(msg + \"\\n\") print(msg) print(\"写入列表\") print(\"-----*****-----\") async def bot_main(): pass # 展示登陆的信息 def show_my_inf(me): print(\"-----****************-----\") print(\"Name:\", me.username) print(\"ID:\", me.id) print(\"-----login successful-----\") async def client_main(): print(\"-client-main-\") me = await client.get_me() show_my_inf(me) # 这个方法是一直连着直到断开，我没有写断开的代码，所以程序应该会一直运行 await client.run_until_disconnected() # 日志，这个是文档里建议使用的，但是我没有实际使用上 logging.basicConfig(format='[%(debug) 5s/%(asctime)s] %(name)s: %(message)s', level=logging.W","date":"2021-11-05","objectID":"/python%E7%88%AC%E5%8F%96tg%E9%A2%91%E9%81%93%E5%9B%BE%E7%89%87/:0:0","tags":["Python","Telegram"],"title":"Python爬取TG频道图片","uri":"/python%E7%88%AC%E5%8F%96tg%E9%A2%91%E9%81%93%E5%9B%BE%E7%89%87/"},{"categories":null,"content":"requests 来源：https://stackoverflow.com/a/22974646 简言之, files参数takes a dictionary with the key being the name of the form field and the value being either a string or a 2, 3 or 4-length tuple, as described in the section POST a Multipart-Encoded File in the Requests quickstart: url = 'http://httpbin.org/post' files = {'file': ('report.xls', open('report.xls', 'rb'), 'application/vnd.ms-excel', {'Expires': '0'})} 上面的tuple解析（压缩）成: tuple(filename, data, content_type, headers) 如果files的值仅仅是字符串, 那么文件名将与键名相同: files = {'obvius_session_id': '72c2b6f406cdabd578c5fd7598557c52'} Content-Disposition: form-data; name=\"obvius_session_id\"; filename=\"obvius_session_id\" Content-Type: application/octet-stream 如果值是tuple且第一个值是None,那么filename属性将不会被包含: files = {'obvius_session_id': (None, '72c2b6f406cdabd578c5fd7598557c52')} Content-Disposition: form-data; name=\"obvius_session_id\" Content-Type: application/octet-stream ","date":"2021-11-05","objectID":"/python%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/:1:0","tags":null,"title":"Python上传文件","uri":"/python%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"aiohttp 来源：https://www.cnblogs.com/lianzhilei/p/10126349.html ","date":"2021-11-05","objectID":"/python%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/:2:0","tags":null,"title":"Python上传文件","uri":"/python%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"① 单个文件上传 服务端 async def post(self, request): reader = await request.multipart() # /!\\ 不要忘了这步。（至于为什么请搜索 Python 生成器/异步）/!\\ file = await reader.next() filename = file.filename # 如果是分块传输的，别用Content-Length做判断。 size = 0 with open(filename, 'wb') as f: while True: chunk = await file.read_chunk() # 默认是8192个字节。 if not chunk: break size += len(chunk) f.write(chunk) return web.Response(text='{} sized of {} successfully stored' ''.format(filename, size)) 客户端 import aiohttp import asyncio url = 'http://127.0.0.1:8080/' files = {'file': open('files/1M.wav', 'rb'),} async def fetch(session, url): async with session.post(url,data=files) as response: return await response.text() async def main(): async with aiohttp.ClientSession() as session: html = await fetch(session, 'http://127.0.0.1:8080') print(html) loop = asyncio.get_event_loop() loop.run_until_complete(main()) ","date":"2021-11-05","objectID":"/python%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/:2:1","tags":null,"title":"Python上传文件","uri":"/python%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"② 传输多个文件及其他参数 服务端 async def post(self, request): reader = await request.multipart() data = {} async for read in reader: filename = read.filename if filename is not None: size = 0 with open('./' + filename, 'wb') as f: while True: chunk = await read.read_chunk() # 默认是8192个字节。 if not chunk: break size += len(chunk) f.write(chunk) else: value = await read.next() key = read.name data[key] = str(value, encoding='utf-8') print(data) return web.Response() 客户端 import aiohttp import asyncio url = 'http://127.0.0.1:8080/' files = {'file': open('files/1M.wav', 'rb'), 'file2': open('files/0.5M.wav', 'rb'), 'name':'000001', } async def fetch(session, url): async with session.post(url,data=files) as response: return await response.text() async def main(): async with aiohttp.ClientSession() as session: html = await fetch(session, 'http://127.0.0.1:8080') print(html) loop = asyncio.get_event_loop() loop.run_until_complete(main()) ","date":"2021-11-05","objectID":"/python%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/:2:2","tags":null,"title":"Python上传文件","uri":"/python%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"},{"categories":["LeanCloud"],"content":"新建表与添加记录 import leancloud leancloud.init(\"AppID\", \"AppKey\") # 或者使用 Master Key # leancloud.init(\"AppID-gzGzoHsz\", master_key=\"master_key\") # 新建表 tableObject = leancloud.Object.extend('表名') # 新建表 tableObject = tableObject() # 增加一条记录 x = tableObject.set({'a':[{'a':1}],'b':'randombg'}) x.add('abc','dddd')#在此行末尾新增字段，待实验 # 提交到服务器 tableObject.save() ","date":"2021-11-04","objectID":"/leancloud%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/:1:0","tags":["LeanCloud","Python"],"title":"LeanCloud数据库操作","uri":"/leancloud%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"},{"categories":["LeanCloud"],"content":"条件查询表格 # 查询表 query = leancloud.Query('RandomBG') # 这里也可以直接传递一个 Class 名字的字符串作为构造参数 # 方法一：返回唯一值 result = query.get('61833be7cf725328f0274093') print(result.dump()) # 返回唯一记录的dict对象值 print(result.get('wallhaven')) # 查询返回唯一记录的某个字段值 result.set('wallhaven',[{'abc':333}]) # 对唯一返回进行修改 result.save() # 对唯一返回进行修改 # 方法二：返回所有值 reslut = query.find() for i in reslut: i.set('wallhaven',[{'333':333}]) i.save() ","date":"2021-11-04","objectID":"/leancloud%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/:2:0","tags":["LeanCloud","Python"],"title":"LeanCloud数据库操作","uri":"/leancloud%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"},{"categories":null,"content":"转载自：https://blog.csdn.net/thewindkee/article/details/80668974 Chrome 浏览器 地址栏中输入 chrome://net-internals/#hsts 在 Delete domain security policies 中输入项目的域名，并 Delete 删除 可以在 Query domain 测试是否删除成功 这里如果还是不行， 请清除浏览器缓存！ 参考文章 :如何关闭浏览器的HSTS功能 Safari 浏览器 完全关闭 Safari 删除 ~/Library/Cookies/HSTS.plist 这个文件 重新打开 Safari 即可 极少数情况下，需要重启系统 Opera 浏览器 和 Chrome 方法一样 Firefox 浏览器 关闭所有已打开的页面 清空历史记录和缓存 地址栏输入 about:permissions 搜索项目域名，并点击 Forget About This Site ","date":"2021-11-03","objectID":"/%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2chrome%E6%B5%8F%E8%A7%88%E5%99%A8http%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%88%90https/:0:0","tags":null,"title":"如何禁止chrome浏览器http自动转成https","uri":"/%E5%A6%82%E4%BD%95%E7%A6%81%E6%AD%A2chrome%E6%B5%8F%E8%A7%88%E5%99%A8http%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%88%90https/"},{"categories":["FastAPI"],"content":"https://stackoverflow.com/a/67497103 网上查找的方法都是使用fastapi的streamresponse方法来返回图，直到看到这个文章，才发现streamresponse方法是个坑 ","date":"2021-11-02","objectID":"/fastapi%E8%BF%94%E5%9B%9E%E5%9B%BE%E7%89%87%E8%B8%A9%E5%9D%91/:0:0","tags":null,"title":"FastAPI返回图片踩坑","uri":"/fastapi%E8%BF%94%E5%9B%9E%E5%9B%BE%E7%89%87%E8%B8%A9%E5%9D%91/"},{"categories":null,"content":" winform.treeview.insertItem( { \"text\" : '根目录一'; { \"text\": '一级目录名', {\"text\": '二级目录名','something':'value'}; {\"text\": '二级目录名','something':'value'}; } { \"text\": '一级目录名', {\"text\": '二级目录名','something':'value'}; {\"text\": '二级目录名','something':'value'}; } { \"text\": '一级节点名','something':'value', } }) winform.treeview.insertItem( { \"text\" : '根目录二'; { \"text\": '一级目录名', {\"text\": '二级目录名','something':'value'}; {\"text\": '二级目录名','something':'value'}; } { \"text\": '一级目录名', {\"text\": '二级目录名','something':'value'}; {\"text\": '二级目录名','something':'value'}; } { \"text\": '一级节点名','something':'value', } } ) ","date":"2021-10-30","objectID":"/aardio%E8%AF%AD%E8%A8%80%E4%B8%ADtreeview%E7%BB%91%E5%AE%9A%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/:0:0","tags":null,"title":"Aardio语言中Treeview绑定数据格式","uri":"/aardio%E8%AF%AD%E8%A8%80%E4%B8%ADtreeview%E7%BB%91%E5%AE%9A%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"},{"categories":["Aardio"],"content":"官方文档参考： https://www.kancloud.cn/ymk18/aau/130355 https://www.kancloud.cn/ymk18/aau/130327 ","date":"2021-10-28","objectID":"/aardio%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%B8%A6%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E7%A8%8B%E5%BA%8F%E5%B9%B6%E9%9A%90%E8%97%8F%E7%AA%97%E5%8F%A3/:0:0","tags":null,"title":"Aardio语言中带参数调用第三方程序，并隐藏窗口","uri":"/aardio%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%B8%A6%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E7%A8%8B%E5%BA%8F%E5%B9%B6%E9%9A%90%E8%97%8F%E7%AA%97%E5%8F%A3/"},{"categories":["Aardio"],"content":" import console; import web.rest.jsonLiteClient; import web.json; var restClient = web.rest.jsonLiteClient(); /* web.rest客户端对象所以执行HTTP请求的函数遵守以下规则： 如果成功，则第一个返回值jsonData为服务端返回数据解码并创建的aardio对象。 在HTTP请求遇到错误时，第一个返回值jsonData为空，第二个返回值errMsg为错误信息,返回值errCode为错误代码 一般我们可以省略errMsg，errCode这两个返回值不用写，直接判断返回值是否为空即可。 */ restClient.addHeaders = { [\"Test\"] = \"test\" } var jsonData,errMsg,errCode = restClient.post(\"http://eu.httpbin.org/post\",{ 用户名 = \"用户名\"; 密码 = \"密码\"; } ) //jsonData非空为请求成功 if( jsonData ){ console.log(jsonData[\"url\"]); //提取返回字典中对应键的值 } else { /* 出错了，如果restClient.lastStatusCode非空则说明服务端返回了HTTP状态代码 */ if( restClient.lastStatusCode ){ console.log( restClient.lastStatusMessage() ) //查看该状态码的说明 restClient.lastResponse() //输出服务端最后返回的信息 } else { //这通常是没有成功发送请求，在请求到达服务器以前就出错了 console.log(\"HTTP请求遇到错误,WinInet错误代码：\",errCode ) console.log(\"关于WinInet错误代码的详细说明：http://support.microsoft.com/kb/193625 \") } } console.pause(true); ","date":"2021-10-28","objectID":"/aardio%E8%AF%AD%E8%A8%80%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/:0:0","tags":null,"title":"Aardio语言中进行网络请求","uri":"/aardio%E8%AF%AD%E8%A8%80%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"},{"categories":["Aardio"],"content":"带参数GET请求 import web.rest.jsonLiteClient; var http = web.rest.jsonLiteClient() http.referer = \"https://item.jd.com/\" var jdClub = http.api(\"https://club.jd.com/comment/productPageComments.action?callback=fetchJSON_comment98vv13283\") var data = jdClub.get( productId=\"100004253893\"; // 商品编号 sortType=6; // 5表示推荐排序,6为按时间排序 isShadowSku=0; // 仅显示当前商品评论 score=3; // 好评 page=1; // 分页索引 pageSize=10; fold=1; rid=0; ) ","date":"2021-10-28","objectID":"/aardio%E8%AF%AD%E8%A8%80%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/:1:0","tags":null,"title":"Aardio语言中进行网络请求","uri":"/aardio%E8%AF%AD%E8%A8%80%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"},{"categories":["Aardio"],"content":" import console; import crypt.bin; import crypt.aes; //创建AES加密算法容器 var aes = crypt.aes(); //设置密钥(最大32个字节) aes.setPassword(\"panda\u0026beta#12345\"); //设置模式 aes.setKeyParamMode(2/*_CRYPT_MODE_ECB*/); var encrypt_str = \"53zlG1UPM3fHdW4rbD8gEGf3MoOlgNFnypUvM9y2sKM=\"; //BASE64编码加密结果 //console.log( crypt.bin.encodeBase64( str ) ); //AES加密字符——\u003eBASE64字符 base64str = crypt.bin.decodeBase64(encrypt_str); //BASE64字符——\u003e普通字符 decrypt_str = aes.decrypt(base64str); console.log(decrypt_str); console.pause(true); ","date":"2021-10-28","objectID":"/aardio%E8%AF%AD%E8%A8%80%E4%B8%AD%E8%BF%9B%E8%A1%8Caes%E7%AE%97%E6%B3%95%E5%8A%A0%E8%A7%A3%E5%AF%86/:0:0","tags":null,"title":"Aardio语言中进行AES算法加解密","uri":"/aardio%E8%AF%AD%E8%A8%80%E4%B8%AD%E8%BF%9B%E8%A1%8Caes%E7%AE%97%E6%B3%95%E5%8A%A0%E8%A7%A3%E5%AF%86/"},{"categories":["逆向"],"content":"转载自：https://blog.csdn.net/djzhao627/article/details/108658332 ","date":"2021-10-28","objectID":"/%E6%90%AD%E5%BB%BAandroid-7.0-%E4%B8%8B%E7%9A%84https%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83/:0:0","tags":["抓包","Https","逆向","APP"],"title":"搭建Android 7.0+下的HTTPS抓包环境","uri":"/%E6%90%AD%E5%BB%BAandroid-7.0-%E4%B8%8B%E7%9A%84https%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83/"},{"categories":["逆向"],"content":"准备 ","date":"2021-10-28","objectID":"/%E6%90%AD%E5%BB%BAandroid-7.0-%E4%B8%8B%E7%9A%84https%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83/:1:0","tags":["抓包","Https","逆向","APP"],"title":"搭建Android 7.0+下的HTTPS抓包环境","uri":"/%E6%90%AD%E5%BB%BAandroid-7.0-%E4%B8%8B%E7%9A%84https%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83/"},{"categories":["逆向"],"content":"一台已root的手机 ","date":"2021-10-28","objectID":"/%E6%90%AD%E5%BB%BAandroid-7.0-%E4%B8%8B%E7%9A%84https%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83/:1:1","tags":["抓包","Https","逆向","APP"],"title":"搭建Android 7.0+下的HTTPS抓包环境","uri":"/%E6%90%AD%E5%BB%BAandroid-7.0-%E4%B8%8B%E7%9A%84https%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83/"},{"categories":["逆向"],"content":"安装Openssl 下载地址：https://slproweb.com/products/Win32OpenSSL.html 安装完毕后将openssl.exe所在目录放入环境变量中，否则下面的openssl指令前需要加绝对路径。 ","date":"2021-10-28","objectID":"/%E6%90%AD%E5%BB%BAandroid-7.0-%E4%B8%8B%E7%9A%84https%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83/:1:2","tags":["抓包","Https","逆向","APP"],"title":"搭建Android 7.0+下的HTTPS抓包环境","uri":"/%E6%90%AD%E5%BB%BAandroid-7.0-%E4%B8%8B%E7%9A%84https%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83/"},{"categories":["逆向"],"content":"证书生成 将Filddler或者其他抓包程序的证书导出，一般为xxx.cer或者xxx.pem 使用openssl的x509指令进行cer证书转pem证书 和 用md5方式显示pem证书的hash值 证书转换，已经是pem格式的证书不需要执行这一步 openssl x509 -inform DER -in xxx.cer -out cacert.pem ","date":"2021-10-28","objectID":"/%E6%90%AD%E5%BB%BAandroid-7.0-%E4%B8%8B%E7%9A%84https%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83/:2:0","tags":["抓包","Https","逆向","APP"],"title":"搭建Android 7.0+下的HTTPS抓包环境","uri":"/%E6%90%AD%E5%BB%BAandroid-7.0-%E4%B8%8B%E7%9A%84https%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83/"},{"categories":["逆向"],"content":"获取证书MD5的hash显示 查看openssl版本的指令openssl version #openssl版本在1.0以上的版本的执行这一句 openssl x509 -inform PEM -subject_hash_old -in cacert.pem #openssl版本在1.0以下的版本的执行这一句 openssl x509 -inform PEM -subject_hash -in cacert.pem 将第二条指令输出的类似347bacb5的值进行复制 ","date":"2021-10-28","objectID":"/%E6%90%AD%E5%BB%BAandroid-7.0-%E4%B8%8B%E7%9A%84https%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83/:3:0","tags":["抓包","Https","逆向","APP"],"title":"搭建Android 7.0+下的HTTPS抓包环境","uri":"/%E6%90%AD%E5%BB%BAandroid-7.0-%E4%B8%8B%E7%9A%84https%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83/"},{"categories":["逆向"],"content":"将pem证书重命名 使用上面复制的值（类似于347bacb5）对pem证书进行重命名 mv cacert.pem 347bacb5.0 ","date":"2021-10-28","objectID":"/%E6%90%AD%E5%BB%BAandroid-7.0-%E4%B8%8B%E7%9A%84https%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83/:4:0","tags":["抓包","Https","逆向","APP"],"title":"搭建Android 7.0+下的HTTPS抓包环境","uri":"/%E6%90%AD%E5%BB%BAandroid-7.0-%E4%B8%8B%E7%9A%84https%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83/"},{"categories":["逆向"],"content":"将新证书放入手机系统证书目录并设置权限 手机系统目录位置是： /system/etc/security/cacerts 需要拷贝至此目录必须拥有root权限 修改证书的权限为644，可查看同目录下其他证书权限，照抄设置 ","date":"2021-10-28","objectID":"/%E6%90%AD%E5%BB%BAandroid-7.0-%E4%B8%8B%E7%9A%84https%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83/:5:0","tags":["抓包","Https","逆向","APP"],"title":"搭建Android 7.0+下的HTTPS抓包环境","uri":"/%E6%90%AD%E5%BB%BAandroid-7.0-%E4%B8%8B%E7%9A%84https%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83/"},{"categories":["逆向"],"content":"重启Android设备以生效 拷贝证书至/system/etc/security/cacerts之后，重启手机就可以使证书生效了 ","date":"2021-10-28","objectID":"/%E6%90%AD%E5%BB%BAandroid-7.0-%E4%B8%8B%E7%9A%84https%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83/:6:0","tags":["抓包","Https","逆向","APP"],"title":"搭建Android 7.0+下的HTTPS抓包环境","uri":"/%E6%90%AD%E5%BB%BAandroid-7.0-%E4%B8%8B%E7%9A%84https%E6%8A%93%E5%8C%85%E7%8E%AF%E5%A2%83/"},{"categories":["FastAPI"],"content":"FastAPI是一个非常好用的web框架,今天我要介绍的是它直接使用请求和响应的方法. 有些时候,我们不能确定客户端的参数,这时候,我们可以直接使用请求和响应,可以获取到更底层的一些信息,已经不确定的参数. https://www.starlette.io/responses/ ","date":"2021-10-20","objectID":"/fastapi%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:0:0","tags":["Python","FastAPI"],"title":"FastAPI直接使用请求与响应","uri":"/fastapi%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["FastAPI"],"content":"1. 请求 众所周知,fastapi站在巨人的肩膀上,其中,请求和和响应部分来自于starlette.这里给出官网对请求解释的部分. 当我们使用fastapi时,可以声明一个类型为starlette.request.Request类型的参数,他将接受原始的请求对象: import uvicorn from fastapi import FastAPI from starlette.requests import Request app=FastAPI() @app.get(\"/\") def func(request:Request): print(request.headers) return request.headers if __name__ == '__main__': uvicorn.run(app=\"main:app\", host=\"127.0.0.1\", port=8080, reload=True, debug=True) 请求对象支持的操作: request.cookies:cookie request.query_params:查询参数 request.url:url对象 request.headers:请求头 async def request.form():获取表单信息,注意这是一个异步函数. async def request.json():获取json信息,这两个只能用一个,这也是一个异步函数. async def request.body():直接获取body数据,未经过转换 ","date":"2021-10-20","objectID":"/fastapi%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:1:0","tags":["Python","FastAPI"],"title":"FastAPI直接使用请求与响应","uri":"/fastapi%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["FastAPI"],"content":"2.响应 可以从官网对响应的解释上看到全部内容. 有很多种响应,包括: Response(content:str,statuc_code:int=200,headers:dict=None,media_type):基本的响应 RedirectResponse(url,status_code,headers):重定向到url FileResponse(path,status_code,media_type):文件响应,path为本地文件路径,需要安装aiofiles库才可以使用. StreamingResponse(data,media_type):流响应,支持一个可迭代对象(包括文件和BytesIO,StringIO等类文件对象) 直接返回即可,关于StreamingResponse还有一篇文章,讲述了如何利用它传输文件. import uvicorn from fastapi import FastAPI from starlette.responses import JSONResponse app=FastAPI() @app.get(\"/\") def func(): ss = { \"_id\": \"616fc0d46da5004b0f738538\", \"id\": 606, \"name\": \"李三\", \"raw_resp\": { \"meta\": { \"deviceType\": \"ANDROID\", \"deviceName\": \"Android 5.1.1 SDK 22 OnePlus HD1910\", \"expiredTime\": \"2031-10-27T02:02:46Z\", } }, \"time\": \"2021年10月20日 07:10\" } response = JSONResponse(ss, headers={\"media_type\":'text/plain'}) return response if __name__ == '__main__': uvicorn.run(app=\"main:app\", host=\"127.0.0.1\", port=8080, reload=True, debug=True) 更多方法参考：https://www.pythonf.cn/read/142674 ","date":"2021-10-20","objectID":"/fastapi%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:2:0","tags":["Python","FastAPI"],"title":"FastAPI直接使用请求与响应","uri":"/fastapi%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["FastAPI"],"content":"读取请求头中某个参数： from fastapi import FastAPI, Header app = FastAPI() @app.get(\"/items/\") async def read_items(user_agent: Optional[str] = Header(None),Authorization: Optional[str] = Header(None)): return {\"User-Agent\": user_agent,'Authorization':Authorization} 上面例子读取了请求头中user_agent和Authorization两个参数，然后作为响应体（json字典类型）返回了。 ","date":"2021-10-20","objectID":"/fastapi%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:3:0","tags":["Python","FastAPI"],"title":"FastAPI直接使用请求与响应","uri":"/fastapi%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["FastAPI"],"content":"读取Cookies from typing import Optional from fastapi import Cookie, FastAPI app = FastAPI() @app.get(\"/items/\") async def read_items(ads_id: Optional[str] = Cookie(None)): return {\"ads_id\": ads_id} ","date":"2021-10-20","objectID":"/fastapi%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:4:0","tags":["Python","FastAPI"],"title":"FastAPI直接使用请求与响应","uri":"/fastapi%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["FastAPI"],"content":"响应头设置 拜见：https://www.cnblogs.com/poloyy/p/15366453.html ","date":"2021-10-20","objectID":"/fastapi%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/:5:0","tags":["Python","FastAPI"],"title":"FastAPI直接使用请求与响应","uri":"/fastapi%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/"},{"categories":["FastAPI"],"content":"官方说明：https://github.com/tiangolo/uvicorn-gunicorn-fastapi-docker/blob/master/README.md ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:0:0","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["FastAPI"],"content":"环境变量 有多个环境变量可供设置，如果不指定，则会使用默认值。 ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:1:0","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["FastAPI"],"content":"MODULE_NAME——指定要运行的主文件文件名（Python中也叫模块名） Python “module” (文件) Gunicorn, this module would contain the actual application in a variable. 默认为: app.main——如果主文件路径为 /app/app/main.py 或者 main——如果主文件路径为 /app/main.py 打个比方, 如果主文件路径为 /app/custom_app/custom_main.py, 那么你需要设置成这样: docker run -d -p 80:80 -e MODULE_NAME=\"custom_app.custom_main\" myimage ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:1:1","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["FastAPI"],"content":"VARIABLE_NAME——指定主文件中FastAPI()对象的变量名称 默认是: app 举个例子, 如果你的主文件是这样的: from fastapi import FastAPI api = FastAPI() @api.get(\"/\") def read_root(): return {\"message\": \"Hello world!\"} 在上面的例子中,FastAPI()对象的变量名为api ，那么你需要这样设置: docker run -d -p 80:80 -e VARIABLE_NAME=\"api\" myimage ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:1:2","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["FastAPI"],"content":"APP_MODULE——这个环境变量可以直接实现上面两个环境变量的作用 docker run -d -p 80:80 -e APP_MODULE=\"custom_app.custom_main:api\" myimage ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:1:3","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["FastAPI"],"content":"GUNICORN_CONF——指定GUNICORN配置文件路径 默认为: /app/gunicorn_conf.py 如果在该路径存在则使用此处的 /app/app/gunicorn_conf.py 如果在该路径存在则使用此处的 /gunicorn_conf.py (容器作者在此处放入了默认配置文件) 你可以这样设置: docker run -d -p 80:80 -e GUNICORN_CONF=\"/app/custom_gunicorn_conf.py\" myimage You can use the config file from this image as a starting point for yours. ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:1:4","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["FastAPI"],"content":"WORKERS_PER_CORE——指定每个CPU核心的线程数 This image will check how many CPU cores are available in the current server running your container. It will set the number of workers to the number of CPU cores multiplied by this value. 默认为: 1 你可以这样设置: docker run -d -p 80:80 -e WORKERS_PER_CORE=\"3\" myimage If you used the value 3 in a server with 2 CPU cores, it would run 6 worker processes. You can use floating point values too. So, for example, if you have a big server (let’s say, with 8 CPU cores) running several applications, and you have an ASGI application that you know won’t need high performance. And you don’t want to waste server resources. You could make it use 0.5 workers per CPU core. For example: docker run -d -p 80:80 -e WORKERS_PER_CORE=\"0.5\" myimage In a server with 8 CPU cores, this would make it start only 4 worker processes. Note: 默认为, if WORKERS_PER_CORE is 1 and the server has only 1 CPU core, instead of starting 1 single worker, it will start 2. This is to avoid bad performance and blocking applications (server application) on small machines (server machine/cloud/etc). This can be overridden using WEB_CONCURRENCY. ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:1:5","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["FastAPI"],"content":"MAX_WORKERS Set the maximum number of workers to use. You can use it to let the image compute the number of workers automatically but making sure it’s limited to a maximum. This can be useful, for example, if each worker uses a database connection and your database has a maximum limit of open connections. 默认为 it’s not set, meaning that it’s unlimited. 你可以这样设置: docker run -d -p 80:80 -e MAX_WORKERS=\"24\" myimage This would make the image start at most 24 workers, independent of how many CPU cores are available in the server. ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:1:6","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["FastAPI"],"content":"WEB_CONCURRENCY Override the automatic definition of number of workers. 默认为: Set to the number of CPU cores in the current server multiplied by the environment variable WORKERS_PER_CORE. So, in a server with 2 cores, 默认为 it will be set to 2. 你可以这样设置: docker run -d -p 80:80 -e WEB_CONCURRENCY=\"2\" myimage This would make the image start 2 worker processes, independent of how many CPU cores are available in the server. ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:1:7","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["FastAPI"],"content":"HOST——指定监听地址，可限制请求地址 The “host” used by Gunicorn, the IP where Gunicorn will listen for requests. It is the host inside of the container. 因此, 如果你设置成 127.0.0.1, 那么将只能在容器中访问FastAPI服务. 默认为: 0.0.0.0 ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:1:8","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["FastAPI"],"content":"PORT ——指定监听端口，貌似可以更改暴露端口，默认为80 The port the container should listen on. If you are running your container in a restrictive environment that forces you to use some specific port (like 8080) you can set it with this variable. 默认为: 80 你可以这样设置: docker run -d -p 80:8080 -e PORT=\"8080\" myimage ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:1:9","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["FastAPI"],"content":"BIND——直接实现上面两个参数的效果 The actual host and port passed to Gunicorn. 默认为, set based on the variables HOST and PORT. So, if you didn’t change anything, it will be set 默认为 to: 0.0.0.0:80 你可以这样设置: docker run -d -p 80:8080 -e BIND=\"0.0.0.0:8080\" myimage ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:1:10","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["FastAPI"],"content":"LOG_LEVEL——指定Gunicorn日志的级别 The log level for Gunicorn. One of: debug info warning error critical 默认为info. If you need to squeeze more performance sacrificing logging, set it to warning, for example: 你可以这样设置: docker run -d -p 80:8080 -e LOG_LEVEL=\"warning\" myimage ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:1:11","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["FastAPI"],"content":"WORKER_CLASS The class to be used by Gunicorn for the workers. 默认为, set to uvicorn.workers.UvicornWorker. The fact that it uses Uvicorn is what allows using ASGI applications like FastAPI and Starlette, and that is also what provides the maximum performance. You probably shouldn’t change it. But if for some reason you need to use the alternative Uvicorn worker: uvicorn.workers.UvicornH11Worker you can set it with this environment variable. 你可以这样设置: docker run -d -p 80:8080 -e WORKER_CLASS=\"uvicorn.workers.UvicornH11Worker\" myimage ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:1:12","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["FastAPI"],"content":"TIMEOUT——超时时间，默认为120. Workers silent for more than this many seconds are killed and restarted. Read more about it in the Gunicorn docs: timeout. Notice that Uvicorn and ASGI frameworks like FastAPI and Starlette are async, not sync. So it’s probably safe to have higher timeouts than for sync workers. 你可以这样设置: docker run -d -p 80:8080 -e TIMEOUT=\"20\" myimage ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:1:13","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["FastAPI"],"content":"KEEP_ALIVE——保持连接时间，默认为2. The number of seconds to wait for requests on a Keep-Alive connection. Read more about it in the Gunicorn docs: keepalive. 你可以这样设置: docker run -d -p 80:8080 -e KEEP_ALIVE=\"20\" myimage ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:1:14","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["FastAPI"],"content":"GRACEFUL_TIMEOUT Timeout for graceful workers restart. Read more about it in the Gunicorn docs: graceful-timeout. 默认为, set to 120. 你可以这样设置: docker run -d -p 80:8080 -e GRACEFUL_TIMEOUT=\"20\" myimage ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:1:15","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["FastAPI"],"content":"ACCESS_LOG——访问日志的记录方式和保存位置，默认为 \"-\"，输出到容器日志中。 如果你想禁用访问日志，将其设置为空值即可: docker run -d -p 80:8080 -e ACCESS_LOG= myimage ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:1:16","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["FastAPI"],"content":"ERROR_LOG——错误日志，默认为 \"-\"，输出到容器日志中。 如果你想禁用错误日志，将其设置为空值即可: docker run -d -p 80:8080 -e ERROR_LOG= myimage ","date":"2021-10-20","objectID":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/:1:17","tags":["Python","FastAPI"],"title":"FastAPI容器使用说明翻译","uri":"/fastapi%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"},{"categories":["Python"],"content":"修改数据库中的值 数据量小的情况下， 1.先全部查询find()； 2.清空数据库delete_many({}); 3.修改; 4.完毕后再插入数据库collection.insert_many(result, ordered=False)。 ","date":"2021-10-20","objectID":"/pymongo%E6%93%8D%E4%BD%9C/:1:0","tags":["Python","pymongo"],"title":"pymongo操作","uri":"/pymongo%E6%93%8D%E4%BD%9C/"},{"categories":["Python"],"content":"随机查询 with MongoClient(\"mongodb://local/?authSource=admin\") as client: c =client.DBs.collection # regx = re.compile(\".*?台湾|日本|香港|韩国|新加坡.*?\") r = c.aggregate( [ {\"$match\":# 筛选条件 {\"$text\":{ \"$search\": \"台湾|日本|香港|韩国|新加坡\" #建立相应字段索引后进行文本搜索 } } } , { \"$sample\": # 随机取样 { \"size\": 1 # 取样的数量 } } ] ) ","date":"2021-10-20","objectID":"/pymongo%E6%93%8D%E4%BD%9C/:2:0","tags":["Python","pymongo"],"title":"pymongo操作","uri":"/pymongo%E6%93%8D%E4%BD%9C/"},{"categories":["Hexo"],"content":"各大云函数对比 公有云 请求次数 运行时间 网络流量 免费数据库 东南亚区域 备注 AWS 100万 400,000 GB-秒 1GB 有 香港、东京、新加坡 Azure 100万 400,000 GB-秒 5GB 有 香港、韩国、日本、新加坡 存储帐户收费 Google Cloud 200万 400,000 GB-秒+200,000GHz 5GB 有 香港、台湾 国内无法访问 IBM Cloud 无限 400,000 GB-秒 不明 有 东京 阿里云 100万 400,000 CU-秒 无 无 中国、香港、东京、新加坡 腾讯云 100万 400,000 GB-秒 无 无 中国、香港、新加坡 百度云 100万 400,000 GB-秒 1GB 无 中国 华为云 100万 400,000 GB-秒 不明 无 中国、香港、泰国 LeanCloud 无限 18小时/天 1GB 有 中国 ","date":"2021-10-18","objectID":"/leancloud%E4%BA%91%E5%87%BD%E6%95%B0%E6%90%AD%E5%BB%BA%E9%9A%8F%E6%9C%BA%E5%9B%BE%E5%BA%8Aapi%E6%9C%8D%E5%8A%A1/:1:0","tags":null,"title":"云函数搭建随机图床API服务","uri":"/leancloud%E4%BA%91%E5%87%BD%E6%95%B0%E6%90%AD%E5%BB%BA%E9%9A%8F%E6%9C%BA%E5%9B%BE%E5%BA%8Aapi%E6%9C%8D%E5%8A%A1/"},{"categories":["Hexo"],"content":"踩坑腾讯云函数 因为图床需要用API来跳转返回图片真实地址，查了最新版腾讯云函数官方文档，已不再支持302跳转。 return { \"isBase64Encoded\": False, \"statusCode\": 302, \"headers\": {\"Location\": url} } https://service-mdz65i5g-1258124728.gz.apigw.tencentcs.com/release/ZiHuFenShen/feature/config 腾讯云函数302跳转实现方式参考：https://juejin.cn/post/6844903632089907214 同时此文通俗解释了腾讯云函数的集成响应与透传响应的区别，这里贴一下，以进行备份： 集成响应和透传响应 简单来说透传响应只会返回200状态码，将返回的内容作为消息体透传给前端，所以一般的返回json数据的函数调用可以直接使用此方式。 集成响应则可以自行定义返回的http状态码，消息头等等内容，我们这里是一个短网址的跳转，需要返回302或者301消息，所以必须使用集成响应的方式。 具体可以参见腾讯云官方文档的解释： 集成响应，是指 API 网关会将云函数的返回内容进行解析，并根据解析内容构造 HTTP 响应。 通过使用集成响应，可以通过代码自主控制响应的状态码、headers、body内容，可以实现自定义格式的内容响应，例如响应 XML、HTML、JSON 甚至 JS 内容。 在使用集成响应时，需要按照 API 网关触发器的集成响应返回数据结构，才可以被 API 网关成功解析，否则会出现 {“errno”:403,“error”:“Invalid scf response format. please check your scf response format.”} 错误信息。 透传响应，是指 API 网关将云函数的返回内容直接传递给API请求方。 通常这种响应的数据格式直接确定为JSON格式，状态码根据函数执行的状态定义，函数执行成功即为 200 状态码。 通过透传响应，用户可以自行获取到JSON格式后在调用位置解析结构，获取结构内的内容。 ","date":"2021-10-18","objectID":"/leancloud%E4%BA%91%E5%87%BD%E6%95%B0%E6%90%AD%E5%BB%BA%E9%9A%8F%E6%9C%BA%E5%9B%BE%E5%BA%8Aapi%E6%9C%8D%E5%8A%A1/:2:0","tags":null,"title":"云函数搭建随机图床API服务","uri":"/leancloud%E4%BA%91%E5%87%BD%E6%95%B0%E6%90%AD%E5%BB%BA%E9%9A%8F%E6%9C%BA%E5%9B%BE%E5%BA%8Aapi%E6%9C%8D%E5%8A%A1/"},{"categories":["Hexo"],"content":"LeanCloud ","date":"2021-10-18","objectID":"/leancloud%E4%BA%91%E5%87%BD%E6%95%B0%E6%90%AD%E5%BB%BA%E9%9A%8F%E6%9C%BA%E5%9B%BE%E5%BA%8Aapi%E6%9C%8D%E5%8A%A1/:3:0","tags":null,"title":"云函数搭建随机图床API服务","uri":"/leancloud%E4%BA%91%E5%87%BD%E6%95%B0%E6%90%AD%E5%BB%BA%E9%9A%8F%E6%9C%BA%E5%9B%BE%E5%BA%8Aapi%E6%9C%8D%E5%8A%A1/"},{"categories":["VPN"],"content":"分析通信过程 ","date":"2021-10-17","objectID":"/pandavpn%E5%90%8E%E7%AB%AF%E6%9B%BF%E6%8D%A2/:1:0","tags":["逆向","VPN"],"title":"PandaVPN后端替换与搭建","uri":"/pandavpn%E5%90%8E%E7%AB%AF%E6%9B%BF%E6%8D%A2/"},{"categories":["VPN"],"content":"一、节点组列表 明文返回json ","date":"2021-10-17","objectID":"/pandavpn%E5%90%8E%E7%AB%AF%E6%9B%BF%E6%8D%A2/:1:1","tags":["逆向","VPN"],"title":"PandaVPN后端替换与搭建","uri":"/pandavpn%E5%90%8E%E7%AB%AF%E6%9B%BF%E6%8D%A2/"},{"categories":["VPN"],"content":"二、单个节点详情——貌似只在服务端进行了校验 1、如果无会员，则返回： {\"code\": \"006\", \"message\": \"此线路仅供VIP用户使用，充值后可解锁所有线路\"} 2、如果是会员，则返回： { \"data\": \"HfLCVcZTDz3mPpjiMIkc0fPygfocLgd8hFFrsheQivFqY0AxxuOe/9ywApl9e/t9NIbxLVB02y5ewQpiX7szqXuHUyfG230WTk6lqfCRI5CBv6C1+oyDV/JkUM0JKgy4enCVPeLInJKtH9ZpTfumiiGkwFGKgnDemqvVlvKBDjri0w8IKzy4WVklJ5ai89ZxGwWsUz6qktiXeLuVlcx/3IOa1eLQP1yt/h2Fca5x4dA7l5Nu9SrDuRmIqIST8RttjkCt511TbI59O8DYZIwqQFmaVaSNQPuR29ukwlD6UFv6snn7nBy5lI/+hvnYc/dDhXrIEKPrVv5kWpeyvfth02C9ReovR/snIJ7yXfpeiX2UOnA35ZG7ptnYEVy1kVdQjamC0beTNWrGFMkKmYuEFRDh0BrtwVkGVqX50vO20ECiL3bEA7B6bylubN3672ZCugHfQRvgM5qfSRMm8GRXot7PBknH/Hz5LuFuEBXLPDsk++7q1FMYb1Kmomo4ioYHQNyv5ASLWVqx0Ock0cQ+DqKUDWKy912znEsYvaFtcL0nx3yiKNYOmwgPGPAx0kNN4RxO6JoPBMBBOl7WNQTlF/vt+ayA98ueHwtQy8DpAQLqSf4VGwHRMhzslIwRZrkSipqHee1pYkHVopZmCnHPRXplgSkJok/rXhtlv2qmPZsdMroA8vBxKRTLF2IlfJH0CsVwHgjjHN48GhLk/as6SGT9ujkY9Pxm+/8+adrOY/aLbZ52mxH9x3B7SVSXCq6Hmo00hJIbwzUHN2s8G8aRxhSoZDZqBgg2b9PLZiTW0LQHNRA5El7V1+ZmmpgDcscnRbuCRKdghEkUtkQ6go6FpZSa3wZQOBAvRy/GIBvEaw0SrMIg8w+8JkvU6ByseuDxqb+jwDd2c8LC5frT6e2QiwF3g60t7AUcrTyovmK4/iaKEkLBqKAPNqtw+1EbNMWFzt8EYm4ofJ2fVgUuDKPPas2DdaMgxVB5Dg085ikbhuXWdxnqieQkHu0gV3uuOk6f1P129pUq4fTPH3N9JiYmIAgotjT0utEmDqDQXYPbzYGyragxPhlCdLlXjAaiozF+\", \"meta\": { \"deviceType\": \"ANDROID\", \"smartModeAcl\": [ \"bypass-lan-china.acl\" ], \"deviceCount\": NumberInt(\"3\"), \"isReachMaxLimit\": false, \"lon\": \"103.82\", \"source\": \"CN\", \"deviceName\": \"Android 5.1.1 SDK 22 OnePlus HD1910\", \"expiredTime\": \"2031-10-27T02:02:46Z\", \"deviceToken\": \"424B267792EFCC60D5DAEA03C08E61CD\", \"target\": \"SG\", \"protocol\": \"SS\", \"activeDeviceCount\": NumberInt(\"1\"), \"qtRecommendedMode\": \"autoProxyConfigScript\", \"lat\": \"1.35\" } } ","date":"2021-10-17","objectID":"/pandavpn%E5%90%8E%E7%AB%AF%E6%9B%BF%E6%8D%A2/:1:2","tags":["逆向","VPN"],"title":"PandaVPN后端替换与搭建","uri":"/pandavpn%E5%90%8E%E7%AB%AF%E6%9B%BF%E6%8D%A2/"},{"categories":["VPN"],"content":"搭建后端 ","date":"2021-10-17","objectID":"/pandavpn%E5%90%8E%E7%AB%AF%E6%9B%BF%E6%8D%A2/:2:0","tags":["逆向","VPN"],"title":"PandaVPN后端替换与搭建","uri":"/pandavpn%E5%90%8E%E7%AB%AF%E6%9B%BF%E6%8D%A2/"},{"categories":["VPN"],"content":"云函数搭建后端 参见: https://coloraven.github.io/2021/10/使用腾讯云函数搭建简单API后端/ ","date":"2021-10-17","objectID":"/pandavpn%E5%90%8E%E7%AB%AF%E6%9B%BF%E6%8D%A2/:2:1","tags":["逆向","VPN"],"title":"PandaVPN后端替换与搭建","uri":"/pandavpn%E5%90%8E%E7%AB%AF%E6%9B%BF%E6%8D%A2/"},{"categories":["VPN"],"content":"自建服务器搭建后端 使用FastAPI-Docker 脚本文件名必须为main.py main.py里面的FastAPI()对象默认必须为app，即app=FastAPI()。 ","date":"2021-10-17","objectID":"/pandavpn%E5%90%8E%E7%AB%AF%E6%9B%BF%E6%8D%A2/:2:2","tags":["逆向","VPN"],"title":"PandaVPN后端替换与搭建","uri":"/pandavpn%E5%90%8E%E7%AB%AF%E6%9B%BF%E6%8D%A2/"},{"categories":["Python"],"content":"非flask等框架的云函数模板： 其入口函数为： main_handler(event,content) 该函数位于src目录下的index.py文件中。 其中event参数用来传递“腾讯整个云函数系统”传递过来的参数，event的值为(见https://cloud.tencent.com/document/product/583/12513)： { \"requestContext\": { \"serviceId\": \"service-f94sy04v\", \"path\": \"/test/{path}\", \"httpMethod\": \"POST\", \"requestId\": \"c6af9ac6-7b61-11e6-9a41-93e8deadbeef\", \"identity\": { \"secretId\": \"abdcdxxxxxxxsdfs\" }, \"sourceIp\": \"10.0.2.14\", \"stage\": \"release\" }, \"headers\": { \"accept-Language\": \"en-US,en,cn\", \"accept\": \"text/html,application/xml,application/json\", \"host\": \"service-3ei3tii4-251000691.ap-guangzhou.apigateway.myqloud.com\", \"user-Agent\": \"User Agent String\" }, \"body\": \"{\\\"test\\\":\\\"body\\\"}\", \"pathParameters\": { \"path\": \"value\" }, \"queryStringParameters\": { \"foo\": \"bar\" }, \"headerParameters\":{ \"Refer\": \"10.0.2.14\" }, \"stageVariables\": { \"stage\": \"release\" }, \"path\": \"/test/value\", \"queryString\": { \"foo\" : \"bar\", \"bob\" : \"alice\" }, \"httpMethod\": \"POST\" } ","date":"2021-10-16","objectID":"/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95api%E5%90%8E%E7%AB%AF/:0:0","tags":null,"title":"使用腾讯云函数搭建简单API后端","uri":"/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95api%E5%90%8E%E7%AB%AF/"},{"categories":["Python"],"content":"代码示例 # -*- coding: utf-8 -*- import sys import logging import json import hashlib import time def md5_convert(string): return hashlib.md5(string.encode('utf-8')).hexdigest() logging.basicConfig(level=logging.INFO, stream=sys.stdout) logger = logging.getLogger() logger.setLevel(level=logging.INFO) logger.info('加载函数') kami_resp = {\"result\":{\"msg\":\"恭喜你，超级VIP用户！用到官方倒闭为止。\"},\"ts\":int(round(time.time()*1000)),\"status\":1} normal_resp = {\"result\":{\"notice\":None,\"stat\":None,\"onlineDialog\":None,\"splash\":None,\"bind\":None,\"register\":{\"probationExt\":None,\"probation\":0,\"useText\":\"进入软件\",\"themeColor\":\"#ee00ee\",\"neutralText\":\"\",\"neutralActionType\":0,\"neutralExt\":\"\",\"cancelText\":\"\",\"cancelActionType\":0,\"cancelExt\":\"http://146.56.247.24:8002/liebiao/B6CB3C0D89FA2B14\",\"message\":\"欢迎使用\"},\"version\":None},\"ts\":int(round(time.time()*1000)),\"status\":1} def main_handler(event,content): logger.info('进入主函数') logger.info(event[\"path\"]) if event[\"path\"] == \"/ZiHuFenShen/feature/pack/verify\": # 验证卡密 return { \"isBase64Encoded\": False, \"statusCode\": 200, \"headers\": {\"Content-Type\": \"application/json;charset=UTF-8\", \"eagleid\": md5_convert(json.dumps(kami_resp, ensure_ascii=False)+'1')}, \"body\": json.dumps(kami_resp, ensure_ascii=False) } if event[\"path\"] == \"/ZiHuFenShen/feature/config\": # 验证其他 return { \"isBase64Encoded\": False, \"statusCode\": 200, \"headers\": {\"Content-Type\": \"application/json;charset=UTF-8\", \"eagleid\": md5_convert(json.dumps(normal_resp, ensure_ascii=False)+'1')}, \"body\": json.dumps(normal_resp, ensure_ascii=False) } if event[\"path\"] == \"/ZiHuFenShen/feature/302\": # 验证其他 return { \"isBase64Encoded\": False, \"statusCode\": 302, # \"headers\": {\"Content-Type\": \"application/json;charset=UTF-8\", \"eagleid\": md5_convert(json.dumps(normal_resp, ensure_ascii=False)+'1')}, \"body\": json.dumps(normal_resp, ensure_ascii=False) } ","date":"2021-10-16","objectID":"/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95api%E5%90%8E%E7%AB%AF/:1:0","tags":null,"title":"使用腾讯云函数搭建简单API后端","uri":"/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95api%E5%90%8E%E7%AB%AF/"},{"categories":["Docker"],"content":"脚本备份 【10.2】https://www.juan920.com/1125.html ql repo https://github.com/smiek2221/scripts.git \"jd_|gua_\" \"\" \"ZooFaker_Necklace.js|JDJRValidator_Pure.js|sign_graphics_validate.js\" 0 0 * * * 【混沌】 ql repo https://github.com/whyour/hundun.git \"quanx\" \"tokens|caiyun|didi|donate|fold|Env\" 0 0 * * * 【ddo（hyzaw）】 ql repo https://ghproxy.com/https://github.com/shufflewzc/hyzaw.git \"ddo_\" 0 0 * * * 【star】 ql repo https://github.com/star261/jd.git \"scripts\" \"code\" 0 0 * * * 【curtinlv仓库】 ql repo https://github.com/curtinlv/JD-Script.git 0 0 * * * 【Faker集合仓库】 ql repo https://ghproxy.com/https://github.com/shufflewzc/faker2.git \"jd_|jx_|getJDCookie\" \"activity|backUp\" \"^jd[^_]|USER|ZooFaker_Necklace\" 0 0 * * * 扫码获取京东cookie task Annyoo2021_scripts_main_getJDCookie.js 38 15 * * * 拉取脚本 ql repo https://github.com/smiek2221/scripts.git \"jd_|gua_\" \"\" \"ZooFaker_Necklace.js|JDJRValidator_Pure.js|sign_graphics_validate.js\" 0 0 * * * 【怨念集合仓库】 ql repo https://github.com/yuannian1112/jd_scripts.git \"jd_|jx_|getJDCookie\" \"activity|backUp\" \"^jd[^_]|USER|utils\" 0 0 * * * 更新面板 ql update 50 0 * * * 删除日志 ql rmlog 7 30 7 */7 * * ","date":"2021-10-13","objectID":"/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E4%BA%AC%E4%B8%9C%E7%AD%BE%E5%88%B0/:1:0","tags":["京东签到"],"title":"青龙面板京东签到","uri":"/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E4%BA%AC%E4%B8%9C%E7%AD%BE%E5%88%B0/"},{"categories":["Docker"],"content":"变量名称 京东Cookies环境变量名称：JD_COOKIE 青龙面板容器启动指令： docker run -dit \\ -v /userdatas/Sandisk/ql/config:/ql/config \\ -v /userdatas/Sandisk/ql/log:/ql/log \\ -v /userdatas/Sandisk/ql/db:/ql/db \\ -v /userdatas/Sandisk/ql/repo:/ql/repo \\ -v /userdatas/Sandisk/ql/raw:/ql/raw \\ -v /userdatas/Sandisk/ql/scripts:/ql/scripts \\ -v /userdatas/Sandisk/ql/jbot:/ql/jbot \\ -v /userdatas/Sandisk/ql/ninja:/ql/ninja \\ -p 5678:5700 \\ -p 6789:5701 \\ --name qinglong \\ --restart unless-stopped \\ whyour/qinglong:latest ","date":"2021-10-13","objectID":"/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E4%BA%AC%E4%B8%9C%E7%AD%BE%E5%88%B0/:2:0","tags":["京东签到"],"title":"青龙面板京东签到","uri":"/%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF%E4%BA%AC%E4%B8%9C%E7%AD%BE%E5%88%B0/"},{"categories":["Hexo"],"content":"大兄弟你进来一定不是看我废话的吧，嗯，安排上，咱用图和爬虫说话，这些网站真的很不错！ emm…顺便和想看详细解析的兄弟说一句，这里有个详细的样例， 爬虫爬取精美图片详介传送门 ","date":"2021-10-07","objectID":"/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B%E5%85%8D%E8%B4%B9%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%AB%99%E5%86%85%E9%99%84%E9%83%A8%E5%88%86%E7%88%AC%E8%99%AB%E4%BB%A3%E7%A0%81/:0:0","tags":null,"title":"【转载】一些免费图片下载网站（内附部分爬虫代码）","uri":"/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B%E5%85%8D%E8%B4%B9%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%AB%99%E5%86%85%E9%99%84%E9%83%A8%E5%88%86%E7%88%AC%E8%99%AB%E4%BB%A3%E7%A0%81/"},{"categories":["Hexo"],"content":"内容检索 1. hippopx * 2. colorhub * 3. pikrepo * 4. wallhaven * 5. 还有这些不错的网站 * * 5.1 pixabay * 5.2 ssyer * 5.3 不错的插画 * 5.4 visualhunt * 5.5 pexels * 5.6 unsplash * 5.7 极简壁纸 1. hippopx https://www.hippopx.com/ 嘘~悄悄附上爬虫代码： 非高清： #这里以爬取小猫图片为例，倘若兄弟想爬取其他的，改一下参数就成噢 from bs4 import BeautifulSoup import requests gHeads = { \"User-Agent\":\"Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36\" } for i in range(1,65): url = \"https://www.hippopx.com/zh/query?q=cat\u0026page=%s\"%(i) #q表示你要找到的名称，这里是cat，page用来确定第几页 print(url) html = requests.get(url,headers=gHeads) html = html.content soup = BeautifulSoup(html, 'lxml') img_all = soup.find_all('link',{\"itemprop\": \"thumbnail\"}) for img4 in img_all: urlimg = img4['href'] print(urlimg) r = requests.get(urlimg, stream=True) image_name = urlimg.split('/')[-1] with open('F:/Cat/%s' % image_name, 'wb') as f: for chunk in r.iter_content(chunk_size=128): f.write(chunk) print('Saved %s' % image_name) print(\"end.....................\") 高清图片下载 #Cat下载High-Definition from bs4 import BeautifulSoup import requests gHeads = { \"User-Agent\":\"Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36\" } for i in range(2,100): url = \"https://www.hippopx.com/zh/query?q=cat\u0026page=%s\"%(i) print(url) html = requests.get(url,headers=gHeads) html = html.content soup = BeautifulSoup(html, 'lxml') img_all = soup.find_all('img',{\"itemprop\": \"contentUrl\"}) for img in img_all: urlimg = img['src'] r = requests.get(urlimg, stream=True) image_name = urlimg.split('/')[-1] with open('F:/Cat_HighDefinition/%s' % image_name, 'wb') as f: for chunk in r.iter_content(chunk_size=128): f.write(chunk) print('Saved %s' % image_name) print(\"end.....................\") 2. colorhub https://www.colorhub.me/ 非高清下载： from bs4 import BeautifulSoup import requests gHeads = { \"User-Agent\":\"Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36\" } for i in range(1,10): url = \"https://www.colorhub.me/search?tag=dog\u0026page=%s\"%(i) print(url) html = requests.get(url,headers=gHeads) html = html.content soup = BeautifulSoup(html, 'lxml') img_all = soup.find_all('img',{\"class\": \"card-img-top\"}) for img4 in img_all: urlimg =\"http:\"+img4['src'] r = requests.get(urlimg, stream=True) image_name = urlimg.split('/')[-1] with open('F:/Image_experiment/DOG/%s' % image_name, 'wb') as f: for chunk in r.iter_content(chunk_size=128): f.write(chunk) print('Saved %s' % image_name) print(\"end.....................\") 高清下载： from bs4 import BeautifulSoup import requests import re gHeads = { \"User-Agent\":\"Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36\" } for i in range(1,2): url = \"https://www.colorhub.me/search?tag=dog\u0026page=%s\"%(i) print(url) html = requests.get(url,headers=gHeads) html = html.content soup = BeautifulSoup(html, 'lxml') href_all = soup.find_all('div',{\"class\":\"card\"}) for href in href_all: href_url = href.a['href'] html4 = requests.get(href_url,headers=gHeads).content soup4 = BeautifulSoup(html4, 'lxml') img4 = soup4.find('a',{\"data-magnify\":\"gallery\"}) urlimg =\"http:\"+img4['href'] r = requests.get(urlimg, stream=True) image_name = urlimg.split('/')[-1] with open('F:/Image/DOG/%s' % image_name, 'wb') as f: for chunk in r.iter_content(chunk_size=128): f.write(chunk) print('Saved %s' % image_name) print(\"end.....................\") 3. pikrepo https://www.pikrepo.com/ 非高清下载： from bs4 import BeautifulSoup import requests gHeads = { \"User-Agent\":\"Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36\" } for i in range(1,100): url = \"https://www.pikrepo.com/search?q=mountain\u0026page=%s\"%(i) print(url) html = requests.get(url,headers=gHeads) html = html.content soup = BeautifulSoup","date":"2021-10-07","objectID":"/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B%E5%85%8D%E8%B4%B9%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%AB%99%E5%86%85%E9%99%84%E9%83%A8%E5%88%86%E7%88%AC%E8%99%AB%E4%BB%A3%E7%A0%81/:0:1","tags":null,"title":"【转载】一些免费图片下载网站（内附部分爬虫代码）","uri":"/%E8%BD%AC%E8%BD%BD%E4%B8%80%E4%BA%9B%E5%85%8D%E8%B4%B9%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%AB%99%E5%86%85%E9%99%84%E9%83%A8%E5%88%86%E7%88%AC%E8%99%AB%E4%BB%A3%E7%A0%81/"},{"categories":["Hexo"],"content":"前言 最近折腾博客时，找到壁纸网站wallhaven.cc，官方没有手机客户端，只有第三方客户端，但是第三方客户端又不能在浏览图片时对喜欢的图片放入自己账号的收藏夹，而是作为本地Bookmark标记，一旦APP卸载，自己整理的喜欢的壁纸就丢失了。所以这里有两个概念： 1、本地书签（BookMark），跟着APP走 2、在线收藏（跟着账号走） ","date":"2021-10-06","objectID":"/wallhaven%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%94%B6%E8%97%8F/:1:0","tags":null,"title":"wallhaven安卓客户端书签的导出与在线收藏","uri":"/wallhaven%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%94%B6%E8%97%8F/"},{"categories":["Hexo"],"content":"APP下载链接 谷歌商店地址 ","date":"2021-10-06","objectID":"/wallhaven%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%94%B6%E8%97%8F/:2:0","tags":null,"title":"wallhaven安卓客户端书签的导出与在线收藏","uri":"/wallhaven%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%94%B6%E8%97%8F/"},{"categories":["Hexo"],"content":"将喜欢的图片加入本地书签 ","date":"2021-10-06","objectID":"/wallhaven%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%94%B6%E8%97%8F/:3:0","tags":null,"title":"wallhaven安卓客户端书签的导出与在线收藏","uri":"/wallhaven%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%94%B6%E8%97%8F/"},{"categories":["Hexo"],"content":"导出书签 找到并进入书签界面 点击右上角更多（···），选择分享bookmark，发送到聊天工具即可。 ","date":"2021-10-06","objectID":"/wallhaven%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%94%B6%E8%97%8F/:4:0","tags":null,"title":"wallhaven安卓客户端书签的导出与在线收藏","uri":"/wallhaven%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%94%B6%E8%97%8F/"},{"categories":["Hexo"],"content":"用py脚本自动将本地书签转为在线收藏。 ","date":"2021-10-06","objectID":"/wallhaven%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%94%B6%E8%97%8F/:5:0","tags":null,"title":"wallhaven安卓客户端书签的导出与在线收藏","uri":"/wallhaven%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%94%B6%E8%97%8F/"},{"categories":["Hexo"],"content":"本地bookmark文件结构: [ { \"n\": \"j3y8pm\", \"o\": \"https://th.wallhaven.cc/lg/j3/j3y8pm.jpg\", \"r\": 284, \"s\": 1632674055901, \"p\": \"https://whvn.cc/j3y8pm\", \"q\": \"1920x1080\" }, { \"n\": \"l3jqxl\", \"o\": \"https://th.wallhaven.cc/lg/l3/l3jqxl.jpg\", \"r\": 116, \"s\": 1632674060537, \"p\": \"https://whvn.cc/l3jqxl\", \"q\": \"1920x1080\" } ] ","date":"2021-10-06","objectID":"/wallhaven%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%94%B6%E8%97%8F/:5:1","tags":null,"title":"wallhaven安卓客户端书签的导出与在线收藏","uri":"/wallhaven%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%94%B6%E8%97%8F/"},{"categories":["Hexo"],"content":"登录wallhaven.cc def login(): '''登录，获取token''' print('开始登录...') header = {'User-Agent' : 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36'} login_index_url = 'https://wallhaven.cc/login' response = s.get(login_index_url, headers=header) html = response.text bf = BeautifulSoup(html, 'lxml') hidden = bf.find_all('input', {'type':'hidden'}) for i in hidden: _token = i['value'] data = { '_token' : _token, 'username': '***', # 账号 'password': '******' # 密码 } login_url = 'https://wallhaven.cc/auth/login' response = s.post(login_url, headers=header, data=data) if response.status_code == 200: print(\"login success\") token = re.findall('\u003cinput type=\"hidden\" name=\"_token\" value=\"(.*?)\"\u003e',response.text)[0] return token else: print('login failed') return response.status_code ","date":"2021-10-06","objectID":"/wallhaven%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%94%B6%E8%97%8F/:5:2","tags":null,"title":"wallhaven安卓客户端书签的导出与在线收藏","uri":"/wallhaven%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%94%B6%E8%97%8F/"},{"categories":["Hexo"],"content":"构造加入收藏的链接 通过抓包图片详情页点击Add to Favorites的动作，发现加入收藏的链接已经在访问图片详情页时返回了，其链接格式如下： https://wallhaven.cc/favorites/add?wallHashid=图片ID\u0026collectionId=收藏夹ID\u0026_token=40位长度的字符串 而且所有的图片收藏链接token都一致，猜测可能是登录后分配的统一token。 于是查看登录请求的返回源码发现确实有token返回，于是可以直接构造加入收藏的链接。 f'https://wallhaven.cc/favorites/add?wallHashid={pic_hashid}\u0026collectionId={collectionID}\u0026_token={token}' ","date":"2021-10-06","objectID":"/wallhaven%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%94%B6%E8%97%8F/:5:3","tags":null,"title":"wallhaven安卓客户端书签的导出与在线收藏","uri":"/wallhaven%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%94%B6%E8%97%8F/"},{"categories":["Hexo"],"content":"完整代码 结合收藏夹图片信息爬取去重：http://coloraven.github.io/2021/9/Wallhaven壁纸爬虫/#完整代码 import requests,json,re,time from bs4 import BeautifulSoup s = requests.Session() def login(userinfo): '''登录，获取token''' print('开始登录...') login_index_url = 'https://wallhaven.cc/login' response = s.get(login_index_url) html = response.text bf = BeautifulSoup(html, 'lxml') hidden = bf.find_all('input', {'type':'hidden'}) for i in hidden: _token = i['value'] data = { '_token' : _token, } data.update(userinfo) login_url = 'https://wallhaven.cc/auth/login' response = s.post(login_url, data=data, allow_redirects=False) username = response.headers['location'].split('/')[-1] # 获取跳转URL response = s.get(response.headers['location']) if response.status_code == 200: print(\"login success\") token = re.findall('\u003cinput type=\"hidden\" name=\"_token\" value=\"(.*?)\"\u003e',response.text)[0] return username,token else: print('login failed') return response.status_code def AddtoFav(pic_hashid,token,collectionID): \"\"\"构造加入收藏的链接并请求\"\"\" s.headers.update({\"referer\": f\"https://wallhaven.cc/w/{pic_hashid}\"}) favLink = f'https://wallhaven.cc/favorites/add?wallHashid={pic_hashid}\u0026collectionId={collectionID}\u0026_token={token}' r = s.get(favLink) if r.status_code==200: print('成功加入收藏') return 200 elif r.status_code==429: print(r.text) return 429 else: print(r.text) return 3 def GetCollectionPicIDs(apikey, collectionID, nickname): '''返回相应ID在线收藏夹中图片ID列表''' # 第一步获取改ID收藏夹的图片总条数 params = { \"apikey\": apikey } r = requests.get('https://wallhaven.cc/api/v1/collections', params=params) for i in r.json()['data']: if i['id']==collectionID: count = i['count'] print(f'正在获取在线收藏夹图片ID，约等待 {(count//24+2)*1.5} 秒.') ids = [] pages = count//24+2 for page in range(1,pages): print('Remain Time:\\t',pages*1.5) params = { \"apikey\": apikey, \"page\": page, } r = requests.get(f'https://wallhaven.cc/api/v1/collections/{nickname}/{collectionID}', params=params) ids += [record['id'] for record in r.json()['data']] time.sleep(1.5) # 限制每分钟45次，QOS=1.3333 pages-=1 return ids def main(userinfo:dict,pic_ids,collectionID,apikey): headers = {'User-Agent' : 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36'} s.headers.update(headers) nickname,token = login(userinfo) headers = { \"accept\": \"*/*\", \"accept-encoding\": \"gzip, deflate, br\", \"accept-language\": \"zh-CN,zh;q=0.9,en-CN;q=0.8,en;q=0.7,zh-HK;q=0.6\", \"cache-control\": \"no-cache\", \"dnt\": \"1\", \"pragma\": \"no-cache\", \"sec-fetch-dest\": \"empty\", \"sec-fetch-mode\": \"cors\", \"sec-fetch-site\": \"same-origin\", \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36\", \"x-requested-with\": \"XMLHttpRequest\", } s.headers.update(headers) OnlinePicIDs = GetCollectionPicIDs(apikey, collectionID, nickname) PicIDsReady2Add = [pic_id for pic_id in pic_ids if pic_id not in OnlinePicIDs] length = len(PicIDsReady2Add) if len(token)==40: for picid in PicIDsReady2Add: print('Still Remain:\\t',length,end='\\t') time.sleep(1.5) # 休眠1.5秒可保证服务器不提示请求过于频繁 code = AddtoFav(picid,token,collectionID) if code == 429: time.sleep(3) # 429错误时，暂停1分钟再重试 AddtoFav(picid,token,collectionID) print(picid) elif code == 1: time.sleep(3) # 防止报429 Too Many Requests 错误，间隔5秒请求 continue elif code ==3: # 其他错误时打印图片ID，供下次继续 print(picid) length -= 1 print('All Done!') if __name__ == '__main__': with open('bookmarks.json','r') as f: bookmarks = json.load(f) pic_ids = [bookmark[\"n\"] for bookmark in bookmarks] apikey = \"***********************\" userinfo = {'username': '******', # 账号-为邮箱 'password': '++KwN9NGC@F34s3Ed++'} # 密码 collectionID = 972651 main(userinfo,pic_ids,collectionID,apikey) ","date":"2021-10-06","objectID":"/wallhaven%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%94%B6%E8%97%8F/:5:4","tags":null,"title":"wallhaven安卓客户端书签的导出与在线收藏","uri":"/wallhaven%E5%AE%89%E5%8D%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%9C%A8%E7%BA%BF%E6%94%B6%E8%97%8F/"},{"categories":["Hexo"],"content":"使用API获取收藏夹中的图片链接地址 请求地址：https://api.pexels.com/v1/collections/pwgv2sw?per_page=80\u0026type=photos ","date":"2021-10-05","objectID":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/:1:0","tags":null,"title":"随机使用Pexels收藏壁纸为博客背景图","uri":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/"},{"categories":["Hexo"],"content":"请求参数: { \"per_page\": \"80\", \"type\": \"photos\" } ","date":"2021-10-05","objectID":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/:1:1","tags":null,"title":"随机使用Pexels收藏壁纸为博客背景图","uri":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/"},{"categories":["Hexo"],"content":"请求头： { \"Authorization\": \"API KEY\" } ","date":"2021-10-05","objectID":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/:1:2","tags":null,"title":"随机使用Pexels收藏壁纸为博客背景图","uri":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/"},{"categories":["Hexo"],"content":"完整Python代码 import requests headers = { 'User-Agent': 'Apipost client Runtime/+https://www.apipost.cn/', 'Authorization': 'API KEY', 'Content-Type': 'application/json', } params = ( ('per_page', '80'), ('type', 'photos'), ) response = requests.get('https://api.pexels.com/v1/collections/pwgv2sw', headers=headers, params=params) ","date":"2021-10-05","objectID":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/:1:3","tags":null,"title":"随机使用Pexels收藏壁纸为博客背景图","uri":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/"},{"categories":["Hexo"],"content":"响应数据示例： { \"page\": 1, \"per_page\": 80, \"media\": [ { \"type\": \"Photo\", \"id\": 1011302, \"width\": 2448, \"height\": 3696, \"url\": \"https://www.pexels.com/photo/green-orchid-plant-1011302/\", \"photographer\": \"Julia Sakelli\", \"photographer_url\": \"https://www.pexels.com/@juliasakelli\", \"photographer_id\": 259751, \"avg_color\": \"#404222\", \"src\": { \"original\": \"https://images.pexels.com/photos/1011302/pexels-photo-1011302.jpeg\", \"large2x\": \"https://images.pexels.com/photos/1011302/pexels-photo-1011302.jpeg?auto=compress\u0026cs=tinysrgb\u0026dpr=2\u0026h=650\u0026w=940\", \"large\": \"https://images.pexels.com/photos/1011302/pexels-photo-1011302.jpeg?auto=compress\u0026cs=tinysrgb\u0026h=650\u0026w=940\", \"medium\": \"https://images.pexels.com/photos/1011302/pexels-photo-1011302.jpeg?auto=compress\u0026cs=tinysrgb\u0026h=350\", \"small\": \"https://images.pexels.com/photos/1011302/pexels-photo-1011302.jpeg?auto=compress\u0026cs=tinysrgb\u0026h=130\", \"portrait\": \"https://images.pexels.com/photos/1011302/pexels-photo-1011302.jpeg?auto=compress\u0026cs=tinysrgb\u0026fit=crop\u0026h=1200\u0026w=800\", \"landscape\": \"https://images.pexels.com/photos/1011302/pexels-photo-1011302.jpeg?auto=compress\u0026cs=tinysrgb\u0026fit=crop\u0026h=627\u0026w=1200\", \"tiny\": \"https://images.pexels.com/photos/1011302/pexels-photo-1011302.jpeg?auto=compress\u0026cs=tinysrgb\u0026dpr=1\u0026fit=crop\u0026h=200\u0026w=280\" }, \"liked\": false } ], \"total_results\": 413, \"next_page\": \"https://api.pexels.com/v1/collections/pwgv2sw/?page=2\u0026per_page=80\u0026type=photos\", \"id\": \"pwgv2sw\" } ","date":"2021-10-05","objectID":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/:1:4","tags":null,"title":"随机使用Pexels收藏壁纸为博客背景图","uri":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/"},{"categories":["Hexo"],"content":"遍历收藏夹图片信息： ","date":"2021-10-05","objectID":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/:2:0","tags":null,"title":"随机使用Pexels收藏壁纸为博客背景图","uri":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/"},{"categories":["Hexo"],"content":"第一次请求： results = [] response = requests.get('https://api.pexels.com/v1/collections/pwgv2sw', headers=headers, params=params) result = response.json() results+=result[\"media\"] 获取响应中的next_page ","date":"2021-10-05","objectID":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/:2:1","tags":null,"title":"随机使用Pexels收藏壁纸为博客背景图","uri":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/"},{"categories":["Hexo"],"content":"后续递归遍历： def get_pic_info(result): if 'next_page' in result: response = requests.get(result.json()['next_page'],headers=headers) result = response.json() return result[\"media\"]+=get_pic_info(result) else: return [] ","date":"2021-10-05","objectID":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/:2:2","tags":null,"title":"随机使用Pexels收藏壁纸为博客背景图","uri":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/"},{"categories":["Hexo"],"content":"提取图片链接信息： for i in results: large2x = i[\"src\"][\"large2x\"] ","date":"2021-10-05","objectID":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/:2:3","tags":null,"title":"随机使用Pexels收藏壁纸为博客背景图","uri":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/"},{"categories":["Hexo"],"content":"最终代码 import requests headers = { # \"user-agent\": \"ApiPOST Runtime +https://www.apipost.cn\", 'Authorization': '563492ad6f91700001000001dab470950ea14cdca736ef73a9d7e101', 'Content-Type': 'application/json', } params = ( ('per_page', '80'), ('type', 'photos') ) results = [] response = requests.get('https://api.pexels.com/v1/collections/pwgv2sw', headers=headers, params=params) result = response.json() results+=result[\"media\"] def get_pic_info(result): if 'next_page' in result: next_page = result['next_page'] response = requests.get(next_page,headers=headers) result = response.json() return result[\"media\"]+get_pic_info(result) else: return [] results+=get_pic_info(result) print(len(results)) ","date":"2021-10-05","objectID":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/:2:4","tags":null,"title":"随机使用Pexels收藏壁纸为博客背景图","uri":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/"},{"categories":["Hexo"],"content":"搭建微服务（Docker容器） 实现：从文件中读取图片信息集，并随机抽取图片链接 ","date":"2021-10-05","objectID":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/:3:0","tags":null,"title":"随机使用Pexels收藏壁纸为博客背景图","uri":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/"},{"categories":["Hexo"],"content":"flask代码 待完善的地方： wallhaven图片大小过滤，NSFW开关， pexels与wallhaven选择 from flask import Flask,redirect,request import json,requests,random,time import urllib3 urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) app = Flask(__name__) headers = { 'Authorization': '563492ad6f91700001000001dab470950ea14cdca736ef73a9d7e101', 'Content-Type': 'application/json', } @app.route(\"/\",methods=['get']) def getimg(): print(\"进入获取图片链接函数\") # 尝试获取参数 if request.args.get(\"source\"): # 接受pexels或者wallhaven或者both，默认为both source=request.args.get(\"source\") if '?' in source: source=source.split('?')[0] else: source='both' if request.args.get(\"size\"): # 接受整数......过滤wallhaven壁纸大小,默认为0==无限制。 if '?' in request.args.get(\"size\"): size=request.args.get(\"size\").split('?')[0] size = int(size) else: size= 0 if request.args.get(\"nsfw\"): # 接受on或者off，对应打开或者关闭，默认关闭。 nsfw=request.args.get(\"nsfw\") if '?' in nsfw: nsfw=nsfw.split('?')[0] else: nsfw='off' # 尝试读取文件 try: with open('pexels_pics.json','r') as f: pexels_pics=json.load(f) pexels_pics=[i['src'][\"large2x\"] for i in pexels_pics] with open('wallhaven.json','r') as ff: wallhaven_pics=json.load(ff) except Exception as e: print(e) print(\"某个必须文件不存在！准备进行更新\") update() with open('pexels_pics.json','r') as f: pexels_pics=json.load(f) pexels_pics=[i['src'][\"large2x\"] for i in pexels_pics] with open('wallhaven.json','r') as ff: wallhaven_pics=json.load(ff) # 根据请求参数过滤wallhaven图片路径信息 if nsfw=='off': if size==0: wallhaven_pics=[i[\"path\"] for i in wallhaven_pics if i[\"purity\"]!='nsfw'] elif size!=0: wallhaven_pics=[i[\"path\"] for i in wallhaven_pics if i[\"file_size\"]\u003c=size\u0026i[\"purity\"]!='nsfw'] elif nsfw == 'on': if size != 0: wallhaven_pics=[i[\"path\"] for i in wallhaven_pics if i[\"file_size\"]\u003c=size] elif size==0: wallhaven_pics=[i[\"path\"] for i in wallhaven_pics ] elif nsfw == 'only': #参数设置不正确，则返回空 CountOfNsfw = len([i[\"path\"] for i in wallhaven_pics if i[\"purity\"]=='nsfw']) if size==0: wallhaven_pics=[i[\"path\"] for i in wallhaven_pics if i[\"purity\"]=='nsfw'] elif size!=0: wallhaven_pics=[i[\"path\"] for i in wallhaven_pics if i[\"file_size\"]\u003c=size\u0026i[\"purity\"]=='nsfw'] print(f'nsfw only total have {CountOfNsfw} pics') else: wallhaven_pics=[] if source=='pexels': img_link = random.choice(pexels_pics) return redirect(img_link) elif source=='wallhaven': img_link = random.choice(wallhaven_pics) return redirect(img_link) elif source=='both': img_link = random.choice(pexels_pics+wallhaven_pics) return redirect(img_link) else:#参数设置不正确，则返回空 return '' def get_pic_info(result): \"\"\"用于被update函数调用\"\"\" if 'next_page' in result: next_page = result['next_page'] print(next_page) response = requests.get(next_page,headers=headers) result = response.json() return result[\"media\"]+get_pic_info(result) else: return [] @app.route(\"/update\",methods=['GET']) def update(): print(\"进入更新图片函数\") params = { 'per_page': 80, 'type': 'photos' } results = [] response = requests.get('https://api.pexels.com/v1/collections/pwgv2sw', headers=headers, params=params,verify=False) result = response.json() results+=result[\"media\"] results+=get_pic_info(result) with open('pexels_pics.json','w') as f: json.dump(results,f) print(f'共计写入{len(results)}条') # 更新wallhaven收藏壁纸 wallhaven_headers = {\"X-API-Key\": \"w1G9hS9Ci80pNuvWAwX8hz519JoqAZUh\"} url = 'https://wallhaven.cc/api/v1/collections/blackelk/972651' # https://wallhaven.cc/api/v1/collections/用户名/收藏夹ID r = requests.get(url,headers=wallhaven_headers) result = r.json() results = result[\"data\"] total_page = result[\"meta\"][\"last_page\"] print(f'预计等待{total_page*7-2}秒') count = 1 # 用于计算请求次数，防止超出每分钟45次频率 print(f'current page: 1 / {total_page}') for page in range(2,total_page+1): print(f'current page: {page} / {total_page}') time.sleep(5) params = {'page': page} r = requests.get(url,headers=wallhaven_headers,params=params,verify=False) count+=1 results+=r.json()[\"data\"] with open('wallhaven.json','w') as f: json.dump(results,f) if __name__ == '__main__': # 开启debug模式方法二 app.run(debug=True,host='0.0.0.0',port=8448) ","date":"2021-10-05","objectID":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/:3:1","tags":null,"title":"随机使用Pexels收藏壁纸为博客背景图","uri":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/"},{"categories":["Hexo"],"content":"gunicorn.conf.py配置文件 此处使用之前弄好的，使用gunicorn可以实现并发访问，给flask赋能。 workers = 4 # 定义同时开启的处理请求的进程数量，根据网站流量适当调整 worker_class = \"gevent\" # 采用gevent库，支持异步处理请求，提高吞吐量 debug = True capture_output = True timeout = 200 bind = \"0.0.0.0:8448\" # 监听IP端口，以便于Docker之间、Docker和宿主机之间的通信 loglevel = \"debug\" ","date":"2021-10-05","objectID":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/:3:2","tags":null,"title":"随机使用Pexels收藏壁纸为博客背景图","uri":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/"},{"categories":["Hexo"],"content":"Dockerfile FROM python:3.9.6-alpine3.14 WORKDIR /app RUN apk --update --no-cache add --virtual .all python3-dev libffi-dev gcc musl-dev make libevent-dev build-base \\ \u0026\u0026pip install --no-cache-dir gevent flask gunicorn requests \\ \u0026\u0026apk --purge del .all COPY . . EXPOSE 8448 CMD gunicorn app:app -preload -c gunicorn.conf.py ","date":"2021-10-05","objectID":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/:3:3","tags":null,"title":"随机使用Pexels收藏壁纸为博客背景图","uri":"/%E9%9A%8F%E6%9C%BA%E4%BD%BF%E7%94%A8pexels%E6%94%B6%E8%97%8F%E5%A3%81%E7%BA%B8%E4%B8%BA%E5%8D%9A%E5%AE%A2%E8%83%8C%E6%99%AF%E5%9B%BE/"},{"categories":["Python"],"content":" https://cloud.tencent.com/developer/article/1527470 ","date":"2021-09-25","objectID":"/python%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/:0:0","tags":["Python"],"title":"Python上传图片","uri":"/python%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"},{"categories":["Hexo"],"content":"源于即刻图床 偶然遇到即刻图床这款插件，打开了我的新世界大门。 即刻图床利用阿里、京东、新浪等大厂的API上传图片作为图床，无需注册，无上传个数限制，无流量限制，且访问速度超快。 下面是各厂商图床API的python实现代码 ","date":"2021-09-25","objectID":"/%E5%88%A9%E7%94%A8%E5%A4%A7%E5%8E%82api%E4%BD%9C%E4%B8%BA%E5%9B%BE%E5%BA%8A/:1:0","tags":null,"title":"利用大厂API作为图床","uri":"/%E5%88%A9%E7%94%A8%E5%A4%A7%E5%8E%82api%E4%BD%9C%E4%B8%BA%E5%9B%BE%E5%BA%8A/"},{"categories":["Hexo"],"content":"JD import requests,base64,lxml.html,json,os from requests_toolbelt import MultipartEncoder def img_to_base64(imagefile): image_data = open(imagefile, 'rb').read() return base64.b64encode(image_data) def upload_to_JD(imagefile): url = 'https://imio.jd.com/uploadfile/file/post.do' headers = { 'authority': 'imio.jd.com', 'pragma': 'no-cache', 'cache-control': 'no-cache', 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36', 'dnt': '1', 'accept': 'application/json', 'origin': 'chrome-extension://dckaeinoeaogebmhijpkpmacifmpgmcb', 'sec-fetch-site': 'none', 'sec-fetch-mode': 'cors', 'sec-fetch-dest': 'empty', 'accept-language': 'zh-CN,zh;q=0.9,en-CN;q=0.8,en;q=0.7', 'cookie': 'shshshfpa=file-dd.jd.local_file-dd.jd.local', } form_data = { 'appId': 'im.customer', 'aid': 'undefined', 'clientType': 'comet', 'pin': 'undefined', 's': img_to_base64(imagefile) } # 生成可用于multipart/form-data上传的数据 m = MultipartEncoder(form_data) # 自动生成Content-Type类型和随机码 headers['Content-Type'] = m.content_type # 使用data上传文件 r = requests.post(url, headers=headers, data=m) json_strs = lxml.html.document_fromstring(r.text).find('body').text try: json_obj = json.loads(json_strs) if json_obj['desc'] == \"上传成功\": print(json_obj['path']) return json_obj['path'] else: print(imagefile,json_obj) except Exception as e: print('遇到错误:',e,'图片文件：','') '''获取文件的大小,结果保留两位小数，单位为MB''' def get_FileSize(filePath): # filePath = unicode(filePath,'utf8') fsize = os.path.getsize(filePath) # fsize = fsize/float(1024*1024) return fsize if __name__ == '__main__': files = os.listdir() # 获取当前目录中的文件名 result = {} for file in files: if get_FileSize(file) \u003c= (10*1024*1024): imgurl = upload_to_JD(file) result[file]=imgurl with open('upload_result.json','w',encoding='utf-8') as f: json.dump(result,f) ","date":"2021-09-25","objectID":"/%E5%88%A9%E7%94%A8%E5%A4%A7%E5%8E%82api%E4%BD%9C%E4%B8%BA%E5%9B%BE%E5%BA%8A/:2:0","tags":null,"title":"利用大厂API作为图床","uri":"/%E5%88%A9%E7%94%A8%E5%A4%A7%E5%8E%82api%E4%BD%9C%E4%B8%BA%E5%9B%BE%E5%BA%8A/"},{"categories":["逆向"],"content":" 原始可用APK已备份 类名： com.cloudinject.feature.App public void attachBaseContext(Context context) { try { StringBuilder sb = new StringBuilder(); sb.append(\"JkmuyJoL\"); File file = new File(context.getFilesDir(), \"decode\"); if (!file.mkdirs()) { sb.append(\".\"); } else { file.delete(); } if (f9216 == null || IV == null || key == null) { f9216 = new DESKeySpec(sb.toString().getBytes(\"UTF-8\")); key = SecretKeyFactory.getInstance(\"DES\").generateSecret(f9216); IV = new IvParameterSpec(sb.toString().getBytes(\"UTF-8\")); } } catch (Exception unused) { } m11271(context); super.attachBaseContext(context); } ","date":"2021-09-25","objectID":"/%E7%B4%AB%E7%8B%90%E5%88%86%E8%BA%ABpj%E8%BF%87%E7%A8%8B/:0:0","tags":["APP","逆向"],"title":"紫狐分身PJ过程","uri":"/%E7%B4%AB%E7%8B%90%E5%88%86%E8%BA%ABpj%E8%BF%87%E7%A8%8B/"},{"categories":["逆向"],"content":"类名 ","date":"2021-09-25","objectID":"/%E7%B4%AB%E7%8B%90%E5%88%86%E8%BA%ABpj%E8%BF%87%E7%A8%8B/:1:0","tags":["APP","逆向"],"title":"紫狐分身PJ过程","uri":"/%E7%B4%AB%E7%8B%90%E5%88%86%E8%BA%ABpj%E8%BF%87%E7%A8%8B/"},{"categories":["逆向"],"content":"p011cd.C9813 package p011cd; import rxc.internal.operators.CryptoBox; /* renamed from: cd.̗̙̖̗̙̗ */ public final class C9813 { public static String HOST = \"http://360stat.org\"; /* renamed from: ̗̖̖̗ */ public static String f34125 = null; /* renamed from: ̗̖̖̙ */ public static String f34126 = null; /* renamed from: ̗̖̗̙ */ public static String f34127 = null; /* renamed from: ̗̖̙̖ */ public static String f34128 = \"http://log-report.com/report\"; /* renamed from: ̗̖̙̗ */ public static String f34129 = \"https://storage.googleapis.com/ij-cloud/j.cap\"; /* renamed from: ̗̖̙̙ */ public static String f34130 = \"http://checksum.cc\"; /* renamed from: ̗̙̗̖ */ public static String f34131 = \"https://bellaluna4ala.s3.ap-east-1.amazonaws.com/j2.cap\"; /* renamed from: ̗̙̗̗ */ public static String f34132 = \"https://storage.googleapis.com/ij-cloud/f.cap1\"; /* renamed from: ̙̗̖ */ public static String f34133 = \"https://bellaluna4ala.s3.ap-east-1.amazonaws.com/f2.cap\"; public static void reload() { HOST = C9739.getHost(); f34130 = C9739.m464(); f34126 = HOST + CryptoBox.decrypt(\"D077E94E47201AC629F795C43B20AF1C\"); f34125 = HOST + CryptoBox.decrypt(\"D077E94E47201AC6ECAF95B536BDF70725E120A4E6663FB9\"); f34127 = f34130 + CryptoBox.decrypt(\"310A51B8EA767DD6\"); } com.cloudinject.feature.App public void onCreate() { super.onCreate(); f9214 = this; f34454 = this; C9761.m497(C9778.m533(C9809.decode(APP_ID.substring(0, 5), f34451))); C9805.m549().f500 = f9214.getSharedPreferences(\"eysFvaLOxnPc9vLZ\", 0); Thread.setDefaultUncaughtExceptionHandler(new C9741()); registerActivityLifecycleCallbacks(new C9746()); } ","date":"2021-09-25","objectID":"/%E7%B4%AB%E7%8B%90%E5%88%86%E8%BA%ABpj%E8%BF%87%E7%A8%8B/:2:0","tags":["APP","逆向"],"title":"紫狐分身PJ过程","uri":"/%E7%B4%AB%E7%8B%90%E5%88%86%E8%BA%ABpj%E8%BF%87%E7%A8%8B/"},{"categories":["逆向"],"content":"以上信息得知，请求URL路径的解密方式为 加密方式： “DES/CBC/PKCS5Padding” 密钥和偏移： “JkmuyJoL” 字符编码：HEX f34126 = HOST + CryptoBox.decrypt(\"D077E94E47201AC629F795C43B20AF1C\"); # 解密后为 /config f34125 = HOST + CryptoBox.decrypt(\"D077E94E47201AC6ECAF95B536BDF70725E120A4E6663FB9\"); # 解密后为pack/verify f34127 = f34130 + CryptoBox.decrypt(\"310A51B8EA767DD6\"); # 解密后为 v2? 通过在线解密工具http://des.online-domain-tools.com/能大概解密出来 com.mob.tools.network.NetworkHelper public String httpPostFiles(String str, ArrayList\u003cKVPair\u003cString\u003e\u003e arrayList, ArrayList\u003cKVPair\u003cString\u003e\u003e arrayList2, ArrayList\u003cKVPair\u003cString\u003e\u003e arrayList3, int i, NetworkTimeOut networkTimeOut) throws Throwable { final HashMap hashMap = new HashMap(); httpPost(str, arrayList, arrayList2, arrayList3, i, new HttpResponseCallback() { /* class com.mob.tools.network.NetworkHelper.C39883 */ @Override // com.mob.tools.network.HttpResponseCallback public void onResponse(HttpConnection httpConnection) throws Throwable { int responseCode = httpConnection.getResponseCode(); if (responseCode == 200 || responseCode \u003c 300) { StringBuilder sb = new StringBuilder(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(httpConnection.getInputStream(), Charset.forName(\"utf-8\"))); for (String readLine = bufferedReader.readLine(); readLine != null; readLine = bufferedReader.readLine()) { if (sb.length() \u003e 0) { sb.append('\\n'); } sb.append(readLine); } bufferedReader.close(); hashMap.put(\"resp\", sb.toString()); return; } StringBuilder sb2 = new StringBuilder(); BufferedReader bufferedReader2 = new BufferedReader(new InputStreamReader(httpConnection.getErrorStream(), Charset.forName(\"utf-8\"))); for (String readLine2 = bufferedReader2.readLine(); readLine2 != null; readLine2 = bufferedReader2.readLine()) { if (sb2.length() \u003e 0) { sb2.append('\\n'); } sb2.append(readLine2); } bufferedReader2.close(); HashMap hashMap = new HashMap(); hashMap.put(UContent.f16213N, sb2.toString()); hashMap.put(\"status\", Integer.valueOf(responseCode)); throw new Throwable(new Hashon().fromHashMap(hashMap)); } }, networkTimeOut); return (String) hashMap.get(\"resp\"); } ","date":"2021-09-25","objectID":"/%E7%B4%AB%E7%8B%90%E5%88%86%E8%BA%ABpj%E8%BF%87%E7%A8%8B/:2:1","tags":["APP","逆向"],"title":"紫狐分身PJ过程","uri":"/%E7%B4%AB%E7%8B%90%E5%88%86%E8%BA%ABpj%E8%BF%87%E7%A8%8B/"},{"categories":["逆向"],"content":"启动APP后，验证卡密时的请求： ","date":"2021-09-25","objectID":"/%E7%B4%AB%E7%8B%90%E5%88%86%E8%BA%ABpj%E8%BF%87%E7%A8%8B/:3:0","tags":["APP","逆向"],"title":"紫狐分身PJ过程","uri":"/%E7%B4%AB%E7%8B%90%E5%88%86%E8%BA%ABpj%E8%BF%87%E7%A8%8B/"},{"categories":["逆向"],"content":"请求方式：GET， URL：http://360stat.org/feature/pack/verify?platform=2\u0026secret=596bbb4570\u0026app_id=bcc47d4f54f5ec3c0000ba22bb5590fe\u0026version_code=4\u0026app_version=1.3\u0026device_code=befc2fe28fb837f7\u0026api_version=1 ","date":"2021-09-25","objectID":"/%E7%B4%AB%E7%8B%90%E5%88%86%E8%BA%ABpj%E8%BF%87%E7%A8%8B/:3:1","tags":["APP","逆向"],"title":"紫狐分身PJ过程","uri":"/%E7%B4%AB%E7%8B%90%E5%88%86%E8%BA%ABpj%E8%BF%87%E7%A8%8B/"},{"categories":["逆向"],"content":"响应头： HTTP/1.1 200 OK Server: openresty/1.13.6.2 Date: Thu, 16 Sep 2021 20:30:41 GMT Content-Type: application/json;charset=UTF-8 Content-Length: 106 Connection: keep-alive sign: 4bfdad943c93a58242246650f06fed54 eagleid: 2ca65aa0e01858fe1fcac57de6fe0b3b resp: cf1096c3ecbbe53653679f37526bd773 ","date":"2021-09-25","objectID":"/%E7%B4%AB%E7%8B%90%E5%88%86%E8%BA%ABpj%E8%BF%87%E7%A8%8B/:3:2","tags":["APP","逆向"],"title":"紫狐分身PJ过程","uri":"/%E7%B4%AB%E7%8B%90%E5%88%86%E8%BA%ABpj%E8%BF%87%E7%A8%8B/"},{"categories":["逆向"],"content":"响应体 {\"result\":{\"msg\":\"验证成功，卡密有效期至：2021-12-16 04:30:41\"},\"ts\":1631824241729,\"status\":1} ","date":"2021-09-25","objectID":"/%E7%B4%AB%E7%8B%90%E5%88%86%E8%BA%ABpj%E8%BF%87%E7%A8%8B/:3:3","tags":["APP","逆向"],"title":"紫狐分身PJ过程","uri":"/%E7%B4%AB%E7%8B%90%E5%88%86%E8%BA%ABpj%E8%BF%87%E7%A8%8B/"},{"categories":["逆向"],"content":"定位时的返回 {\"message\": \"success\", \"code\": 200, \"data\": \"r52fVRuqRKZwpOlKry70HcCa3ExP+fVYgu4LaHDYX1+zoT8gsIN9kq/xDYCpXxgHO7Pzo0q4P9G60j2+xSmwzNfE14TpohR342SDqb3oexA/4foWowknL2EcV6l/xQcWW8G+dvcdaZOi4dE6zA5f8Vu9JWNUshiOJeBELoAPo/u7QkD2cI1xbjDj6gDEM60X0vqT/6+dRSPYu/pOWZVz4O8F9Zb2Fdiq/ZcCCF5au0CLPnjhN2g5Bcyu8/bpwDaG4mQ8VOo1cgjkkHNPmhWoCvhfKkNh6ZxVHZtSUas2Qf6szxngq0+hFrkAxGbU6vVuai5r8wQpj4UEbAsriVEZ9V3pqdah1YZIiIC6ucqWes6vYUY36aNIPoWybgHjyFfFSDTb6gxQrl+EbsAw/fkNTcrXW/BmX0mQJoqnLhVh0yqxHgNgnF+9re3AoruBR+eHaWSgg3ewHXCsxrqNXbPJuyVQSjyUs7OUQiFynuiIsCmxWyxNisZqktJe4/FfX2b/\" } ","date":"2021-09-25","objectID":"/%E7%B4%AB%E7%8B%90%E5%88%86%E8%BA%ABpj%E8%BF%87%E7%A8%8B/:4:0","tags":["APP","逆向"],"title":"紫狐分身PJ过程","uri":"/%E7%B4%AB%E7%8B%90%E5%88%86%E8%BA%ABpj%E8%BF%87%E7%A8%8B/"},{"categories":["Hexo"],"content":"chrome商店地址：https://chrome.google.com/webstore/detail/即刻图床/dckaeinoeaogebmhijpkpmacifmpgmcb?hl=zh-CN update logs：https://jiketuchuang.com/ /*! jQuery v3.4.1 | (c) JS Foundation and other contributors | jquery.org/license */ !function(e,t){\"use strict\";\"object\"==typeof module\u0026\u0026\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(C,e){\"use strict\";var t=[],E=C.document,r=Object.getPrototypeOf,s=t.slice,g=t.concat,u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return\"function\"==typeof e\u0026\u0026\"number\"!=typeof e.nodeType},x=function(e){return null!=e\u0026\u0026e===e.window},c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement(\"script\");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute\u0026\u0026t.getAttribute(r))\u0026\u0026o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?n[o.call(e)]||\"object\":typeof e}var f=\"3.4.1\",k=function(e,t){return new k.fn.init(e,t)},p=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;function d(e){var t=!!e\u0026\u0026\"length\"in e\u0026\u0026e.length,n=w(e);return!m(e)\u0026\u0026!x(e)\u0026\u0026(\"array\"===n||0===t||\"number\"==typeof t\u0026\u00260\u003ct\u0026\u0026t-1 in e)}k.fn=k.prototype={jquery:f,constructor:k,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e\u003c0?this[e+this.length]:this[e]},pushStack:function(e){var t=k.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return k.each(this,e)},map:function(n){return this.pushStack(k.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(e\u003c0?t:0);return this.pushStack(0\u003c=n\u0026\u0026n\u003ct?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},k.extend=k.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for(\"boolean\"==typeof a\u0026\u0026(l=a,a=arguments[s]||{},s++),\"object\"==typeof a||m(a)||(a={}),s===u\u0026\u0026(a=this,s--);s\u003cu;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],\"__proto__\"!==t\u0026\u0026a!==r\u0026\u0026(l\u0026\u0026r\u0026\u0026(k.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i\u0026\u0026!Array.isArray(n)?[]:i||k.isPlainObject(n)?n:{},i=!1,a[t]=k.extend(l,o,r)):void 0!==r\u0026\u0026(a[t]=r));return a},k.extend({expando:\"jQuery\"+(f+Math.random()).replace(/\\D/g,\"\"),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||\"[object Object]\"!==o.call(e))\u0026\u0026(!(t=r(e))||\"function\"==typeof(n=v.call(t,\"constructor\")\u0026\u0026t.constructor)\u0026\u0026a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t){b(e,{nonce:t\u0026\u0026t.nonce})},each:function(e,t){var n,r=0;if(d(e)){for(n=e.length;r\u003cn;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},trim:function(e){return null==e?\"\":(e+\"\").replace(p,\"\")},makeArray:function(e,t){var n=t||[];return null!=e\u0026\u0026(d(Object(e))?k.merge(n,\"string\"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r\u003cn;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i\u003co;i++)!t(e[i],i)!==a\u0026\u0026r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(d(e))for(r=e.length;o\u003cr;o++)null!=(i=t(e[o],o,n))\u0026\u0026a.push(i);else for(o in e)null!=(i=t(e[o],o,n))\u0026\u0026a.push(i);return g.apply([],a)},guid:1,support:y}),\"function\"==typeof Symbol\u0026\u0026(k.fn[Symbol.iterator]=t[Symbol.iterator]),k.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"),function(e,t){n[\"[object \"+t+\"]\"]=t.toLowerCase()});var h=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,k=\"sizzle\"+1*new Date,m=n.","date":"2021-09-25","objectID":"/%E5%8D%B3%E5%88%BB%E5%9B%BE%E5%BA%8A%E6%BA%90%E7%A0%81/:0:0","tags":null,"title":"即刻图床源码","uri":"/%E5%8D%B3%E5%88%BB%E5%9B%BE%E5%BA%8A%E6%BA%90%E7%A0%81/"},{"categories":["Hexo"],"content":" #wallhaven热门图片采集下载 # —*—coding: utf-8 -*- import requests,time,random,os from lxml import etree from fake_useragent import UserAgent from tqdm import tqdm def parse_html(pageNum): \"\"\"提取单页中地图片链接地址，需要自定义查询参数，举例如下：\"\"\" url = f\"https://wallhaven.cc/search?categories=111\u0026purity=111\u0026ratios=landscape\u0026topRange=1y\u0026sorting=toplist\u0026order=desc\u0026page={pageNum}\" ua = UserAgent().random html = requests.get(url=url, headers={'user-agent': ua}, timeout=6).content.decode('utf-8') tree = etree.HTML(html) imgsrcs = tree.xpath('//ul/li/figure/img/@data-src') imgurls = [] for imgsrc in imgsrcs: img = imgsrc.replace(\"th\", \"w\").replace(\"small\", \"full\") imgs = img.split('/') imgurl = f\"{'/'.join(imgs[:-1])}/wallhaven-{imgs[-1]}\" try: # 使用head请求探测（不会下载图片，加快速度）地址是否正确 r = requests.head(url=imgurl, headers={'user-agent': ua}, timeout=6) if r.status_code==200: # print(\"进入条件一\",r.status_code) imgurls.append(imgurl) else: # print(\"进入条件二\",r.status_code) imgurl = imgurl.replace('jpg', 'png') print(imgurl) imgurls.append(imgurl) except Exception as e: print(f\"出错，错误代码：{e}\") # 休息0-0.2秒 pause_time = random.uniform(0,0.2) time.sleep(pause_time) return imgurls def img_downloader(imgurl,savepath): \"\"\"根据图片链接下载图片到本地，在脚本所在目录新建savepath变量内容对应地文件夹，所有图片保存到其中，文件名为服务器中图片地编码\"\"\" ua = UserAgent().random r = requests.get(url=imgurl, headers={'user-agent': ua}, timeout=6) if r.status_code==200: with open(f'{savepath}\\{imgurl[-10:]}', 'wb') as f: f.write(r.content) print(f\"\\t{imgurl[-10:]} 成功保存图片！\") else: print('图片下载失败:',r.status_code,'图片编码',end='\\t') print(imgurl[-10:]) def start(): '''爬取图片链接保存到文件（文件名wallhaven.txt），不下载图片，此处文件名改了地话，down_pic_from_file函数中也要相应修改''' \"\"\"需要自定义页数\"\"\" result = [] for i in range(1,100): result += parse_html(i) result = '\\n'.join(set(result)) with open('wallhaven.txt','w',encoding='utf-8') as f: f.writelines(result) def down_pic_from_file(): \"\"\"利用os.listdir方法来获取已下载文件名，并与wallhaven.txt中链接对应文件名比对过滤，避免重复下载\"\"\" '''读取文件中的图片链接并下载''' with open('wallhaven.txt','r',encoding='utf-8') as f: result = f.readlines() result = [i.strip() for i in result] savepath = 'wallheaven' # 读取目录中已经下载的图片 done_down_imgs = os.listdir(savepath) remain_list = [i for i in result if i[-10:] not in done_down_imgs] # 如果目录中不存在该图片才下载 print('剩余',len(remain_list)) for url in tqdm(remain_list): if url[-10:] not in done_down_imgs: # print(url) img_downloader(url,savepath) time.sleep(random.uniform(0,1)) 以上是爬取链接保存到文件和根据链接下载图片到本地，两个步骤相互独立。 ","date":"2021-09-23","objectID":"/wallhaven%E5%A3%81%E7%BA%B8%E7%88%AC%E8%99%AB/:0:0","tags":null,"title":"Wallhaven壁纸爬虫-自动上传到指定图床","uri":"/wallhaven%E5%A3%81%E7%BA%B8%E7%88%AC%E8%99%AB/"},{"categories":["Hexo"],"content":"上传图床 我的最终目的是给本博客作为随机背景图，因为wallhaven国内访问速度慢，所以想到将这些图片上传到国内图床再进行使用。 以下是读取wallhaven.txt中的图片链接，下载并上传到图床sm.ms的代码，我使用的是国外vps跑的，奈何sm.ms一小时的上传数量限制是100张图片，尼玛，后来才发现还有一个限制：一天200张上限。 import io,json,requests,time count = 0 # `sm.ms`限制一小时只能上传100`张，此变量用来计算， ys = {} # 用来存放wallhaven地址与图床外链地址的映射关系字典 huishou = [] # 用爱存放大于5M图片的链接 def upload(imgurl): global ys,huishou,count #声明全局变量 token = \"WFyjCGBrKJ9iQqlKyedmnHruZaREHVsn\" # sm.ms个人密钥 headers = {\"Authorization\": token} imgsize = requests.head(imgurl).headers[\"Content-Length\"] # 用head请求，仅探测图片大小，不会下载图片 if int(imgsize) \u003c= 5242880: # 图片小于5M的就进行上传 imgbyte = requests.get(imgurl).content files = {\"smfile\": io.BytesIO(imgbyte)} # 使用io.BytesIO方法，将下载的图片数据紧接着转手上传出去，全部在内存中完成，不占用磁盘空间。 sm_ms_url = \"https://sm.ms/api/v2/upload\" res = requests.post(sm_ms_url, files=files, headers=headers) res=res.json() if res['code']==\"success\": count+=1 print('wallhaven地址',imgurl,'图片外链地址：',res[\"data\"][\"url\"]) ys[imgurl] = res[\"data\"][\"url\"] if count%100==0: time.sleep(3600) elif res['code']=='image_repeated': print('该链接图片已上传',imgurl) else: print(res['message']) else: print(\"该链接图片大于5M\", imgurl) huishou.append(imgurl) if __name__ == \"__main__\": with open(\"wallhaven.txt\", \"r\", encoding=\"utf-8\") as f: result = f.readlines() result = [i.strip() for i in result] for url in result: upload(url) with open('映射关系.json','w') as f: json.dump(ys) with open('5m+.json','w') as f: json.dump(huishou) ","date":"2021-09-23","objectID":"/wallhaven%E5%A3%81%E7%BA%B8%E7%88%AC%E8%99%AB/:1:0","tags":null,"title":"Wallhaven壁纸爬虫-自动上传到指定图床","uri":"/wallhaven%E5%A3%81%E7%BA%B8%E7%88%AC%E8%99%AB/"},{"categories":["Hexo"],"content":"多线程筛选小于5M的图片链接 import time,requests,random # from tqdm import tqdm from multiprocessing.dummy import Pool as ThreadPool s = requests.Session() def login(): '''登录''' print('开始登录...') header = {'User-Agent' : 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36'} login_index_url = 'https://wallhaven.cc/login' response = s.get(login_index_url, headers=header) html = response.text bf = BeautifulSoup(html, 'lxml') hidden = bf.find_all('input', {'type':'hidden'}) for i in hidden: _token = i['value'] data = { '_token' : _token, 'username': '', # 账号 'password': '' # 密码 } login_url = 'https://wallhaven.cc/auth/login' response = s.post(login_url, headers=header, data=data) if response.status_code == 200: print(\"login success\") return 200 else: print('login failed') return response.status_code count = 0 def get_imgsize(url): global count count +=1 print('第',count,'次调用') try: imgsize = session.head(url).headers[\"Content-Length\"] # 用head请求，仅探测图片大小，不会下载图片 if int(imgsize) \u003c= 5242880: return url except Exception as e: print(e) if __name__ == \"__main__\": with open(\"wallhaven.txt\", \"r\", encoding=\"utf-8\") as f: result = f.readlines() result = [i.strip() for i in result] small=[] pool = ThreadPool(10) results = pool.map(get_imgsize, result) pool.close() pool.join() small = [i for i in results if i is not None] with open(\"wallhaven_smallerthan5mb.txt\", \"w\", encoding=\"utf-8\") as f: f.writelines('\\n'.join(small)) ","date":"2021-09-23","objectID":"/wallhaven%E5%A3%81%E7%BA%B8%E7%88%AC%E8%99%AB/:2:0","tags":null,"title":"Wallhaven壁纸爬虫-自动上传到指定图床","uri":"/wallhaven%E5%A3%81%E7%BA%B8%E7%88%AC%E8%99%AB/"},{"categories":["Hexo"],"content":"收藏夹图片信息获取（使用API KEY） w1G9hS9Ci80pNuvWAwX8hz519JoqAZUh API KEY使用限制：1分钟45次， 使用方法： 1、请求参数中：apikey=xxxx 2、请求头中 ：{\"X-API-Key\": \"XXXX\"} 请求连接：https://wallhaven.cc/api/v1/collections/blackelk/972651 请求方式：GET ","date":"2021-09-23","objectID":"/wallhaven%E5%A3%81%E7%BA%B8%E7%88%AC%E8%99%AB/:3:0","tags":null,"title":"Wallhaven壁纸爬虫-自动上传到指定图床","uri":"/wallhaven%E5%A3%81%E7%BA%B8%E7%88%AC%E8%99%AB/"},{"categories":["Hexo"],"content":"完整代码 import requests,json,time headers = {\"X-API-Key\": \"w1G9hS9Ci80pNuvWAwX8hz519JoqAZUh\"} url = 'https://wallhaven.cc/api/v1/collections/blackelk/972651' # https://wallhaven.cc/api/v1/collections/用户名/收藏夹ID r = requests.get(url,headers=headers) result = r.json() results = result[\"data\"] total_page = result[\"meta\"][\"last_page\"] count = 1 # 用于计算请求次数，防止超出每分钟45次频率 print(f'current page: {page} / {total_page}') for page in range(2,total_page+1): print(f'current page: {page} / {total_page}') if count % 45 ==0 : time.sleep(60) params = {'page': page} r = requests.get(url,headers=headers,params=params) count+=1 results+=r.json()[\"data\"] with open('wallhaven.json','w') as f: json.dump(results,f) ","date":"2021-09-23","objectID":"/wallhaven%E5%A3%81%E7%BA%B8%E7%88%AC%E8%99%AB/:3:1","tags":null,"title":"Wallhaven壁纸爬虫-自动上传到指定图床","uri":"/wallhaven%E5%A3%81%E7%BA%B8%E7%88%AC%E8%99%AB/"},{"categories":["Hexo"],"content":"参考 https://blog.csdn.net/qq_29367075/article/details/111940621 https://cloud.tencent.com/developer/article/1799246 登录模拟参考 https%3A%2F%2Fgithub.com%2FRoarpalm%2Fwallhaven%2Fblob%2F779a10bdc3d24e03f9bf2915339ccd58ee165780%2Fnew%20GUI%20Wallhaven%20Setu%20Machine.py%23L62 ","date":"2021-09-23","objectID":"/wallhaven%E5%A3%81%E7%BA%B8%E7%88%AC%E8%99%AB/:4:0","tags":null,"title":"Wallhaven壁纸爬虫-自动上传到指定图床","uri":"/wallhaven%E5%A3%81%E7%BA%B8%E7%88%AC%E8%99%AB/"},{"categories":["Python"],"content":"使用模块：PyCryptodome +++success 实现代码 ;;;id3 样例一 以下代码最后测试于2021年9月20日(AES/ECB/PKCS5Padding模式测试通过) 来源：https://www.cxyzjd.com/article/weixin_43755186/108254464 import base64 from Crypto.Cipher import AES class EncryptDate: def __init__(self, key): self.key = key.encode(\"utf-8\") # 初始化密钥 self.length = AES.block_size # 初始化数据块大小 self.aes = AES.new(self.key, AES.MODE_ECB) # 初始化AES,ECB模式的实例 # 截断函数，去除填充的字符 self.unpad = lambda date: date[0 : -ord(date[-1])] def pad(self, text): \"\"\" #填充函数，使被加密数据的字节码长度是block_size的整数倍 \"\"\" count = len(text.encode(\"utf-8\")) add = self.length - (count % self.length) entext = text + (chr(add) * add) return entext def encrypt(self, encrData): # 加密函数 res = self.aes.encrypt(self.pad(encrData).encode(\"utf8\")) msg = str(base64.b64encode(res), encoding=\"utf8\") return msg def decrypt(self, decrData): # 解密函数 res = base64.decodebytes(decrData.encode(\"utf8\")) msg = self.aes.decrypt(res).decode(\"utf8\") return self.unpad(msg) eg = EncryptDate(\"a1ccb0d670efba1bc4353b1bc8ddf4f7\") # 这里密钥的长度必须是16的倍数 text = '[{\"lat\": 20.36253, \"lon\": 127.840366}]' res = eg.encrypt(text) print(res) print(eg.decrypt(res)) ;;; ;;;id3 样例二 以下代码测试于2020年 from base64 import b64decode from base64 import b64encode from Crypto.Cipher import AES #pycryptodome库 import base64 import json class AESCipher: \"\"\" Tested under Python 3.x and PyCrypto 2.6.1. \"\"\" def __init__(self, key='FfCcu4q6/x2z3XOO'): #加密需要的key值 self.key=key.encode(\"utf-8\")### self.BLOCK_SIZE = 256#16 # Bytes self.pad = lambda s: s + (self.BLOCK_SIZE - len(s) % self.BLOCK_SIZE) * \\ chr(self.BLOCK_SIZE - len(s) % self.BLOCK_SIZE) self.unpad = lambda s: s[:-ord(s[len(s) - 1:])] def encrypt(self, raw): raw = self.pad(raw) #通过key值，使用ECB模式进行加密 cipher = AES.new(self.key, AES.MODE_ECB) #返回得到加密后的字符串进行解码然后进行64位的编码 return base64.b64encode(cipher.encrypt(raw)).decode('utf8') def decrypt(self, enc): enc=enc.encode(\"utf-8\")### #首先对已经加密的字符串进行解码 enc = b64decode(enc) #通过key值，使用ECB模式进行解密 cipher = AES.new(self.key, AES.MODE_ECB) decrypted_text = self.unpad(cipher.decrypt(enc)).decode('utf8') decrypted_text = decrypted_text.replace('\\/','/')#网址正常化 decrypted_text = decrypted_text.encode('utf8').decode('unicode_escape')#unicode字符转中文 return decrypted_text if __name__ == \"__main__\": key= '' crypted_data='' #调用解密函数 decrypted_text = AESCipher(key).decrypt(crypted_data) # decrypted_text =decrypted_text.encode('utf8').decode('unicode_escape') # unicode字符转中文 print(decrypted_text) ;;; +++ ","date":"2021-09-20","objectID":"/python%E4%B8%ADaes%E5%8A%A0%E8%A7%A3%E5%AF%86/:0:0","tags":null,"title":"Python中AES加解密","uri":"/python%E4%B8%ADaes%E5%8A%A0%E8%A7%A3%E5%AF%86/"},{"categories":["Windows"],"content":"解决方案来源：https://bbs.pcbeta.com/forum.php?mod=viewthread\u0026tid=1785990 终于解决了，方法在这里：http://www.oystd.com/blog/2010/10/15/32.html 打开注册表编辑器，定位到 HKEY_CURRENT_USER\\Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\Shell 将Bags删除，注销，或者下载Default-Windows-Size.zip。 二、将IE8的窗口恢复到默认大小的方法。 将IE8的窗口恢复到默认大小最简单的方法：新建文本文档，复制下面内容，以reg格式保存，双击导入注册表，重启IE8。其实就是将Window_Placement这个键删除，重启IE后自动重新生成并赋以默认值。 Windows Registry Editor Version 5.00 [HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main] \"Window_Placement\"=- ","date":"2021-09-19","objectID":"/win10%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E9%BB%98%E8%AE%A4%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE/:0:0","tags":null,"title":"Win10资源管理器默认大小设置","uri":"/win10%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E9%BB%98%E8%AE%A4%E5%A4%A7%E5%B0%8F%E8%AE%BE%E7%BD%AE/"},{"categories":["Windows"],"content":" https://wwi.lanzoui.com/b05gumbe 密码:9xum 工具地址 ","date":"2021-09-19","objectID":"/win10%E6%95%B0%E5%AD%97%E6%BF%80%E6%B4%BB/:0:0","tags":null,"title":"Win10数字激活","uri":"/win10%E6%95%B0%E5%AD%97%E6%BF%80%E6%B4%BB/"},{"categories":["逆向"],"content":"紫狐分身概述 打开APP需要卡密验证，绕过卡密验证只需要劫持改包即可，具体见：火牛-紫狐分身的字符串加密-卡密验证环节破解。 正常卡密验证返回包为：{\"result\":{\"msg\":\"验证成功，卡密有效期至：2030-11-13 00:22:24\"},\"ts\":1634142164901,\"status\":1} 分身时会验证卡密是否曾经注册过，注册过则可以正常使用，否则不能正常使用，重点是：即时卡密过期也能正常使用。 ","date":"2021-09-18","objectID":"/%E7%81%AB%E7%89%9B%E5%88%86%E8%BA%AB%E7%A0%B4%E8%A7%A3%E8%BF%87%E7%A8%8B/:1:0","tags":["破解","APP"],"title":"火牛（紫狐）分身破解过程","uri":"/%E7%81%AB%E7%89%9B%E5%88%86%E8%BA%AB%E7%A0%B4%E8%A7%A3%E8%BF%87%E7%A8%8B/"},{"categories":["逆向"],"content":"第一步：卡密破解 ","date":"2021-09-18","objectID":"/%E7%81%AB%E7%89%9B%E5%88%86%E8%BA%AB%E7%A0%B4%E8%A7%A3%E8%BF%87%E7%A8%8B/:2:0","tags":["破解","APP"],"title":"火牛（紫狐）分身破解过程","uri":"/%E7%81%AB%E7%89%9B%E5%88%86%E8%BA%AB%E7%A0%B4%E8%A7%A3%E8%BF%87%E7%A8%8B/"},{"categories":["逆向"],"content":"抓包（过程略） 打开APP，随便输入一个卡密（随便几位数字），抓包查看请求和返回数据。 请求详情 卡密验证API为http://jyfya.top/Auth/Verify 返回详情 返回数据为： {\"code\":404,\"\"msg\":\"\\u6ce8\\u518c\\u7801\\u4e0d\\u5b58\\u5728\",\"data\":[]} 尝试将此处的404改为200，竟然成功。 ","date":"2021-09-18","objectID":"/%E7%81%AB%E7%89%9B%E5%88%86%E8%BA%AB%E7%A0%B4%E8%A7%A3%E8%BF%87%E7%A8%8B/:3:0","tags":["破解","APP"],"title":"火牛（紫狐）分身破解过程","uri":"/%E7%81%AB%E7%89%9B%E5%88%86%E8%BA%AB%E7%A0%B4%E8%A7%A3%E8%BF%87%E7%A8%8B/"},{"categories":["逆向"],"content":"破解 1、绕过卡密验证过程 搜索\"is_verify\" 在smali码里找到第45行，将const/4 v0,0x0改为const/4 v0,0x1 {height=“585px” width=“270px”} 这样打开APP就不会再有提示输入卡密的界面。 但是…..因为正常情况下，输入卡密，服务器验证成功后，会将卡密本地保存，以待后续使用APP时调用，如此直接绕过卡密验证过程，本地的卡密信息为空，在调用时会出错，导致添加分身后，进入分身配置界面时提示当前连接不到服务器，请稍后重试。APP无法继续使用。 2、去除当前连接不到服务器，请稍后重试弹窗 抓包发现跳这个弹窗前，APP发起了一个请求（http://hw.jyfya.top:8080/v4/now/?nonce=cloneuser\u0026token=\u0026appversioncode=312\u0026virtual_id=91d7ea36fee5bd281fd2a088810e8d20），目的不明，该请求的状态码是200，按理说应该不会弹当前连接不到服务器，请稍后重试，毕竟该请求是通的，但是响应体是空白的，估计是因为这个才导致弹窗的，但是没有正版卡密的情况下，不知道其正常的响应体长怎么样。 意外 在不停折腾过程中，某次偶然情况，我在卡密输入框里输入的中文，然后篡改卡密验证时的响应数据，结果在打开分身应用时竟然不再弹窗，再查看请求过程，发现响应体竟然有数据。 {height=“585px” width=“270px”} 至此，拿到了正常的响应体数据。 暴力去弹窗（备用） 根据弹窗当前连接不到服务器，请稍后重试中的关键字，全局代码搜索无果，搜索Arsc资源得到ID7f1100b3，以该ID在全局代码中搜索发现弹窗的逻辑。 {height=“585px” width=“270px”} 在smali码中将该方法删掉~~，再验证，发现不再弹窗了。 虚拟定位破解 经过第1、2步破解后，可以正常进入分身应用设置界面了。 但是又遇到新的问题： 在`位置保护`里选点虚拟位置后点击右下角`选择`时报错 {height=“585px” width=“270px”} 抓包发现点击右下角`选择`时，后台请求 {height=“585px” width=“270px”} 返回数据 {height=“585px” width=“270px”} 明显是服务器报错了，估计是因为token（即卡密）为中文导致的，后来尝试换成数字卡密还是会报错Null is not a valid element。 突破 意外情况曾经拿到了虚拟定位正常返回数据 {\"message\":\"success\",\"code\":200,\"data\":\"qv36S6TQFKpL4tieu90GS58wzdnSVR8/Qwkmcta8G7J/3KEIJNjmSR/2TBm/suMc\"} data值为使用AES-ECB-PK5加密的数据，data值解开后为形如以下结构的字符串(注意为字符串)： [{\"lat\":28.294743,\"lon\":112.896041}] +++success 抓包情况 ;;;id3 请求信息 请求方式：GET 请求URL：http://hw.jyfya.top:8080/v4/dbcell/?lat=28.288195462671396\u0026lon=112.9000414965204\u0026n=10\u0026mnc=1\u0026range=2\u0026gps=1\u0026incoord=bd09\u0026coord=bd09\u0026nonce=cloneuser\u0026token=6699666\u0026appversioncode=312\u0026virtual_id=91d7ea36fee5bd281fd2a088810e8d20 ;;; ;;;id3 请求头 User-Token: e3158c8b9687b4ca317b813431987b6c X-Mgs-Proxy-Signature: 53efd12b437a15b7e85d55441127ea8e X-UT-DID: HUAWEI_TAS-AN00|YUgEKXp38YEDAH5sndk4SKff X-CHANNEL: null User-Agant: B0a9ReUQDyrrqIRVHAMmXMQBYKbLssglkMXKUlEMd0szCaG0tpuZJv+bskFyD6Uh9T3Y7qpyiYaCkf7pyDemg== Host: hw.jyfya.top:8080 Connection: Keep-Alive Accept-Encoding: gzip User-Agent: okhttp/3.14.9 ;;; +++ +++ # 第二步：登录逆向 ","date":"2021-09-18","objectID":"/%E7%81%AB%E7%89%9B%E5%88%86%E8%BA%AB%E7%A0%B4%E8%A7%A3%E8%BF%87%E7%A8%8B/:3:1","tags":["破解","APP"],"title":"火牛（紫狐）分身破解过程","uri":"/%E7%81%AB%E7%89%9B%E5%88%86%E8%BA%AB%E7%A0%B4%E8%A7%A3%E8%BF%87%E7%A8%8B/"},{"categories":["逆向"],"content":"登录抓包情况 请求详情 返回详情 {\"message\": \"success\", \"code\": 200, \"data\": \"ZB5pocrTQ8oJg/iHuV8fAyO4ay7FfrpM/kDeD4lYZDjbEO4c/YAlio1WP8VkaWsDcpY0yF79RsDBf8/CKwNcNQionGuaPjKyan0NFe9vEYVrAMD0p4RX0m/qfqIdYK/fCwq0LrRFwe5wuLcv+YBFf+jUoCgOL0aQCWGtgRotMIgmEut7yOR340uXmYFKfO2s4jQY9yoPhP/t6+rLLAcINDvhILdYivbax7XKmZtQ1KtcEof3DC/kLwG4V6EurxgWV7it2XEryRiuUyrXKmxe3b2cG3EDxNoF8bZjEDZ+lET+rjaQ3ok0WY1yK5jrFIykdM7sGm7RN9cfRZk4sDRsGVR76HTz1dXuy58kLbozCLx4IAlZvl3gJIaNXZ1DjZg2j0vkQH7sKKO0ao8nZV6MPFFyChZdBOMvLbe+R1aQiWoBtlXcvOW+ug2B5ZfkmveG6u9zgk6qyEP5XEDYzzWfGSbh+L7p6zl0iBo4/Rfs/0WzqshBjv+W71Vi2lxQ3f4OLlBXVkodR5TtXRwwRCQB2mJAvqlFDpAhNcT76DQTdPMGdMjpxRpq29z02ipG5S0QAfn6rSjKTV1LWdoes1aEj1g2Rm8DEMUBX+Sm4syqe4A1ogd4DTABNSdgt+G4vrQ6Pxi7K6pFJf4JmPBaR3rwuigcNhkuUJlWekMl4oY0coVtn9yUIkIGwO9gJ5lrxSwniPASn10a5/KYDzmbEs/u4DKe8qp0yc962Op0rtjjDtp4PeEhSrC3iw2ORnZCsIC68hGPqwoUiJrice1m6KLTW5VKFZS2HhReSS7Jt52rMl4zayIwPBg3gh79Pi/0CXjkFvY53ctkzi0/evuqtiiBB9pibZB88KzUEVRzP/MlaYqUVJhrT5XIILTiLU1nkkqJeVuW3+Z2aWanydszY7pio7Esk9Qir4YHniLjfpOhCITCZeEbRzlAIvPbc3+6PRTp\"} 根据请求与返回情况，查找情况： 疑似登录逻辑代码所在类z1.w22，代码如下（找到以下代码走了很多弯路，花费很长时间，后来才发现，直接查找请求参数cloneuser可直接找到此处）： public static class d implements i30\u003cApiResult\u003e { /* renamed from: b */ public ApiResult a(j30 j30, Type type, h30 h30) throws n30 { if (!j30.A()) { return null; } m30 m30 = (m30) j30; int k = m30.K(\"code\").k(); String x = m30.P(\"message\") ? m30.K(\"message\").x() : \"\"; ApiResult apiResult = new ApiResult(); apiResult.setCode(k); apiResult.setMessage(x); Type type2 = ((ParameterizedType) type).getActualTypeArguments()[0]; j30 K = m30.K(\"data\"); if (apiResult.isSuccessSign()) { String x2 = m30.K(\"data\").x(); f0.i().q(o.C0); String destrcode = AES.destrcode(x2, \"a1ccb0d670efba1bc4353b1bc8ddf4f7\"); o30 o30 = new o30(); if (destrcode != null) { apiResult.setData(h30.a(o30.c(destrcode), type2)); apiResult.setCode(ApiResult.HTTP_OK); v.f(destrcode); } else { apiResult.setCode(ApiResult.HTTP_OK_SIGN_FAILE); } } else if (apiResult.isSuccess()) { apiResult.setData(h30.a(m30.K(\"data\"), type2)); } else if (K != null \u0026\u0026 (K.A() || K.y())) { apiResult.setData(h30.a(K, type2)); } if (k == ApiResult.TOKEN_EXPIRE) { zh2.f().q(new h22()); } return apiResult; } } 跟踪上面高亮行中的destrcode方法得到： public static String destrcode(String str, String str2) { try { byte[] b = b(str); String str3 = \"\"; for (byte b2 : b) { str3 = str3 + ((int) b2) + \",\"; } Cipher instance = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); instance.init(2, secretKeySpec(str2)); return new String(instance.doFinal(b), \"UTF-8\"); } catch (Exception e) { e.toString(); return null; } } 使用https://8gwifi.org/CipherFunctions.jsp解密成功，如下图： {height=“585px” width=“270px”} {\"radar_dl\": \"2019-01-01 00:00:00\", \"inchina\": 1, \"versioncode\": \"8\", \"tag\": 0, \"deadline\": 1696246150000, \"stonetime\": 1586396889000, \"googleversioncode\": \"-1\", \"points\": 0, \"viptype\": 6, \"username\": \"18276802235\", \"radar_viptype\": 6, \"inviteid\": \"GU5HB49X\", \"imsis\": \"\", \"virtual_id\": \"91d7ea36fee5bd281fd2a088810e8d20\", \"imeis\": \"58095A0D87FF688ACD1AFF7F90458AE0|Xiaomi_MI8SE,DF1E0D493251CEA30873A45A49D6CB53|HUAWEI_BKL-AL20 088E959F0FF35615BEC1DBF76CD6B107|Xiaomi_MINOTELTE\", \"invitenum\": 1, \"radar_userid\": \"None\", \"fatherid\": \"HDVDBGBD\", \"userid\": \"F68F66FC2B6F91C1FCE52A9AB531D07D|HUAWEI_BKL-AL20\", \"token\": \"e3158c8b9687b4ca317b813431987b6c\", \"vipphone\": \"\", \"channel\": \"zhuoyao\", \"starttime\": 1568120195000} +++ 适用于本教程AES加密解密的python脚本，来源：https://www.cxyzjd.com/article/weixin_43755186/108254464 import base64 from Crypto.Cipher import AES class EncryptDate: def __init__(self, key): self.key = key.encode(\"utf-8\") # 初始化密钥 self.length = AES.block_size # 初始化数据块大小 self.aes = AES.new(self.key, AES.MODE_ECB) # 初始化AES,ECB模式的实例 # 截断函数，去除填充的字符 self.unpad = lambda date: date[0 : -ord(date[-1])] def pad(self, text): \"\"\" #填充函数，使被加密数据的字节码长度是block_size的整数倍 \"\"\" count = len(text.encode(\"utf-8\")) add = self.length - (count % self.length) entext = text + (chr(add) * add) return entext def encrypt(self, encrData): # 加密函数 res = self.aes.encrypt(self.pad(encrDat","date":"2021-09-18","objectID":"/%E7%81%AB%E7%89%9B%E5%88%86%E8%BA%AB%E7%A0%B4%E8%A7%A3%E8%BF%87%E7%A8%8B/:3:2","tags":["破解","APP"],"title":"火牛（紫狐）分身破解过程","uri":"/%E7%81%AB%E7%89%9B%E5%88%86%E8%BA%AB%E7%A0%B4%E8%A7%A3%E8%BF%87%E7%A8%8B/"},{"categories":["逆向"],"content":"火牛-紫狐分身的字符串加密-卡密验证环节破解 字符串使用DES/CBC/PKCS5Padding模式进行了加密（在线加解密地址），加密密钥和偏移量均为JkmuyJoL的HEX码\"4a 6b 6d 75 79 4a 6f 4c\"。 比如：请输入卡密，加密后的字符串变为：4D4EB9A4E93156AD7D2FD9C80AC8ACBB， 加密过程截图 {height=“585px” width=“270px”} 故如要通过APP的字符串来搜索代码进行逆向，需要先将字符串按上述模式进行加密，获取对应HEX码，再进行搜索。 通过以上方式加密卡密验证请求参数platorm字符串，再用加密后字符串进行搜索，来到以下代码： public static String m540(String str, int i, Map\u003cString, String\u003e map) { Throwable th; Throwable th2; BufferedReader bufferedReader = null; if (i \u003e f34070) { return null; } try { if (C9808.m553(map)) { map = new Hashtable(); } map.put(CryptoBox.decrypt(\"01CEACFC0AF45D87\"), App.APP_ID);//app_id map.put(CryptoBox.decrypt(\"9DDC6D94B5D5A82195F4039E4BCB96E9\"), C9823.m570(App.getContext()));//device_code map.put(CryptoBox.decrypt(\"F933F932FC1BBCC4F641AA1302651920\"), String.valueOf(App.f34457));//platform map.put(CryptoBox.decrypt(\"755D2E8EE7A5F9617BF0CDC6C3476784\"), String.valueOf(App.f34458));//api_version map.put(CryptoBox.decrypt(\"F06BA0D8EBD24E7610D4F2CE7DB58654\"), App.f34452); //app_version map.put(CryptoBox.decrypt(\"9752D144A1F714491ACBD84E2BFEDD05\"), String.valueOf(App.f34456));//version_code HttpURLConnection httpURLConnection = (HttpURLConnection) new URL(str + CryptoBox.decrypt(\"9BECF8203DFEAF53\") + m541(map)).openConnection();// ? httpURLConnection.setConnectTimeout(2000); httpURLConnection.setReadTimeout(2000); httpURLConnection.connect(); BufferedReader bufferedReader2 = new BufferedReader(new InputStreamReader(httpURLConnection.getInputStream(), CryptoBox.decrypt(\"13169925E946FA96\")));//utf-8 try { StringBuilder sb = new StringBuilder(); while (true) { String readLine = bufferedReader2.readLine(); if (readLine == null) { break; } sb.append(readLine);//字符串拼接 } // 此处的C9804.m548的代码在下面贴出（通过可以阅读看出是求MD5的方法。即：eagleid算法为：拼接返回值的每一行，再拼接'1'后将字符串求MD5。 if (!httpURLConnection.getHeaderField(CryptoBox.decrypt(\"D29A3C6F78CE2E83\")).equals(C9804.m548(sb.toString().concat(CryptoBox.decrypt(\"19B19EF55618DC53\"))))) {//前：eagleid ，后：1 C9812.m559(bufferedReader2); return null; } String sb2 = sb.toString(); C9812.m559(bufferedReader2); return sb2; } catch (Throwable th3) { th = th3; bufferedReader = bufferedReader2; C9812.m559(bufferedReader); throw th; } } catch (Throwable th4) { th2 = th4; m542(CryptoBox.decrypt(\"8E90A3E7E9C0E8EE9D221F6DC0BC9B82\"), C9810.m557(App.getContext(), th2));//http error. Thread.sleep(100); String r8 = m540(str, i + 1, map); C9812.m559(bufferedReader); return r8; } } package p011cd; import java.io.PrintStream; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import rxc.internal.operators.CryptoBox; /* renamed from: cd.̗̙̖̗̖̖ */ public class C9804 { /* renamed from: ̗ */ protected static MessageDigest f497; /* renamed from: ̗ */ protected static char[] f498 = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'}; static { f497 = null; try { f497 = MessageDigest.getInstance(CryptoBox.decrypt(\"019EDB52DF54D0CF\"));//MD5 } catch (NoSuchAlgorithmException e) { PrintStream printStream = System.err; printStream.println(C9804.class.getName() + CryptoBox.decrypt(\"1C63A63473AFCA62EB0ED209B599B1D195382B0F8E6F0CFFBB0D002A1603C36F8787230B9932B9F170BF114D256396D801FAD473922044F2\"));//初始化失败，MessageDigest不支持MD5Util。 e.printStackTrace(); } } /* renamed from: ̗̖ */ public static String m548(String str) { f497.update(str.getBytes()); byte[] digest = f497.digest(); int length = digest.length; StringBuffer stringBuffer = new StringBuffer(length * 2); int i = length + 0; for (int i2 = 0; i2 \u003c i; i2++) { byte b = digest[i2]; char[] cArr = f498; char c = cArr[(b \u0026 240) \u003e\u003e 4]; char c2 = cArr[b \u0026 15]; stringBuffer.append(c); stringBuffer.append(c2); } return stringBuffer.toString(); } } ","date":"2021-09-18","objectID":"/%E7%81%AB%E7%89%9B%E5%88%86%E8%BA%AB%E7%A0%B4%E8%A7%A3%E8%BF%87%E7%A8%8B/:4:0","tags":["破解","APP"],"title":"火牛（紫狐）分身破解过程","uri":"/%E7%81%AB%E7%89%9B%E5%88%86%E8%BA%AB%E7%A0%B4%E8%A7%A3%E8%BF%87%E7%A8%8B/"},{"categories":["逆向"],"content":"分身过程逆向 经过分析，分身过程的请求参数key并未加密，但是参数值存在大量的 直接搜索\"appversioncode\"即可找出来: private class C8579b implements ehh { private C8579b() { } @Override // p109z1.ehh /* renamed from: a */ public ehp mo59189a(ehh.AbstractC8788a aVar) throws IOException { ehn a = aVar.mo59741a(); ehn.C8795a f = a.mo59874f(); if (a.mo59868a().toString().contains(PathConst.f18227e)) { f.mo59891b(\"User-Agent\", dwc.m44271a().mo59261b(AppConst.f18045e)).mo59891b(\"User-Md5\", duz.m43551r()); } else if (a.mo59868a().toString().contains(PathConst.f18222a)) { String str = RetrofitHelper.m43305b() + \"\"; String str2 = (dwj.m44508d() / 1000) + \"\"; ehg.C8787a a2 = a.mo59868a().mo59708v().mo59714a(\"nonce\", str).mo59714a(C9111lm.f32050f, str2).mo59714a(\"appversioncode\", duz.m43543n() + \"\").mo59714a(\"signature\", RetrofitHelper.this.m43304a(a, str, duz.m43547p().toLowerCase(), str2)); if (UserManager.m43341a().mo59207b()) { a2.mo59714a(\"token\", ShTool.mGetString(dwm.m44562a(), \"token\", dwc.m44271a().mo59261b(AppConst.f18009aE))); a2.mo59714a(\"virtual_id\", UserManager.m43341a().mo59208c().getVirtualId()); a2.mo59714a(\"ut_did\", PhoneUtils.m44228e()); } ehg c = a2.mo59723c(); dvs.m44154a((Object) (\"---------\" + c.mo59679a().toString())); f.mo59887a(c); } return aVar.mo59742a(f.mo59896d()); } } ","date":"2021-09-18","objectID":"/%E7%81%AB%E7%89%9B%E5%88%86%E8%BA%AB%E7%A0%B4%E8%A7%A3%E8%BF%87%E7%A8%8B/:5:0","tags":["破解","APP"],"title":"火牛（紫狐）分身破解过程","uri":"/%E7%81%AB%E7%89%9B%E5%88%86%E8%BA%AB%E7%A0%B4%E8%A7%A3%E8%BF%87%E7%A8%8B/"},{"categories":["Other"],"content":"主板详情 主板系列 战斧系列,Intel系列 芯片组 Intel B360 CPU支持 支持Intel LGA1151接口Coffee Lake系列处理器（TDP:65W） 内存支持 2个内存条插槽，总内存容量最大支持32GB， 支持DDR4双通道2133/2400/2666MHZ规格内存 显卡支持 1个PCI Express3.0X16 插槽 存储接口 4个SATA3.0 6Gb/s接口 扩展接口 I/O：1组PS2鼠标和键盘端口，1个HDMI接口，1个DVI接口，1个VGA接口，4个USB3.0接口, 1个 RJ45网络接口，3个音频输入输出接孔（6声道支持）; 板载（可扩展）： 2组9-pin USB2.0针脚， 1组19-pin USB3.0针脚,1组9-pin COM针脚 扩展插槽 1个PCI Express3.0X16 插槽， 1个PCI Express3.0X1 插槽， 1个M.2插槽（支持M.2 PCI-e x4 \u0026 SATA SSD，支持2242/2260/2280规格的SSD，数据传输率最高可达32Gb/s。) 系统BIOS 128M UEFI，支持多国语言 电源管理 支持S3、S4、S5唤醒 支持定时开机、来电开机、网络S5唤醒 硬件监控 CPU风扇转速可控，SYSTEM风扇转速监视 CPU温度监视，System温度监视，及各组电压监视 板载网卡 RTL8111H 千兆 板载声卡 ALC662 六声道 主板规格 225 x 185mm mATX ","date":"2021-09-17","objectID":"/%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/:0:0","tags":null,"title":"我的主板","uri":"/%E6%88%91%E7%9A%84%E7%94%B5%E8%84%91%E9%85%8D%E7%BD%AE/"},{"categories":["Windows"],"content":"安装到移动硬盘的方式 在正常的windows系统中使用rufus工具写入镜像到移动硬盘 ","date":"2021-09-16","objectID":"/%E5%90%AF%E7%94%A8%E5%A4%87%E7%94%A8%E7%B3%BB%E7%BB%9F/:1:0","tags":null,"title":"启用备用系统","uri":"/%E5%90%AF%E7%94%A8%E5%A4%87%E7%94%A8%E7%B3%BB%E7%BB%9F/"},{"categories":["Windows"],"content":"rufus工具设置 设置rufus，以显示移动硬盘 默认情况下rufus只显示U盘，要让其显示移动硬盘，需要在显示高级设备选项下勾选显示 USB 外置硬盘 镜像选项选择 选择Window To Go 其他保持默认即可 ","date":"2021-09-16","objectID":"/%E5%90%AF%E7%94%A8%E5%A4%87%E7%94%A8%E7%B3%BB%E7%BB%9F/:1:1","tags":null,"title":"启用备用系统","uri":"/%E5%90%AF%E7%94%A8%E5%A4%87%E7%94%A8%E7%B3%BB%E7%BB%9F/"},{"categories":["Windows"],"content":"修改引导方式 进入BIOS，将引导方式由Legacy改为UEFI, ","date":"2021-09-16","objectID":"/%E5%90%AF%E7%94%A8%E5%A4%87%E7%94%A8%E7%B3%BB%E7%BB%9F/:2:0","tags":null,"title":"启用备用系统","uri":"/%E5%90%AF%E7%94%A8%E5%A4%87%E7%94%A8%E7%B3%BB%E7%BB%9F/"},{"categories":["Windows"],"content":"从移动硬盘启动 重启系统，BIOS将默认自动从移动硬盘启动进入系统 ","date":"2021-09-16","objectID":"/%E5%90%AF%E7%94%A8%E5%A4%87%E7%94%A8%E7%B3%BB%E7%BB%9F/:3:0","tags":null,"title":"启用备用系统","uri":"/%E5%90%AF%E7%94%A8%E5%A4%87%E7%94%A8%E7%B3%BB%E7%BB%9F/"},{"categories":["Windows"],"content":"切换内置硬盘系统 只需要进入BIOS，将引导方式由UEFI改为Legacy即可, ","date":"2021-09-16","objectID":"/%E5%90%AF%E7%94%A8%E5%A4%87%E7%94%A8%E7%B3%BB%E7%BB%9F/:4:0","tags":null,"title":"启用备用系统","uri":"/%E5%90%AF%E7%94%A8%E5%A4%87%E7%94%A8%E7%B3%BB%E7%BB%9F/"},{"categories":["Docker"],"content":" docker run -dit \\ -v /userdatas/Sandisk/ql/config:/ql/config \\ -v /userdatas/Sandisk/ql/log:/ql/log \\ -v /userdatas/Sandisk/ql/db:/ql/db \\ -v /userdatas/Sandisk/ql/repo:/ql/repo \\ -v /userdatas/Sandisk/ql/raw:/ql/raw \\ -v /userdatas/Sandisk/ql/scripts:/ql/scripts \\ -v /userdatas/Sandisk/ql/jbot:/ql/jbot \\ -v /userdatas/Sandisk/ql/ninja:/ql/ninja \\ -p 5678:5700 \\ -p 6789:5701 \\ --name qinglong \\ --restart unless-stopped \\ whyour/qinglong:latest ","date":"2021-09-07","objectID":"/docker%E6%90%AD%E5%BB%BA%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF/:0:0","tags":null,"title":"Docker搭建青龙面板","uri":"/docker%E6%90%AD%E5%BB%BA%E9%9D%92%E9%BE%99%E9%9D%A2%E6%9D%BF/"},{"categories":["法律"],"content":" 对于运营商电话卡实名核验的监管，《网络安全法》第六十一条规定“由有关主管部门”管辖，并未明确由公安机关管辖，《反恐法》与《网络安全法》类似。 查找电信入网方面的监管主体相关规定，发现工信部发布的《电话用户真实身份信息登记规定》中明确规定，电话用户实名核验属于工信及其所属通管部门负责管辖。 另：对于公安机关在运营商黑卡中扮演的角色，《江苏省电话用户真实身份信息登记管理规定》（全文链接）第十六条规定“公安机关负责依法处理利用非实名电话卡实施的违法犯罪活动和倒卖移动号卡等违法行为”。 而公安部151号令《公安机关互联网安全监督检查规定》则通篇没有提过电话用户实名核验属于公安机关管辖，跟运营商有关的，只提到“对提供互联网接入服务的，监督检查是否记录并留存网络地址及分配使用情况”（第十一条第一项）和“报送接入单位和用户基本信息及其变更情况”（第十条**第一项）。 公安部关于印发《违反\u003c网络安全法\u003e行为名称及适用条款》的通知（公网安[2019]566号），此通知的概述中讲了目的：“为规范《网络安全法》涉及网络违法行为名称及其适用，提供公安机关网络安全行政执法的规范化水平”。最后一段描述为：“对上述违法行为，除《网络安全法》明确规定由公安机关实施行政处罚的之外，公安机关实施行政处罚限于公安机关监管范围。”，意思是此通知不作为明确监管主体依据。 ","date":"2021-09-06","objectID":"/%E8%BF%90%E8%90%A5%E5%95%86%E5%BC%80%E9%BB%91%E5%8D%A1%E8%A1%8C%E4%B8%BA-%E7%AE%A1%E8%BE%96%E4%B8%BB%E4%BD%93%E6%80%9D%E8%80%83/:0:0","tags":null,"title":"“运营商开黑卡行为” 管辖主体思考","uri":"/%E8%BF%90%E8%90%A5%E5%95%86%E5%BC%80%E9%BB%91%E5%8D%A1%E8%A1%8C%E4%B8%BA-%E7%AE%A1%E8%BE%96%E4%B8%BB%E4%BD%93%E6%80%9D%E8%80%83/"},{"categories":["法律"],"content":"结论 公安机关不属于“运营商开黑卡行为”的管辖主体。 ","date":"2021-09-06","objectID":"/%E8%BF%90%E8%90%A5%E5%95%86%E5%BC%80%E9%BB%91%E5%8D%A1%E8%A1%8C%E4%B8%BA-%E7%AE%A1%E8%BE%96%E4%B8%BB%E4%BD%93%E6%80%9D%E8%80%83/:1:0","tags":null,"title":"“运营商开黑卡行为” 管辖主体思考","uri":"/%E8%BF%90%E8%90%A5%E5%95%86%E5%BC%80%E9%BB%91%E5%8D%A1%E8%A1%8C%E4%B8%BA-%E7%AE%A1%E8%BE%96%E4%B8%BB%E4%BD%93%E6%80%9D%E8%80%83/"},{"categories":["法律"],"content":"附 ","date":"2021-09-06","objectID":"/%E8%BF%90%E8%90%A5%E5%95%86%E5%BC%80%E9%BB%91%E5%8D%A1%E8%A1%8C%E4%B8%BA-%E7%AE%A1%E8%BE%96%E4%B8%BB%E4%BD%93%E6%80%9D%E8%80%83/:2:0","tags":null,"title":"“运营商开黑卡行为” 管辖主体思考","uri":"/%E8%BF%90%E8%90%A5%E5%95%86%E5%BC%80%E9%BB%91%E5%8D%A1%E8%A1%8C%E4%B8%BA-%E7%AE%A1%E8%BE%96%E4%B8%BB%E4%BD%93%E6%80%9D%E8%80%83/"},{"categories":["法律"],"content":"《网络安全法》关于实名核验规定的摘取 第八条　国家网信部门负责统筹协调网络安全工作和相关监督管理工作。国务院电信主管部门、公安部门和其他有关机关依照本法和有关法律、行政法规的规定，在各自职责范围内负责网络安全保护和监督管理工作。 县级以上地方人民政府有关部门的网络安全保护和监督管理职责，按照国家有关规定确定。 第二十四条　网络运营者为用户办理网络接入、域名注册服务，办理固定电话、移动电话等入网手续，或者为用户提供信息发布、即时通讯等服务，在与用户签订协议或者确认提供服务时，应当要求用户提供真实身份信息。用户不提供真实身份信息的，网络运营者不得为其提供相关服务。 国家实施网络可信身份战略，支持研究开发安全、方便的电子身份认证技术，推动不同电子身份认证之间的互认。 第六十一条　网络运营者违反本法第二十四条第一款规定，未要求用户提供真实身份信息，或者对不提供真实身份信息的用户提供相关服务的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。 第七十六条　本法下列用语的含义： （三）网络运营者，是指网络的所有者、管理者和网络服务提供者。 ","date":"2021-09-06","objectID":"/%E8%BF%90%E8%90%A5%E5%95%86%E5%BC%80%E9%BB%91%E5%8D%A1%E8%A1%8C%E4%B8%BA-%E7%AE%A1%E8%BE%96%E4%B8%BB%E4%BD%93%E6%80%9D%E8%80%83/:2:1","tags":null,"title":"“运营商开黑卡行为” 管辖主体思考","uri":"/%E8%BF%90%E8%90%A5%E5%95%86%E5%BC%80%E9%BB%91%E5%8D%A1%E8%A1%8C%E4%B8%BA-%E7%AE%A1%E8%BE%96%E4%B8%BB%E4%BD%93%E6%80%9D%E8%80%83/"},{"categories":["法律"],"content":"《电话用户真实身份信息登记规定》关于实名核验规定的摘取 全文链接：http://www.gov.cn/gongbao/content/2013/content_2473882.htm 第二条　中华人民共和国境内的电话用户真实身份信息登记活动，适用本规定。 第三条　本规定所称电话用户真实身份信息登记，是指电信业务经营者为用户办理固定电话、移动电话（含无线上网卡，下同）等入网手续，在与用户签订协议或者确认提供服务时，如实登记用户提供的真实身份信息的活动。 本规定所称入网，是指用户办理固定电话装机、移机、过户，移动电话开户、过户等。 第四条　工业和信息化部和各省、自治区、直辖市通信管理局（以下统称电信管理机构）依法对电话用户真实身份信息登记工作实施监督管理。 ","date":"2021-09-06","objectID":"/%E8%BF%90%E8%90%A5%E5%95%86%E5%BC%80%E9%BB%91%E5%8D%A1%E8%A1%8C%E4%B8%BA-%E7%AE%A1%E8%BE%96%E4%B8%BB%E4%BD%93%E6%80%9D%E8%80%83/:2:2","tags":null,"title":"“运营商开黑卡行为” 管辖主体思考","uri":"/%E8%BF%90%E8%90%A5%E5%95%86%E5%BC%80%E9%BB%91%E5%8D%A1%E8%A1%8C%E4%B8%BA-%E7%AE%A1%E8%BE%96%E4%B8%BB%E4%BD%93%E6%80%9D%E8%80%83/"},{"categories":["法律"],"content":"公安部151号令《公安机关互联网安全监督检查规定》部分摘取 http://www.gov.cn/gongbao/content/2018/content_5343745.htm 第三条　本规定适用于公安机关依法对互联网服务提供者和联网使用单位履行法律、行政法规规定的网络安全义务情况进行的安全监督检查。 （明确监管对象） 第九条　公安机关应当根据网络安全防范需要和网络安全风险隐患的具体情况，对下列互联网服务提供者和联网使用单位开展监督检查： （进一步明确监管对象） （一）提供互联网接入、互联网数据中心、内容分发、域名服务的； （二）提供互联网信息服务的； （三）提供公共上网服务的； （四）提供其他互联网服务的。 第十条　公安机关应当根据互联网服务提供者和联网使用单位履行法定网络安全义务的实际情况，依照国家有关规定和标准，对下列内容进行监督检查： （明确被监管对象的哪些法律行为属于公安机关管辖） （一）是否办理联网单位备案手续，并报送接入单位和用户基本信息及其变更情况； （二）是否制定并落实网络安全管理制度和操作规程，确定网络安全负责人； （三）是否依法采取记录并留存用户注册信息和上网日志信息的技术措施； （四）是否采取防范计算机病毒和网络攻击、网络侵入等技术措施； （五）是否在公共信息服务中对法律、行政法规禁止发布或者传输的信息依法采取相关防范措施； （六）是否按照法律规定的要求为公安机关依法维护国家安全、防范调查恐怖活动、侦查犯罪提供技术支持和协助； （七）是否履行法律、行政法规规定的网络安全等级保护等义务。 第十一条　除本规定第十条所列内容外，公安机关还应当根据提供互联网服务的类型，对下列内容进行监督检查： （明确被监管对象的哪些法律行为属于公安机关管辖） （一）对提供互联网接入服务的，监督检查是否记录并留存网络地址及分配使用情况； （二）对提供互联网数据中心服务的，监督检查是否记录所提供的主机托管、主机租用和虚拟空间租用的用户信息； （三）对提供互联网域名服务的，监督检查是否记录网络域名申请、变动信息，是否对违法域名依法采取处置措施； （四）对提供互联网信息服务的，监督检查是否依法采取用户发布信息管理措施，是否对已发布或者传输的法律、行政法规禁止发布或者传输的信息依法采取处置措施，并保存相关记录； （五）对提供互联网内容分发服务的，监督检查是否记录内容分发网络与内容源网络链接对应情况； （六）对提供互联网公共上网服务的，监督检查是否采取符合国家标准的网络与信息安全保护技术措施。 ","date":"2021-09-06","objectID":"/%E8%BF%90%E8%90%A5%E5%95%86%E5%BC%80%E9%BB%91%E5%8D%A1%E8%A1%8C%E4%B8%BA-%E7%AE%A1%E8%BE%96%E4%B8%BB%E4%BD%93%E6%80%9D%E8%80%83/:2:3","tags":null,"title":"“运营商开黑卡行为” 管辖主体思考","uri":"/%E8%BF%90%E8%90%A5%E5%95%86%E5%BC%80%E9%BB%91%E5%8D%A1%E8%A1%8C%E4%B8%BA-%E7%AE%A1%E8%BE%96%E4%B8%BB%E4%BD%93%E6%80%9D%E8%80%83/"},{"categories":["法律"],"content":"《反恐法》关于运营商实名核验的摘取 第八条 公安机关、国家安全机关和人民检察院、人民法院、司法行政机关以及其他有关国家机关，应当根据分工，实行工作责任制，依法做好反恐怖主义工作。 中国人民解放军、中国人民武装警察部队和民兵组织依照本法和其他有关法律、行政法规、军事法规以及国务院、中央军事委员会的命令，并根据反恐怖主义工作领导机构的部署，防范和处置恐怖活动。 有关部门应当建立联动配合机制，依靠、动员村民委员会、居民委员会、企业事业单位、社会组织，共同开展反恐怖主义工作。 第二十一条 电信、互联网、金融、住宿、长途客运、机动车租赁等业务经营者、服务提供者，应当对客户身份进行查验。对身份不明或者拒绝身份查验的，不得提供服务。 第八十六条 电信、互联网、金融业务经营者、服务提供者未按规定对客户身份进行查验，或者对身份不明、拒绝身份查验的客户提供服务的，主管部门应当责令改正；拒不改正的，处二十万元以上五十万元以下罚款，并对其直接负责的主管人员和其他直接责任人员处十万元以下罚款；情节严重的，处五十万元以上罚款，并对其直接负责的主管人员和其他直接责任人员，处十万元以上五十万元以下罚款。 住宿、长途客运、机动车租赁等业务经营者、服务提供者有前款规定情形的，由主管部门处十万元以上五十万元以下罚款，并对其直接负责的主管人员和其他直接责任人员处十万元以下罚款。 ","date":"2021-09-06","objectID":"/%E8%BF%90%E8%90%A5%E5%95%86%E5%BC%80%E9%BB%91%E5%8D%A1%E8%A1%8C%E4%B8%BA-%E7%AE%A1%E8%BE%96%E4%B8%BB%E4%BD%93%E6%80%9D%E8%80%83/:2:4","tags":null,"title":"“运营商开黑卡行为” 管辖主体思考","uri":"/%E8%BF%90%E8%90%A5%E5%95%86%E5%BC%80%E9%BB%91%E5%8D%A1%E8%A1%8C%E4%B8%BA-%E7%AE%A1%E8%BE%96%E4%B8%BB%E4%BD%93%E6%80%9D%E8%80%83/"},{"categories":["Python"],"content":"安装 pip install pipreqs ","date":"2021-09-03","objectID":"/pipreqs%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91/:1:0","tags":null,"title":"pipreqs使用踩坑","uri":"/pipreqs%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91/"},{"categories":["Python"],"content":"使用 pipreqs . ","date":"2021-09-03","objectID":"/pipreqs%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91/:2:0","tags":null,"title":"pipreqs使用踩坑","uri":"/pipreqs%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91/"},{"categories":["Python"],"content":"GBK报错 加 --encoding=utf8参数 pipreqs . --encoding=utf8 ","date":"2021-09-03","objectID":"/pipreqs%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91/:3:0","tags":null,"title":"pipreqs使用踩坑","uri":"/pipreqs%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91/"},{"categories":["Python"],"content":"check_hostname requires server_hostname 这可能是因为使用代理造成的，不管怎么样，解决方法是降低urllib3版本： pip install urllib3==1.25.11 ","date":"2021-09-03","objectID":"/pipreqs%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91/:4:0","tags":null,"title":"pipreqs使用踩坑","uri":"/pipreqs%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91/"},{"categories":["手机"],"content":" Microsoft Windows [版本 10.0.17763.2114] (c) 2018 Microsoft Corporation。保留所有权利。 #音乐 adb shell pm uninstall --user 0 com.android.mediacenter Success #主题 adb shell pm uninstall --user 0 com.huawei.android.thememanager Success #应用市场 adb shell pm uninstall --user 0 com.huawei.appmarket Success #收音机 adb shell pm uninstall --user 0 com.huawei.android.FMRadio Success #讯飞语音引擎 adb shell pm uninstall --user 0 com.iflytek.speechsuite Success #手机服务 adb shell pm uninstall --user 0 com.huawei.phoneservice Success #百度华为输入法 adb shell pm uninstall --user 0 com.huawei.hwvplayer.youku Success adb shell pm uninstall --user 0 com.baidu.input_huawei Success adb shell pm uninstall --user 0 com.android.wallpaper.holospiral Success #打印服务 adb shell pm uninstall --user 0 com.android.printspooler Success #黄页 adb shell pm uninstall --user 0 com.huawei.yellowpage Success adb shell pm uninstall --user 0 com.huawei.vassistant Success #服务手册 adb shell pm uninstall --user 0 com.huawei.hwstartupguide Success adb shell pm uninstall --user 0 com.svox.pico Success #华为支付 adb shell pm uninstall --user 0 com.huawei.android.hwpay Success adb shell pm uninstall --user 0 com.android.wallpaper.livepicker Success adb shell pm uninstall --user 0 com.android.phasebeam Success adb shell pm uninstall --user 0 com.android.galaxy4 Success #基本互动屏保 adb shell pm uninstall --user 0 com.android.dreams.basic Success #浏览器 adb shell pm uninstall --user 0 com.android.browser Success adb shell pm uninstall --user 0 com.android.noisefield Success #情景智能 adb shell pm uninstall --user 0 com.huawei.intelligent Success #手机找回 adb shell pm uninstall --user 0 com.huawei.android.remotecontrol Success #天气 adb shell pm uninstall --user 0 com.huawei.android.totemweather Success #相册桌面 adb shell pm uninstall --user 0 com.android.dreams.phototable Success #文档 adb shell pm uninstall --user 0 com.android.documentsui Success #文件管理 adb shell pm uninstall --user 0 com.huawei.hidisk Success #系统更新 adb shell pm uninstall --user 0 com.huawei.android.hwouc Success #悬浮按钮？ adb shell pm uninstall --user 0 com.huawei.android.FloatTasks Success adb shell pm uninstall --user 0 com.huawei.internetaudioservice Success #负一屏 adb shell pm uninstall --user 0 com.huawei.hiboard Success adb shell pm uninstall --user 0 com.google.android.marvin.talkback Success #APP标签 adb shell pm uninstall --user 0 com.android.apps.tag Success #邮箱 adb shell pm uninstall --user 0 com.android.email Success #日历 adb shell pm uninstall --user 0 com.android.calendar Success #日历存储 adb shell pm uninstall --user 0 com.android.providers.calendar Success #手势服务 adb shell pm uninstall --user 0 com.huawei.motionservice Success #推送 adb shell pm uninstall --user 0 com.huawei.android.pushagent Success ","date":"2021-09-02","objectID":"/mate8%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%88%A0%E9%99%A4%E8%AE%B0%E5%BD%95/:0:0","tags":null,"title":"mate8内置应用删除记录","uri":"/mate8%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%88%A0%E9%99%A4%E8%AE%B0%E5%BD%95/"},{"categories":["Docker"],"content":"来源：https://docs.linuxserver.io/images/docker-jellyfin#environment-variables-e docker run -d \\ --name=jellyfin \\ -e PUID=1000 \\ -e PGID=1000 \\ -e TZ=Aisa/Shanghai \\ -p 8096:8096 \\ -p 8920:8920 `#optional` \\ -p 7359:7359/udp `#optional` \\ -p 1900:1900/udp `#optional` \\ -v /userdatas/Sandisk/Jellyfin/config:/config \\ -v /userdatas/Sandisk/Jellyfin/tvseries:/data/tvshows `#optional` \\ -v /userdatas/Sandisk/Jellyfin/movies:/data/movies `#optional` \\ --restart unless-stopped \\ ghcr.io/linuxserver/jellyfin ","date":"2021-09-01","objectID":"/docker%E6%90%AD%E5%BB%BAjellyfin/:0:0","tags":null,"title":"Docker搭建Jellyfin","uri":"/docker%E6%90%AD%E5%BB%BAjellyfin/"},{"categories":["电视盒子"],"content":"tox1刷slimbox 工具使用Amlogic USB_Burning Tool v3.1.0.zip (点击下载) 其他版本在此 1.下载固件(点击进入下载页面)，导入UBT中 2.准备USB公对公线，一头先连接tox1，用牙签顶住tox1的复位按钮，再将USB公对公线另一头连接电脑，等UBT上显示连接成功后送掉牙签。 刷入时记得将擦除Bootloader勾选去掉，否则不能刷入。 ","date":"2021-09-01","objectID":"/slimbox%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/:1:0","tags":null,"title":"slimbox折腾记录","uri":"/slimbox%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"},{"categories":["电视盒子"],"content":"slimbox配置记录 开启File Server后，手机需要用ES文件的网络 局域网进行扫描发现，PC端暂未测试如何连接。 ","date":"2021-09-01","objectID":"/slimbox%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/:2:0","tags":null,"title":"slimbox折腾记录","uri":"/slimbox%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"},{"categories":["手机"],"content":"文末附下载地址 ","date":"2021-08-30","objectID":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/:0:0","tags":["手机"],"title":"免ROOT删除华为手机内置应用工具及教程","uri":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/"},{"categories":["手机"],"content":"原理：adb调试情况下，将系统应用禁用 ECHO OFF MODE con: COLS=80 LINES=38 TITLE EMUI 系统精简 color 3f :STARTS CLS ECHO. 华为系统精简 ECHO. ============================================================================= ECHO. 请确定已经安装好驱动,并以经打开USB调试模式 ECHO. 双清系统后，应用自动恢复 华为花粉俱乐部 ECHO. ============================================================================== ECHO. 功能选择项（请输入相对应的序号按回车键确认）： ECHO. ECHO. 华为系统类 测试命令类 ECHO. ECHO. 1.卸载 华山动态 27.卸载 相机 0.查看连接设备状态 ECHO. 2.卸载 学生模式 28.卸载 备份 80.卸载Google套件 ECHO. 3.卸载 推送体验上传 29.卸载 华为移动服务 81.查看系统应用 ECHO. 4.卸载 互动图片屏保 30.卸载 会员服务 82.屏幕分辨率 ECHO. 5.卸载 文件取词标记 31.卸载 游戏助手 83.修改屏幕密度480 ECHO. 6.卸载 天际通 32.卸载 工作资料设置 84.完美动画修改0.76 ECHO. 7.卸载 K歌htm打印 33.卸载 彩信服务 85.查看电池状态 ECHO. 8.卸载 百度输入法 34.卸载 杂志锁屏 86.进入BL模式 ECHO. 9.卸载 隐私空间 35.卸载 华为浏览器 87.进入REC模式 ECHO.10.卸载 智慧搜索 36.卸载 手势服务 88.禁止系统更新 ECHO.11.卸载 智能截屏 37.卸载 智能检测 89.重新启动 ECHO.12.卸载 智能识屏 38.卸载 省电精灵 ECHO.13.卸载 语音助手 39.卸载 查找手机 ECHO.14.卸载 sim卡应用 40.卸载 计算器 ECHO.15.卸载 搜狐讯飞引擎 41.卸载 电子邮件 ECHO.16.卸载 华为share 42.卸载 图库 ECHO.17.卸载 悬浮导航 43.卸载 个人紧急信息 ECHO.18.卸载 灭屏显示 44.卸载 智能助手 ECHO.19.卸载 视频编辑 45.卸载 融合定位 ECHO.20.卸载 多屏互动 46.卸载 时钟 ECHO.21.卸载 备忘录 47.卸载 主题 ECHO.22.卸载 音乐视频 48.卸载 应用商店 ECHO.23.卸载 桌面 ECHO.24.卸载 华为钱包 NFC ECHO.25.卸载 银联支付保护 ECHO.26.卸载 镜子 ECHO. ……………………………………………………………………………………………………… set choice= set /p choice=输入对应数字，然后按回车键（Success代表成功）: if /i \"%choice%\"==\"0\" goto 0 if /i \"%choice%\"==\"1\" goto 1 if /i \"%choice%\"==\"2\" goto 2 if /i \"%choice%\"==\"3\" goto 3 if /i \"%choice%\"==\"4\" goto 4 if /i \"%choice%\"==\"5\" goto 5 if /i \"%choice%\"==\"6\" goto 6 if /i \"%choice%\"==\"7\" goto 7 if /i \"%choice%\"==\"8\" goto 8 if /i \"%choice%\"==\"9\" goto 9 if /i \"%choice%\"==\"10\" goto 10 if /i \"%choice%\"==\"11\" goto 11 if /i \"%choice%\"==\"12\" goto 12 if /i \"%choice%\"==\"13\" goto 13 if /i \"%choice%\"==\"14\" goto 14 if /i \"%choice%\"==\"15\" goto 15 if /i \"%choice%\"==\"16\" goto 16 if /i \"%choice%\"==\"17\" goto 17 if /i \"%choice%\"==\"18\" goto 18 if /i \"%choice%\"==\"19\" goto 19 if /i \"%choice%\"==\"20\" goto 20 if /i \"%choice%\"==\"21\" goto 21 if /i \"%choice%\"==\"22\" goto 22 if /i \"%choice%\"==\"23\" goto 23 if /i \"%choice%\"==\"24\" goto 24 if /i \"%choice%\"==\"25\" goto 25 if /i \"%choice%\"==\"26\" goto 26 if /i \"%choice%\"==\"27\" goto 27 if /i \"%choice%\"==\"28\" goto 28 if /i \"%choice%\"==\"29\" goto 29 if /i \"%choice%\"==\"30\" goto 30 if /i \"%choice%\"==\"31\" goto 31 if /i \"%choice%\"==\"32\" goto 32 if /i \"%choice%\"==\"33\" goto 33 if /i \"%choice%\"==\"34\" goto 34 if /i \"%choice%\"==\"35\" goto 35 if /i \"%choice%\"==\"36\" goto 36 if /i \"%choice%\"==\"37\" goto 37 if /i \"%choice%\"==\"38\" goto 38 if /i \"%choice%\"==\"39\" goto 39 if /i \"%choice%\"==\"40\" goto 40 if /i \"%choice%\"==\"41\" goto 41 if /i \"%choice%\"==\"42\" goto 42 if /i \"%choice%\"==\"43\" goto 43 if /i \"%choice%\"==\"44\" goto 44 if /i \"%choice%\"==\"45\" goto 45 if /i \"%choice%\"==\"46\" goto 46 if /i \"%choice%\"==\"47\" goto 47 if /i \"%choice%\"==\"48\" goto 48 if /i \"%choice%\"==\"49\" goto 49 if /i \"%choice%\"==\"50\" goto 50 if /i \"%choice%\"==\"51\" goto 51 if /i \"%choice%\"==\"52\" goto 52 if /i \"%choice%\"==\"53\" goto 53 if /i \"%choice%\"==\"54\" goto 54 if /i \"%choice%\"==\"55\" goto 55 if /i \"%choice%\"==\"56\" goto 56 if /i \"%choice%\"==\"57\" goto 57 if /i \"%choice%\"==\"58\" goto 58 if /i \"%choice%\"==\"59\" goto 59 if /i \"%choice%\"==\"60\" goto 60 if /i \"%choice%\"==\"61\" goto 61 if /i \"%choice%\"==\"62\" goto 62 if /i \"%choice%\"==\"63\" goto 63 if /i \"%choice%\"==\"64\" goto 64 if /i \"%choice%\"==\"65\" goto 65 if /i \"%choice%\"==\"66\" goto 66 if /i \"%choice%\"==\"67\" goto 67 if /i \"%choice%\"==\"68\" goto 68 if /i \"%choice%\"==\"69\" goto 69 if /i \"%choice%\"==\"70\" goto 70 if /i \"%choice%\"==\"71\" goto 71 if /i \"%choice%\"==\"72\" goto 72 if /i \"%choice%\"==\"73\" goto 73 if /i \"%choice%\"==\"74\" goto 74 if /i \"%choice%\"==\"75\" goto 75 if /i \"%choice%\"==\"76\" goto 76 if /i \"%choice%\"==\"77\" goto 77 if /i \"%choice%\"==\"78\" goto 78 if /i \"%choice%\"==\"79\" goto 79 if /i \"%choice%\"==\"80\" goto 80 if /i \"%choice%\"==\"81\" goto 81 if /i \"%choice%\"==\"82\" goto 82 if /i \"%choice%\"==\"83\" goto 83 if /i \"%choice%\"==\"84\" goto 84 if /i \"%choice%\"==\"85\" goto 85 if /i \"%choice%\"==\"86\" goto 86 if /i \"%choice%\"==\"87\" goto 87 if /i \"%c","date":"2021-08-30","objectID":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/:1:0","tags":["手机"],"title":"免ROOT删除华为手机内置应用工具及教程","uri":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/"},{"categories":["手机"],"content":"另一篇介绍了哪些可删 https://zhuanlan.zhihu.com/p/107371855 以下截取自该文章 package:com.huawei.hifolder //华为精品应用文件夹， package:com.android.mediacenter //华为音乐，一堆广告，还要登录华为ID... package:com.huawei.hidisk //文件管理,功能挺全，但是竟然强行绑定云空间... package:com.huawei.android.thememanager //主题，里面一堆巨丑\u0026要付费的主题 package:com.huawei.intelligent //手机桌面滑到最左侧的智能情景模式...全是广告，唉 package:com.huawei.appmarket //华为应用市场，连skype、google都搜不出来的市场有鸟用？ package:com.huawei.wallet //华为钱包，用不着，刷卡有云闪付，公交卡有大都会。 package:com.huawei.android.findmyphone //查找手机，1000块的手机查找什么手机？ package:com.huawei.phoneservice //会员服务，不好意思，不是会员 package:com.android.browser //（华为）浏览器，看到我的文章上方推送的新闻了吧 package:com.android.soundrecorder //录音机，卸载防止系统悄咪咪的监听我 package:com.baidu.input_huawei //百度输入法-华为版，起到1+1\u003e2的效果，笑死我了 package:com.android.contacts //联系人，注意EMUI系统的拨号是属于联系人的子功能， 因此你会发现最终手机主页上的拨号+联系人都不见了 package:com.android.stk //SIM卡应用，已经过了2G时代，永别了 package:com.huawei.trustspace //支付保护中心，类似360沙箱，太麻烦不需要 package:com.android.calendar //日历，土味太浓，删了 package:com.huawei.vassistant //语音助手，防窃听，不多说 package:com.android.gallery3d //图库（系统相册），功能挺好，强绑华为云空间令人不爽，卸了 package:com.huawei.himovie //华为视频，本文一开头的罪魁祸首出现了，干掉你！ ","date":"2021-08-30","objectID":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/:2:0","tags":["手机"],"title":"免ROOT删除华为手机内置应用工具及教程","uri":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/"},{"categories":["手机"],"content":"再一篇介绍哪些可以删 https://woj.app/7121.html adb shell pm disable-user com.android.emergency ##停用 个人紧急信息 adb shell pm uninstall --user 0 com.huawei.hicar ##卸载 智慧汽车 adb shell pm disable-user com.huawei.trustspace ##（支付保护中心）停用 adb shell pm uninstall --user 0 com.huawei.hwstartupguide #首次开机时、引导用户设置系列信息。你不是第一次开机了吧？卸载 adb shell pm uninstall --user 0 com.android.dreams.phototable ##动态屏保 这玩意除了耗电一无是处。删 adb shell pm disable-user com.huawei.trustagent ##智能解锁 手环来解手机的锁，无用 adb shell pm uninstall --user 0 com.huawei.vassistant ##语音助手 小艺 adb shell pm uninstall --user 0 com.huawei.hwireader ##华为阅读 adb shell pm uninstall --user 0 com.huawei.iconnect ##扫描发现穿戴设备后进行连接提醒。用不着的话删 adb shell pm uninstall --user 0 com.huawei.synergy ##可以帮您将手机端的消息同步到您的穿戴设备上。同上。 adb shell pm uninstall --user 0 com.android.wallpaper.livepicker ##桌面动态壁纸。费电，删。 adb shell pm disable-user com.huawei.android.UEInfoCheck ##用户体验计划监控。停用 adb shell pm disable-user com.huawei.intelligent ##情景智能。 这是就是负一页的那个。 adb shell pm disable-user com.huawei.android.karaoke ##卡拉OK k歌音效 adb shell pm disable-user com.huawei.rcsserviceapplication ##智能推荐系统。用于华为智能助手服务推荐，EMUI亮点特性推荐以及智能通知管理。 adb shell pm uninstall --user 0 com.huawei.hiview ##Emui日志上传功能 adb shell pm uninstall --user 0 com.huawei.hiviewtunnel ##Emui日志上传功能 adb shell pm disable-user com.huawei.regservice ##华为注册服务 adb shell pm disable-user com.android.cts.ctsshim ##CTS兼容性检测 adb shell pm disable-user com.android.cts.priv.ctsshim ##CTS adb shell pm disable-user com.huawei.android.pushagent ##华为推送服务 给个性化信息及广告用的 adb shell pm disable-user com.huawei.nearby ##无需联网，通过蓝牙即可实现\"附近的人\"相互聊天，国内用不了 adb shell pm uninstall --user 0 com.vmall.client ##华为商城 adb shell pm uninstall --user 0 com.huawei.fans ##花粉俱乐部 ","date":"2021-08-30","objectID":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/:3:0","tags":["手机"],"title":"免ROOT删除华为手机内置应用工具及教程","uri":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/"},{"categories":["手机"],"content":"常用ADB命令 ","date":"2021-08-30","objectID":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/:4:0","tags":["手机"],"title":"免ROOT删除华为手机内置应用工具及教程","uri":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/"},{"categories":["手机"],"content":"1.获取设备状态 输入db get-state 回车 device：设备正常连接 offline：连接出现异常，设备无响应 unknown：没有连接设备 ","date":"2021-08-30","objectID":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/:4:1","tags":["手机"],"title":"免ROOT删除华为手机内置应用工具及教程","uri":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/"},{"categories":["手机"],"content":"2.查看系统应用 查看所有应用：adb shell pm list packages 查看系统应用：adb shell pm list packages -s 查看用户应用：adb shell pm list packages -3 ","date":"2021-08-30","objectID":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/:4:2","tags":["手机"],"title":"免ROOT删除华为手机内置应用工具及教程","uri":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/"},{"categories":["手机"],"content":"3．查看禁用的系统应用命令 先输入ADB-tools\u003e adb shell HWEVR:/ $ pm list packages -s -d 回车 再输入pm list packages -s -d 回车 ","date":"2021-08-30","objectID":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/:4:3","tags":["手机"],"title":"免ROOT删除华为手机内置应用工具及教程","uri":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/"},{"categories":["手机"],"content":"4.重启命令 重启手机：adb reboot 重启到recovery：adb reboot recovery 重启到fastboot：adb reboot fastboot ","date":"2021-08-30","objectID":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/:4:4","tags":["手机"],"title":"免ROOT删除华为手机内置应用工具及教程","uri":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/"},{"categories":["手机"],"content":"5.禁用、启用、删除应用的命令 禁用程序为adb shell pm disable-user+空格+程序名； 启用程序为adb shell pm enable+空格+程序名； 删除程序为adb shell pm uninstall –user 0+空格+程序名 ","date":"2021-08-30","objectID":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/:4:5","tags":["手机"],"title":"免ROOT删除华为手机内置应用工具及教程","uri":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/"},{"categories":["手机"],"content":"禁用服务清单-表格带说明 1.本表格重要的功能全是禁用命令，请自己选择删除还是禁用（具体命令在表格最后） 2.自由选择需要禁用的应用，需要保留哪一个功能的，请删除那一行的代码即可 5.禁用后，不满意，可以重新启用，删除则不可以。 6.如果想一次性恢复所有禁用的应用，请打开设置-应用-应用管理-右上角的三个点，选择恢复默许设置-重置，重启即可 7.代码可以复制多行，但不要含有汉字，必须是全英文，否则会不成功 8.个人认为135行系统更新（刷绿色）之后的应用和功能不禁用为好，娱乐工作两不误，体验更佳。 应用包名 显示名称 说明 com.huawei.livewallpaper.matetwenty 华山动态主题 无用 com.huawei.locationsharing 位置共享 除了费电，其它好像也没用处 com.google.Android.backuptransport 自动备份 不影响华为云备份及普通备份 com.huawei.hicar 智慧汽车连接 不实用 com.huawei.hwpolicyservice 旅行助手服务管理 不用旅行助手的 com.huawei.trustcircle 银联支付保护中心 没有支付宝微信安全，就是个坑 com.huawei.trustspace 支付保护中心 无用 com.huawei.desktop.explorer 我的文件 无用 com.android.sharedstoragebackup 备份 删除后，无法云备份 com.huawei.contactscamcard 名片全能王 com.iflytek.speechsuite 迅飞语音引擎 禁用后无影响 com.huawei.hwstartupguide 引导用户设置 首次开机时有效，其它时候无用 com.huawei.android.findmyphone 查找我的手机 com.huawei.hiskytone 天际通 com.android.wallpaper.livepicker 动态壁纸 com.huawei.skytone 天际通数据 com.huawei.cloud 华为云 禁用后不影响云空间及云备份 com.android.email 电子邮件 用第三方邮件代替 com.huawei.lives 华为生活服务 com.android.dreams.basic 基本互动屏保 com.huawei.search 华为搜索 com.huawei.videoeditor 视频编辑 com.huawei.android.karaoke 卡拉ok com.google.android.marvin.talkback 盲人辅助语音 com.huawei.KoBackup 备份 禁用不影响 com.huawei.powergenie 省电精灵 禁用后更省电，如果游戏掉帧，请启用 com.huawei.android.remotecontroller 智能遥控器 红外遥控器 com.android.keyguard 华为杂志锁屏 com.android.apps.tag 标记 com.android.emergency 个人紧急信息 com.huawei.contentsensor 取词 智能识屏里的插件 com.huawei.android.UEInfoCheck 用户体验计划监控 不解释 com.huawei.gameassistant 游戏助手 com.huawei.gamebox 华为游戏中心 如果想启用，请不要禁用应用市场 com.android.calculator2 计算器 com.huawei.nearby 无需联网，通过蓝牙即可实现\"附近的人\"相互聊天，国内用不了 com.huawei.android.pushagent 华为推送服务 给个性化信息及广告用的，很费电 com.huawei.phoneservice 服务 服务，删除后无法第一时间尝鲜升级 com.huawei.motionservice 手势服务 禁用不影响全面屏手势，需要分屏功能的勿禁用 com.huawei.hilink.framework 智能产品框架 com.huawei.regservice 华为注册服务 com.huawei.nlp 人工智能语言管理 com.google.ar.core 谷歌 AR com.huawei.arengine.service AR EngineServer com.huawei.hiai 华为智能AI com.huawei.vrservice 华为VR服务 com.huawei.fastapp 快应用中心 adb shell pm disable-user com.huawei.aod 灭屏显示 adb shell pm disable-user com.huawei.lbs 物理硬件位置服务 无用，还狂费电 com.huawei.rcsserviceapplication 华为RCS服务 增强短信功能，移动卡之间免费短信 com.android.frameworkres.overlay 可以禁用，不知道是什么 com.huawei.wallet 华为钱包 adb shell pm disable-user com.huawei.android.hwpay 华为钱包支付 adb shell pm disable-user com.android.dreams.phototable 相片保护程序 只有当内存不足时才会启用 adb shell pm disable-user com.huawei.scanner 扫一扫 禁用不影响所有应用的扫一扫功能 以下为系统预装应用 预装应用全部是删除命令 com.suning.mobile.ebuy 苏宁易购 com.ximalaya.ting.android 喜马拉雅 cn.TuHu.android 途虎 com.zhihu.android 知乎 com.sohu.newsclient 搜狐新闻 com.booking 阅读 com.microsoft.translator 微软翻译 com.tencent.qqlivehuawei 腾讯视频 com.huawei.compass 指南针 com.huawei.hwireader 华为阅读 com.hicloud.android.clone 手机克隆 com.dianping.v1 大众点评 com.taobao.taobao 淘宝 com.sina.weibo 微博 cn.wps.moffice_eng WPS com.baidu.BaiduMap 百度地图 com.baidu.searchbox 百度搜索 com.ss.android.article.news 今日头条 com.jingdong.app.mall 京东 com.sankuai.meituan 美团 com.UCMobile uc浏览器 com.vmall.client 华为商城 com.huawei.fans 花粉俱乐部 com.netease.newsreader.activity 网易新闻 com.sohu.sohuvideo.emplayer 华为搜狐视频 com.huawei.hwvplayer.youku 华为视频优酷版 ctrip.android.view 携程 com.android.mediacenter 华为音乐 com.ss.android.ugc.aweme 抖音 com.huawei.smarthome 智能家居 com.android.hwmirror 镜子 美女留下 com.huawei.scenepack 旅行助手 com.huawei.android.tips 玩机技巧 com.huawei.mmitest 首次开机测试 com.huawei.android.chr HwChrService 检测异常，收集异常关键信息，很费电 com.huawei.bd 用户体验计划 com.huawei.android.hwupgradeguide 升级向导 com.huawei.wifiprobqeservice 评估WIFI质量 com.huawei.hiview Emui日志上传功能 com.huawei.hiviewtunnel Emui日志上传功能 com.huawei.himovie.partner1 系统视频缓存区 除了增加手机的拉圾外，别无它用 com.huawei.himovie.partner2 系统视频缓存区 除了增加手机的拉圾外，别无它用 com.huawei.hifolder 精品推荐 打开文件夹，会推荐应用的那个拉圾 com.huawei.mycenter 会员中心 com.eg.android.AlipayGphone 支付宝 谷歌服务 禁用命令 com.google.android.configupdater 谷歌服务更新 谷歌可以全禁用或删除，没有任何问题 com.google.android.overlay.settingsProvider 多层设置 国内也用不了 com.google.android.overlay.gmsconfig 在谷歌地地图上显示位置 com.google.ar.core AR com.android.vending 谷歌应用市场 com.android.cts.priv.ctsshim CTS com.android.calllogbackup 电话标签备份 com.android.cts.","date":"2021-08-30","objectID":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/:5:0","tags":["手机"],"title":"免ROOT删除华为手机内置应用工具及教程","uri":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/"},{"categories":["手机"],"content":"还一篇 https://zhuanlan.zhihu.com/p/27853169 下载地址：免ROOT删除华为手机内置应用工具附件 ","date":"2021-08-30","objectID":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/:6:0","tags":["手机"],"title":"免ROOT删除华为手机内置应用工具及教程","uri":"/%E5%85%8Droot%E5%88%A0%E9%99%A4%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8F%8A%E6%95%99%E7%A8%8B/"},{"categories":["手机"],"content":"文字教程（搬运自下方视频的介绍）： Huawei Mate 40 Pro Install GMS 1、修改系统时间到2020/7月之前 2、下载Google套件：点击进入仓库（fork自mgeeker） 3、解压 Backup.zip 4、系统恢复 （密码：a12345678） 5、恢复之后桌面上会多一个 “谷歌服务助手” 6、启动 谷歌服务助手，激活，开始下载（如果有下载异常，重新下载） 7、把系统时间改回来（自动设置打开）,再把网络打开 8、安装MicroG，打开，选择Add google account， 登录google account 9、选择设置帐户，查看添加帐号是否已经添加OK 10、删除MicroG，安装1-7。重要安装（Google Play，Google框架，Google 服务） 11、打开Google Play，会报错，多重试几次，再杀掉进程，重试 12、Google Play正常打开，但是会有很多Google 警告的推送 13、下载一个device id app，打开，复制GSF编号，打开 URL https://www.google.com/android/uncertified/… 添加刚刚复制的GSF 14、打开飞行模式，关机，开机 15、打开设置应用应用管理，搜索Google，显示系统进程，分别对Google服务框架、Google Play服务（第一次不删除数据），Google Play商店作以下操作：清除缓存、删除数据，强行停止。 重启手机 16、打开设置应用应用管理，搜索Google，选择Google Play服务，存储，清空缓存，管理空间，清除所有数据，返回，强行停止，重启手机 17、如果警告关不掉，很重复15-16，多试几次，总会成功的，一般情况下一次就会成功🙂 本教程来源： {% youtube 6nx_VUlFaUc %} ","date":"2021-08-30","objectID":"/mate30-emui-11%E5%88%B7%E8%B0%B7%E6%AD%8C%E6%A1%86%E6%9E%B6gms/:0:0","tags":null,"title":"MATE30 EMUI 11刷谷歌框架(GMS)","uri":"/mate30-emui-11%E5%88%B7%E8%B0%B7%E6%AD%8C%E6%A1%86%E6%9E%B6gms/"},{"categories":["手机"],"content":"http://www.360doc.com/content/21/0108/15/32875768_955858444.shtml 本文章参考了两个帖子，并有很多朋友在论坛帮助，让我降级成功。现在把详细内容做成教程，供大家参考。 首先说明的问题： 1.到底要不要花钱降级？其实花钱在某宝降级也可以，省事，风险也小。如果你是一个动手能力强，喜欢折腾的人，那么就请继续往下看。 2.刷机到底有没有风险？这个我不知道，至少我买回来华为手机已经来来回回刷了很多次，暂时没有遇到变砖的问题，我认为只要系统没有病毒，软件是正版软件，数据线结实可靠，应该没有问题。 3.降级到底好不好？emui9.1/10.0/11.0我都用过了，说说优点和问题，仅个人观点。9.1功能不如10.0和11功能多，但是整体流畅，续航完美，不卡顿，拍照效果好，可能有些人操作丝滑程度没有10.0以上版本舒服，手势导航有bug，部分软件出现各种闪烁关闭的情况，所以我一直用三键导航。10.0操作丝滑，但是拍照差很多意思，尤其是夜间拍摄，注意不是夜景拍摄，还有续航也不太好。11.0版本体验了一下，耗电还好，跟10.0差不多，拍照也和10.0差不多，但是内存占用率高10个百分点以上，总是感觉不舒服，部分软件操作卡顿，其他问题没有发现，我是刷完机双清以后用的。 考虑好是否刷机后再继续进行**！** 参考帖子地址： 1.https://www.coolapk.com/feed/21700271?shareKey=ZTdlN2RiOWEyMDMxNWZjZGRjMjQ~\u0026shareUid=4266939\u0026shareFrom=com.coolapk.market_10.5.3 2.https://www.bilibili.com/read/cv8315201 感谢酷安好友“你现在好像可以凑成三连”和bilibili好友“鸿蒙系统发展史”两位大神！ **友情提示：刷机有风险 降级需谨慎 在开始以前务必备份数据****注意：降级一定会丢失所有资料 ！！！！！**免责声明：如操作不当造成的黑砖 数据丢失 本人不负责！ 下面正是开始内容： 1.准备 （1）系统准备，操作系统推荐win10！ 因为我用win8两台电脑都打不开其中一个重要软件，重新安装也不行，后来新装win10后就可以打开了。如果你遇到打开Hisuite proxy软件时出现停止错误，那么请更换系统，有人说缺少.netframework支持，其实我都装了，也还是不行。可能有的小伙伴成功了吧。根据软件开发者说明要.netframework 4.8版本，那么win10以下都是不支持的，所以只有win10能用。 （2）手机版本，降级9.1.0.193之前先要用华为手机助手降级到官方能降级9.1的那个版本，比如p30是9.1.0.226，如果你的系统是10.0.0.200那么不能直接降级至9.1.0.193。所以我从11.0.0.120降级的时候一共降级了四次，当然每次也就半个多小时。也就是降级任何一个大版本中间的小版本，要先将手机刷到这个大版本上，不能跨版本降级。我试过，会出错误。 （3）刷机包地址准备。 首先查看自己的刷机型号，手机输入*##2846579##*，进入工程菜单，第2项单板信息查询，第1项版本信息，找到基础包版本号，定制包版本号，预装包版本号三个，比如p30基础包是ELE-LGRP1-CHN，定制包是ELE-AL00-CUST，预装包是ELE-AL00-PRELOAD，后面的版本数字不用。 然后进入下面网页搜索https://pro-teammt.ru/en/online-firmware-database-ru/?firmware_model=\u0026firmware_page=0 选择我是人类，看图选择验证信息，进入搜索列表。 首****先搜索基础包，然后找到想刷的版本。我选择了9.1.0.193，本来想刷9.1.0.109，可惜没有，那就没有办法了，193也是最好的一个系统，看好是全量包，3.68个G大小，看好日期，8月23日，因为后面找定制包和预装包要对应日期。有人可能会问，为什么不选择8月12日的193版本，我个人认为后面的虽然版本号一样，但是应该有补丁存在，应该好点吧。点击filelist，弹出一个链接框来，复制到记事本上，保留到http://update.dbankcdn.com/TDS/data/files/p3/s15/G4830/g1755/v301250/f1/这个位置，后面的不要了。然后换行再复制版本号ELE-LGRP1-CHN 9.1.0.193到记事本上。基础包信息就找全了。 定制包和预装包获取方法一样，但是日期要和基础包的日期一样，不一样我没有尝试，会不会出问题自己考虑。也有人说可以只刷基础包，我怕有问题，都一起刷了。 ![](http://image109.360doc.com/DownloadImg/2021/01/0815/212395464_6_20210108030824963) 到这里，地址准备完了，然后打开Hisuite proxy工具（在第三项软件准备b里面有），将上面的地址和版本号，按照顺序复制进去。左下角的两个勾打上，就是CUST PKG和Preloaded PKG前面两个勾打上。伪装服务器地址就准备好了。 1. （2）准备软件 a.华为手机助手 的ove（国外）版本。百度搜索就有，可以不用最新版，有时候最新版会出现安装不了的情况，我也遇到过，低版本没问题，上面两个链接可以下载，为什么用ove版本，因为国内版本我没这么刷过！ b.Hisuite proxy 工具，个人理解，这是一个刷机时伪装华为服务器的代理软件，所以降级任意版本必须有他，要解压在一个文件夹内，以管理员身份运行。 c.httpcomponent补丁文件，附件有下载，应该是修改了一些参数，可以和伪装服务器链接。 （3）配置刷机环境 a.卸载原来的华为手机助手，安装下载的ove版本。 b.安装完成后先不打开华为助手软件，找到下载的httpcomponent补丁文件复制到华为助手的所在文件夹里，替换完成。如果不知道文件夹在哪里，请自行百度，因为这步不会可能真的是小白！ c.替换完成后打开ove版本华为助手，不用升级。设置代理服务器为127.0.0.1，端口为7777，与Hisuite proxy软件上显示的一样。 到这里，准备工作就结束了。 2.然后就是像用Huawei手机助手普通刷机一样，发现版本9.1.0.193，保存好数据之后，享受刷机过程吧。因为刷机后版本低，所以会有格式化硬盘的情况出现，不用慌，只要数据保存了，就没事。 刷完之后，版本完美，利用adb卸载各种无用功能，速度飞起，内存占用少，省电，拍照好都有了。希望大家能够成功！ 再次感谢酷安好友“你现在好像可以凑成三连”和bilibili好友“鸿蒙系统发展史”，有些图片来自你们的链接！ 链接:https://www.lanzoui.com/b00zwv1ch 密码:2okq 作者：bili_340311671 https://www.bilibili.com/read/cv8315201 出处：bilibili ","date":"2021-08-30","objectID":"/emui11%E9%99%8D%E7%BA%A7%E6%95%99%E7%A8%8B%E7%90%86%E8%AE%BA%E9%80%82%E7%94%A8%E4%BA%8E%E5%8D%8E%E4%B8%BA%E5%85%A8%E7%B3%BB%E5%88%97/:0:0","tags":null,"title":"Emui 11降级教程，理论适用于华为全系列","uri":"/emui11%E9%99%8D%E7%BA%A7%E6%95%99%E7%A8%8B%E7%90%86%E8%AE%BA%E9%80%82%E7%94%A8%E4%BA%8E%E5%8D%8E%E4%B8%BA%E5%85%A8%E7%B3%BB%E5%88%97/"},{"categories":["手机"],"content":"最近在写东西的时候需要以前一个旧手机中的素材，幸运的是旧手机进行了全量备份，不幸的是手机不在了，而备份又是加密的文件（enc格式），需要解密华为手机备份文件，要解决的就是脱离手机解密。 于是在网上找来找去，找到了这个脚本：https://github.com/RealityNet/kobackupdec ","date":"2021-08-29","objectID":"/%E5%8D%8E%E4%B8%BAhisuite%E5%A4%87%E4%BB%BD%E8%A7%A3%E5%AF%86/:0:0","tags":["hisuite","解密","手机"],"title":"华为Hisuite备份解密","uri":"/%E5%8D%8E%E4%B8%BAhisuite%E5%A4%87%E4%BB%BD%E8%A7%A3%E5%AF%86/"},{"categories":["手机"],"content":"源码 #!/usr/bin/python3 # -*- coding: utf-8 -*- # # Huawei KoBackup backups decryptor. # # Version History # - 20200705: fixed decrypt_large_package to read input's chunks # - 20200611: added 'expandtar' option, to avoid automatic expansion of TARs # added 'writable' option, to allow user RW on decrypted files # large TAR files are not managed in chunk but not expanded # - 20200607: merged empty CheckMsg, update folder_to_media_type by @realSnoopy # - 20200406: merged pull by @lp4n6, related to files and folders permissions # - 20200405: added Python minor version check and note (thanks @lp4n6) # - 2020test: rewritten to handle v9 and v10 backups # - 20200107: merged pull by @lp4n6, fixed current version # - 20191113: fixed double folder creation error # - 20190729: first public release # - 20190729: first public release # # Note: it needs Python version \u003e= 3.7 # # Released under MIT License # # Copyright (c) 2019 Francesco \"dfirfpi\" Picasso, Reality Net System Solutions # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to deal # in the Software without restriction, including without limitation the rights # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell # copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE # SOFTWARE. # '''Huawei KoBackup decryptor.''' import argparse import binascii import enum import io import logging import os import os.path import pathlib import sys import tarfile import xml.dom.minidom from Crypto.Cipher import AES from Crypto.Hash import SHA256 from Crypto.Hash import HMAC from Crypto.Protocol.KDF import PBKDF2 from Crypto.Util import Counter VERSION = '20200705' # Disabling check on doc strings and naming convention. # pylint: disable=C0111,C0103 MAX_FILE_SIZE = 536870912 # Files larger than that needs to be 'chuncked'. # --- DecryptMaterial --------------------------------------------------------- class DecryptMaterial: def __init__(self, type_name): self._type_name = type_name self._name = None self._encMsgV3 = None self._iv = None self._path = None self._records_num = None self._copy_file_path = None @property def type_name(self): return self._type_name @property def name(self): return self._name @name.setter def name(self, value_string): if value_string: self._name = value_string else: logging.error('empty entry name!') @property def records_num(self): return self._records_num @records_num.setter def records_num(self, value_string): self._records_num = value_string @property def encMsgV3(self): return self._encMsgV3 @encMsgV3.setter def encMsgV3(self, value_hex_string): if value_hex_string: self._encMsgV3 = binascii.unhexlify(value_hex_string) if len(self._encMsgV3) != 48: logging.error('encMsgV3 should be 48 bytes long!') @property def iv(self): return self._iv @iv.setter def iv(self, value_hex_string): if value_hex_string: self._iv = binascii.unhexlify(value_hex_string) if len(self._iv) != 16: logging.error('iv should be 16 bytes long!') @property def copy_file_path(self): return self._copy_file_path @copy_file_path.setter def copy_file_path(self, value_string): self._copy_file_path = value_string @property def path(self): return self._path @path.setter def path(self, value_string): if value_string: self._path","date":"2021-08-29","objectID":"/%E5%8D%8E%E4%B8%BAhisuite%E5%A4%87%E4%BB%BD%E8%A7%A3%E5%AF%86/:1:0","tags":["hisuite","解密","手机"],"title":"华为Hisuite备份解密","uri":"/%E5%8D%8E%E4%B8%BAhisuite%E5%A4%87%E4%BB%BD%E8%A7%A3%E5%AF%86/"},{"categories":["手机"],"content":"使用说明 ","date":"2021-08-29","objectID":"/%E5%8D%8E%E4%B8%BAhisuite%E5%A4%87%E4%BB%BD%E8%A7%A3%E5%AF%86/:2:0","tags":["hisuite","解密","手机"],"title":"华为Hisuite备份解密","uri":"/%E5%8D%8E%E4%B8%BAhisuite%E5%A4%87%E4%BB%BD%E8%A7%A3%E5%AF%86/"},{"categories":["手机"],"content":"kobackupdec Huawei backup decryptor This script is introduced by the blog post at https://blog.digital-forensics.it/2019/07/huawei-backup-decryptor.html. The kobackupdec is a Python3 script aimed to decrypt Huawei HiSuite or KoBackup (the Android app) backups. When decrypting and uncompressing the archives, it will re-organize the output folders structure trying to mimic the typical Android one. The script will work both on Windows and Linux hosts, provided the PyCryptoDome dependency. Starting from 20100107 the script was rewritten to handle v9 and v10 kobackup backups structures. ","date":"2021-08-29","objectID":"/%E5%8D%8E%E4%B8%BAhisuite%E5%A4%87%E4%BB%BD%E8%A7%A3%E5%AF%86/:2:1","tags":["hisuite","解密","手机"],"title":"华为Hisuite备份解密","uri":"/%E5%8D%8E%E4%B8%BAhisuite%E5%A4%87%E4%BB%BD%E8%A7%A3%E5%AF%86/"},{"categories":["手机"],"content":"EOL On 1.1.2021 the script will get its end of life status. It was needed two years ago to overcome issues for some Huawei devices’ forensics acquisitions. Now commercial forensics solutions include the very same capabilities, and much more: there are no more reasons to maintain it. We’ve got messages from guys using this script to manage theirs backups: we do not recommend it, and we did not write it for this reason. Anyhow we’re happy some of you did find it useful, and we thank you for the feedback. We shared it to the community, trying to give back something: if someone has any interest in maintaining it, please let us know so we can include a link to the project. ","date":"2021-08-29","objectID":"/%E5%8D%8E%E4%B8%BAhisuite%E5%A4%87%E4%BB%BD%E8%A7%A3%E5%AF%86/:2:2","tags":["hisuite","解密","手机"],"title":"华为Hisuite备份解密","uri":"/%E5%8D%8E%E4%B8%BAhisuite%E5%A4%87%E4%BB%BD%E8%A7%A3%E5%AF%86/"},{"categories":["手机"],"content":"Usage The script assumes that backups are encrypted with a user-provided password. Actually it does not support the HiSuite self generated password, when the user does not provide its own. usage: kobackupdec.py [-h] [-v] password backup_path dest_path Huawei KoBackup decryptor version 20200611 positional arguments: password user password for the backup backup_path backup folder dest_path decrypted backup folder optional arguments: -h, --help show this help message and exit -e, --expandtar expand tar files -w, --writable do not set RO pemission on decrypted data -v, --verbose verbose level, -v to -vvv password, is the user provided password. backup_path, is the folder containing the Huawei backup, relative or absolute paths can be used. dest_path, is the folder to be created in the specified path, absolute or relative. It will complain if the provided folder already exists. [-v] (from -v to -vvv) verbosity level, written on stderr. It’s suggested to use -vvv with a redirect to get a log of the process. Example Z:\\\u003e py -3 kobackupdec.py -vvv 123456 \"Z:\\HUAWEI P30 Pro_2019-06-28 22.56.31\" Z:\\HiSuiteBackup INFO:root:getting files and folder from Z:\\HUAWEI P30 Pro_2019-06-28 22.56.31 INFO:root:parsing XML files... INFO:root:parsing xml audio.xml DEBUG:root:parsing xml file audio.xml INFO:root:parsing xml document.xml DEBUG:root:parsing xml file document.xml INFO:root:parsing xml info.xml DEBUG:root:ignoring entry HeaderInfo DEBUG:root:ignoring entry BackupFilePhoneInfo DEBUG:root:ignoring entry BackupFileVersionInfo INFO:root:parsing xml picture.xml DEBUG:root:parsing xml file picture.xml INFO:root:parsing xml soundrecorder.xml DEBUG:root:parsing xml file soundrecorder.xml INFO:root:parsing xml video.xml DEBUG:root:parsing xml file video.xml DEBUG:root:crypto_init: using version 3. DEBUG:root:SHA256(BKEY)[16] = b'8d969eef6ecad3c29a3a629280e686cf' ... The output folder structure will be similar to the following one: data/data applications will be exploded in their proper paths, and the APKs will be restored too (not icons, actually). Note that the db folder will contain the special databases as created by the Huawei backups. HiSuiteBackup |-- data | |-- app | | |-- de.sec.mobile.apk-1 | | | [...] | | `-- org.telegram.messenger.apk-1 | `-- data | |-- de.sec.mobile | | [...] | `-- org.telegram.messenger |-- db | |-- HWlanucher.db | |-- Memo.db | |-- alarm.db | |-- calendar.db | |-- calllog.db | |-- camera.db | |-- clock.db | |-- contact.db | |-- harassment.db | |-- phoneManager.db | |-- setting.db | |-- sms.db | |-- soundrecorder.db | |-- systemUI.db | |-- weather.db | `-- wifiConfig.db `-- storage |-- DCIM |-- Download |-- Huawei |-- MagazineUnlock |-- Notifications |-- Pictures |-- WhatsApp |-- mp3 |-- parallel_intl `-- s8-wallpapers-9011.PNG ","date":"2021-08-29","objectID":"/%E5%8D%8E%E4%B8%BAhisuite%E5%A4%87%E4%BB%BD%E8%A7%A3%E5%AF%86/:2:3","tags":["hisuite","解密","手机"],"title":"华为Hisuite备份解密","uri":"/%E5%8D%8E%E4%B8%BAhisuite%E5%A4%87%E4%BB%BD%E8%A7%A3%E5%AF%86/"},{"categories":["VPN"],"content":"转载自：https://wsxq2.55555.io/blog/2018/10/20/Kali-Linux科学上网/ 用于备份该文章，以免源博客文章突然消失后找不到。 本文只讲解 Kali Linux 下针对SS和 SSR的客户端配置。由于 Kali 基于 Debian，所以其它基于 Debian 的 Linux 类似，例如Ubuntu。 关于科学上网的具体介绍请参见我的另一篇博客 科学上网。本文是它的子集 温馨提示：如果你的 Kali Linux 在虚拟机中且主机已经实现了科学上网，那么你没必要再折腾，直接使用通过已经可以科学上网的电脑实现科学上网这个方法即可 ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:0:0","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"SS 本部分最后更新时间：2018-04-08。 ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:1:0","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"shadowsocks-qt5 2019-07-02更新： 客户端选择shadowsocks-qt5是因为它简单，界面友好（好吧，是因为当初只听说过它）。现在的我更倾向于使用shadowsocks-libev作为客户端，因为它最近一次更新在 2019 年 7 月，而 shadowsocks（即原始的 Python 版）最后更新时间是 2018 年 10 月，shadowsocks-qt5 最近一次更新则是在 2018 年 8 月 具体环境说明： 客户端操作系统：Kali-Linux 使用的 shadowsocks 实现（客户端）：shadowsocks-qt5 使用的用户：root 另外，对于其它的 shadowsocks 实现，参考相应的官网文档操作即可。它们的官网链接在Shadowsocks - Implementations页面中 简介 Shadowsocks-Qt5 is a native and cross-platform shadowsocks GUI client with advanced features. ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:1:1","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"Features Shadowsocks-Qt5 is written in C++ with Qt 5. Support traffic statistics Support server latency (lag) test Use multiple profiles simultaneously config.ini is located under ~/.config/shadowsocks-qt5/ on *nix platforms, or under the application’s directory on Windows. ——引用自shadowsocks/shadowsocks-qt5: A cross-platform shadowsocks GUI client 安装 在/etc/apt/sources.list文件末尾添加: deb http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu devel main 更新 apt 软件列表： apt update #这里会提示错误，以下两步解决该错误 gpg --keyserver keyserver.ubuntu.com --recv 6DA746A05F00FA99 gpg --export --armor 6DA746A05F00FA99 | sudo apt-key add - apt update #这一步成功后便可安装shadowsocks-qt5了 安装shadowsocks-qt5: apt install shadowsocks-qt5 。 配置 安装后在bash中输入ss-qt5, 完成配置, 配置好后的图如下： 图中使用的服务器账号是我花180元/年租用的搬瓦工的 VPS (见下图)（大家也可以搭建一个属于自己的 SS 服务器，可以学到不少东西） 设置 PAC 获得 pac 文件： pip install genpac pip install --upgrade genpac mkdir ~/vpnPAC cd ~/vpnPAC touch user-rules.txt genpac -p \"SOCKS5 127.0.0.1:1080\" --gfwlist-proxy=\"SOCKS5 127.0.0.1:1080\" --output=\"autoproxy.pac\" --gfwlist-url=\"https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt\" --user-rule-from=\"user-rules.txt\" 系统设置自动代理: 设置-\u003e网络-\u003e网络代理，方式改为自动，配置 URL改为：file://root/vpnPAC/autoproxy.pac 优化 设置开机启动：通过kali linux自带的优化工具实现: Win+a, 直接输入优化工具，出现优化工具图标（当然你也可以自己找），双击，找到开机启动程序，添加shadowsock-qt5 自动连接某个节点：打开bash，输入ss-qt5，右键某个节点-\u003e编辑-\u003e程序启动时自动连接 通过快捷键开启或关闭shadowsocks-qt5: 设置-\u003e键盘-\u003e添加自定义快捷键（滑到最下面你会看到一个+）， 名字可以随意，命令输入ss-qt5（关闭时输入pkill ss-qt5），按键设置成你喜欢的即可。 ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:1:2","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"shadowsocks-libev 简介 shadowsocks-libev 是一个 shadowsocks 协议的轻量级实现，是 shadowsocks-android, shadowsocks-ios 以及 shadowsocks-openwrt 的上游项目。其具有以下特点： 体积小巧，静态编译并打包后只有 100 KB。 高并发，基于 libev 实现的异步 I/O，以及基于线程池的异步 DNS，同时连接数可上万。 低资源占用，几乎不占用 CPU 资源，服务器端内存占用一般在 3MB 左右。 跨平台，适用于所有常见硬件平台，已测试通过的包括 x86 ARM 和 MIPS。也适用于大部分 POSIX 的操作系统或平台，包括 Linux，OS X 和 gwin 等。 协议及配置兼容，完全兼容 shadowsocks 协议，且兼容标准实现中的 JSON 风格配置文件，可与任意实现的 shadowsocks 端或服务端搭配使用。 ——引用自CentOS 7 配置 shadowsocks-libev 服务器端进行科学上网 | 鸣沙山侧 月牙泉畔 安装 apt install shadowsocks-libev 查看该软件包中有哪些文件： dpkg -l shadowsocks-libev 配置 修改配置文件/etc/shadowsocks-libev/config.json： { \"server\":\"serverip\", \"server_port\":1234, \"local_address\": \"0.0.0.0\", \"local_port\":1080, \"password\":\"shadowsocks\", \"timeout\":60, \"method\":\"aes-256-cfb\" } 控制 使用如下命令启动： systemctl start shadowsocks-libev-local@config 其中config是你的配置文件的名字（config.json），如果变了，则这里也需要变 使用如下命令设置开机自启： systemctl enable shadowsocks-libev-local@config …… 查看日志 /var/log/syslog journalctl -u shadowsocks-libev-local@config 后续步骤 参见 PC 连接到 SSR Local ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:1:3","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"SSR SSR 的诸多实现如下（和 SS 类似）： 实现 编程语言 适用平台 最近一次更新 服务器 or 客户端 shadowsocksr Python Linux, OSX 2018-05 both shadowsocksr-libev C Linux, OSX, openwrt 2018-03 both shadowsocksr-android Java,Go Android 2018-03 client shadowsocks-csharp C# Windows 2018-04 client electron-ssr JavaScript, Vue Linux, OSX, Windows 2019-05 client ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:2:0","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"shadowsocksr（Python 版）（ SSR Local 连接到 SSR Server 操作系统：Kali Linux。实际上只要是 Linux 将本文内容稍加修改也适用。毕竟核心的东西是不变的 使用的 SSR 客户端：shadowsocksr（Python 版）。 2019-07-05 更新： 该部分阐述了如何让 SSR Local 连接到 SSR Server。在 SSR Local 和 SSR Server 通信的过程中使用的协议为 SSR 之所以使用 Python 版，是因为我只找到 Python 版的，/笑哭。 这一步是最重要的，后面的方法都建立在这个基础之上 2019-07-03 更新：事实上， SSR 现在可用的 Linux 客户端有三个，shadowsocksr, shadowsocksr-libev, electron-ssr，参见前文的表格 安装 获得 Python 版 SSR 的相关文件： cd ~/ git clone https://github.com/shadowsocksrr/shadowsocksr 经测试，其实只有 shadowsocksr 下的 shadowsocks 目录是必须的 配置 根据你的服务器配置修改配置文件~/shadowsocksr/config.json: { \"server\": \"\u003cip address\u003e\", \"server_ipv6\": \"::\", \"server_port\": 8388, \"local_address\": \"127.0.0.1\", \"local_port\": 1080, \"password\": \"password\", \"method\": \"none\", \"protocol\": \"auth_chain_a\", \"protocol_param\": \"\", \"obfs\": \"plain\", \"obfs_param\": \"\", \"speed_limit_per_con\": 0, \"speed_limit_per_user\": 0, \"additional_ports\" : {}, \"additional_ports_only\" : false, \"timeout\": 120, \"udp_timeout\": 60, \"dns_ipv6\": false, \"connect_verbose_info\": 0, \"redirect\": \"\", \"fast_open\": false } 启动 启动 SSR客户端： cd ~/shadowsocksr/shadowsocks python2 local.py -c ~/shadowsocksr/config.json 测试 下面的每个步骤都建立在前一个步骤成功的基础上： 使用命令ss -ltn | grep 1080，其输出应当如下： LISTEN 0 128 127.0.0.1:1080 *:* 如果失败，说明启动失败，可能是配置文件错误导致的 使用浏览器进行测试，即选择 浏览器全局代理 这部分的方法进行测试 如果失败，则可能是服务器连不上导致的 自动化 每次手动启动实在太麻烦，可以写个脚本让它在打开终端时自动启动，也可以让它开机自启。对于前者，可将如下bash脚本添加到~/.bashrc文件中（我自己写的，欢迎提建议）： function pg(){ ps aux | grep -v \"grep\" |grep $1 } function ssr(){ ps aux |grep \"[l]ocal\\.py\" \u003e /dev/null if [ $? -eq 1 ]; then python ~/shadowsocksr/shadowsocks/local.py -c ~/shadowsocksr/config.json -d start else if [ -n \"$1\" ]; then kill `pg \"local\\.py\" | awk '{print $2}'` else echo \"ssr has been run!\" fi fi } ssr 简要说一下上面那个函数ssr的用法：直接在 bash 中输入ssr后回车则后台启动（关闭终端也能继续运行）ssr客户端，输入ssr \u003c任意字符\u003e则关闭已启动的ssr客户端。 后续步骤 参见 PC 连接到 SSR Local ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:2:1","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"PC 连接到SSR Local 2019-07-03 更新： 该部分阐述了如何让 SSR Local 监听到数据，即如何让应用程序走本地代理。本地代理使用的协议为 socks5。 ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:3:0","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"浏览器全局代理 2019-07-04 更新：本部分的目标在于让浏览器浏览所有网页时都走代理。只需在浏览器中设置手动代理即可 以 FireFox 为例： 找到浏览器中的手动代理设置的位置：点击右上角的菜单，选择Preferences，选择General，滑到最下面，选择Network Proxy标签下的Settings，选择Manual proxy configuration 配置：找到SOCKS Host一栏，填入127.0.0.1和1080，在下面选择SOCKS v5，其它栏留空（如HTTP Proxy）。并在之后的No Proxy for中填入不需要代理的网址或 IP 地址或网段（例如 127.0.0.1、192.168.0.0/16等）。 2019-07-04 更新：记得勾选下方的Proxy DNS when using SOCKS v5以防止 GFW 的 DNS 污染。此外，对第 2 步的手动配置代理中的说明如下： HTTP Proxy： HTTP 代理服务器地址。须知，使用前面的方法在127.0.0.1 1080处搭建的代理服务器是 SOCKS 代理服务器（不是 HTTP 代理服务器），且使用的是 socks5 协议（不是 socks4/socks4a 协议）。所以在这里填写127.0.0.1 1080将无法访问（即必须留空） SSL Proxy：访问 HTTPS 站点时使用的代理服务器地址，其实就是 HTTP 代理服务器地址。留空原因同上 FTP Proxy：访问 FTP 站点时使用的代理服务器地址，其实就是 HTTP 代理服务器地址（不过需要注意的是 FTP 代理是存在的，例如使用工具ftp.proxy）。留空原因同上 SOCKS Host：访问任意站点时使用的代理服务器地址。 完！ 这时便可以访问https://www.google.com了，简单吧？ ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:3:1","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"系统全局代理 在系统设置中的网络代理方式设为手动，并将相应的Socks Host改为127.0.0.1 1080即可。具体步骤如下： 设置系统手动代理：设置-\u003e网络-\u003e网络代理，方式改为手动，SOCKS Host改为127.0.0.1 1080，其它留空（留空的理由和前文类似） 温馨提示：该处的设置依赖于network-manager服务，应确保其正在运行。（有的人因为network-manager.service和networking.service冲突所以采取网上的建议将network-manager.service给禁用了，结果导致系统设置中和网络相关的设置均不可用。好吧，说的就是我自己-_-）可以使用systemctl命令查看network-manager.service的状态，如下所示： root@kali:~# systemctl status network-manager.service ● NetworkManager.service - Network Manager Loaded: loaded (/lib/systemd/system/NetworkManager.service; enabled; vendor preset: enabled) Active: active (running) since Thu 2019-07-04 23:30:33 CST; 19h ago Docs: man:NetworkManager(8) Main PID: 396 (NetworkManager) Tasks: 3 (limit: 4695) Memory: 13.8M CGroup: /system.slice/NetworkManager.service └─396 /usr/sbin/NetworkManager --no-daemon 7月 04 23:30:35 kali.abc.com NetworkManager[396]: \u003cinfo\u003e [1562254235.6270] manager: NetworkManager state is now CONNECTED_GLOBAL 7月 04 23:30:35 kali.abc.com NetworkManager[396]: \u003cinfo\u003e [1562254235.7143] modem-manager: ModemManager available 7月 04 23:30:35 kali.abc.com NetworkManager[396]: \u003cinfo\u003e [1562254235.7188] device (eth0): state change: disconnected -\u003e prepare (reason 'none', sys-iface-state: 'external') 7月 04 23:30:35 kali.abc.com NetworkManager[396]: \u003cinfo\u003e [1562254235.7203] device (eth0): state change: prepare -\u003e config (reason 'none', sys-iface-state: 'external') 7月 04 23:30:35 kali.abc.com NetworkManager[396]: \u003cinfo\u003e [1562254235.7210] device (eth0): state change: config -\u003e ip-config (reason 'none', sys-iface-state: 'external') 7月 04 23:30:35 kali.abc.com NetworkManager[396]: \u003cinfo\u003e [1562254235.7215] device (eth0): state change: ip-config -\u003e ip-check (reason 'none', sys-iface-state: 'external') 7月 04 23:30:35 kali.abc.com NetworkManager[396]: \u003cinfo\u003e [1562254235.7226] device (eth0): state change: ip-check -\u003e secondaries (reason 'none', sys-iface-state: 'external') 7月 04 23:30:35 kali.abc.com NetworkManager[396]: \u003cinfo\u003e [1562254235.7233] device (eth0): state change: secondaries -\u003e activated (reason 'none', sys-iface-state: 'external') 7月 04 23:30:35 kali.abc.com NetworkManager[396]: \u003cinfo\u003e [1562254235.8065] device (eth0): Activation: successful, device activated. 7月 04 23:30:35 kali.abc.com NetworkManager[396]: \u003cinfo\u003e [1562254235.8200] manager: startup complete root@kali:~# 另外，这一步中的设置完成后，每次打开新终端的时候，检查代理相关的环境变量，你会发现： root@kali:~# env|grep -i proxy ALL_PROXY=socks://127.0.0.1:1080/ no_proxy= NO_PROXY= all_proxy=socks://127.0.0.1:1080/ root@kali:~# 所以这个步骤的实质只是设置了下环境变量 😂 假如你在系统的网络代理设置中将所有代理均设置为127.0.0.1 1080且Ignore Hosts设置为127.0.0.1, 192.168.0.0/16，那么在新打开的终端中检查代理相关的环境变量，你会发现： root@kali:~# env|grep -i proxy HTTP_PROXY=http://127.0.0.1:1080/ FTP_PROXY=http://127.0.0.1:1080/ https_proxy=http://127.0.0.1:1080/ http_proxy=http://127.0.0.1:1080/ ALL_PROXY=socks://127.0.0.1:1080/ no_proxy=127.0.0.1,192.168.0.0/16 NO_PROXY=127.0.0.1,192.168.0.0/16 HTTPS_PROXY=http://127.0.0.1:1080/ all_proxy=socks://127.0.0.1:1080/ ftp_proxy=http://127.0.0.1:1080/ root@kali:~# 同样印证了上述结论——在 Kali 系统设置中的网络代理设置处进行手动代理设置实质上是修改了代理相关的环境变量 需要注意的是（如前文所述），通用代理只有两种： HTTP 代理（使用 http 协议）和 SOCKS 代理（使用 socks4/socks4a/socks5 协议）。即代理相关环境变量中，每个变量=后面的协议部分必需是http/socks4/socks4a/socks5之一（对于curl还支持socks5h） 测试：打开浏览器，输入网址www.google.com看是否访问成功 2019-07-05 更新：如果使用的浏览器是 FireFox，则还需要将网络代理设置为Use system proxy settings。同样要记得勾选下方的Proxy DNS when using SOCKS v5以防止 GFW 的 DNS 污染 ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:3:2","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"真·系统全局代理（透明代理） 如前所述，在 Kali 系统设置中的网络代理设置处进行手动代理设置实质上是修改了代理相关的环境变量。对于 linux 下不支持代理的程序而言，前面的设置并没有什么用，即并非真的实现了全局代理。那么如果要实现真正意义上的全局代理，即让所有应用都经过代理服务器该怎么办？答案是使用 tsocks： tsocks 官网 tsocks 下载链接 tsocks 手册 tsocks 利用 LD_PRELOAD 机制，代理程序里的connect函数，然后就可以代理所有的 TCP 请求了。不过对于 dns 请求，默认是通过 udp 来发送的，所以 tsocks 不能代理 dns 请求。 默认情况下，tsocks 会先加载~/.tsocks.conf，如果没有，再加载/etc/tsocks.conf。对于 local ip 不会代理。 使用方法： sudo apt-get install tsocks LD_PRELOAD=/usr/lib/libtsocks.so wget http://www.facebook.com ——引用自科学上网的一些原理 | 横云断岭的专栏 ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:3:3","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"通过 SOCKS 代理进行 DNS 查询 使用 dns2socks（Github 上也有其项目地址https://github.com/qiuzi/dns2socks）或 overture 此外，shadowsocks-libev 中的 ss-tunnel 也能实现该功能。和 dns2socks 相比，ss-tunnel 走 TCP（即 socks5），而 dns2socks 走 UDP 具体步骤就不详述了 对了， HTTP 代理 DNS 的解析必然是通过代理的： 对于 HTTP/ HTTPS 类型的代理服务器而言，请求的域名会作为 HTTP 协议的一部分直接发往代理服务器，不会在本地进行任何解析操作。也就是说，域名的解析与连接目标服务器，是代理服务器的职责。浏览器本身甚至无须知道最终服务器的 IP 地址。据我所知，此行为无法通过浏览器选项等更改。 也就是说，理论上使用 HTTP/ HTTPS 类型的代理服务器时，本地的 DNS 解析、缓存、 hosts 文件等都不使用，与本地设置的 DNS 服务器地址无关。 DNS 解析完全在代理服务器上进行。 ——引用自请问在设置http/https代理后DNS的解析还是通过proxy吗? ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:3:4","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"转换 SOCKS 代理为 HTTP 代理 2019-07-04 更新：相关的工具有很多，例如 Polipo、privoxy等。这里使用的工具是 Polipo。需要注意的是 Polipo 最后一次更新是在 2014-05-15（参见 Polipo - Wikipedia） 如前所述，通用代理只有两种： HTTP 代理（使用 HTTP 协议）和 SOCKS 代理（使用 socks4/socks4a/socks5 协议）。最常见且最普及的是前者，有的应用不支持后者。所以为了让那些不支持 SOCKS 代理的应用程序使用代理，需要将 SOCKS 转换为 HTTP 代理。 Polipo可以用来将SOCKS的代理转换为HTTP的代理，从而使那些只支持HTTP代理的软件（如wget，部分浏览器，部分操作系统（如 Windows 就只支持 http 代理和 socks4 代理，这是我通过抓包分析发现的））也可以科学上网 安装polipo: apt install polipo 修改/etc/polipo/config文件为如下内容： logSyslog = true logFile = /var/log/polipo/polipo.log socksParentProxy = \"127.0.0.1:1080\" socksProxyType = socks5 proxyAddress = \"0.0.0.0\" proxyPort = 8123 重启polipo（安装后它会自动启动，故这里说重启）： systemctl restart polipo 验证 polipo 是否正常工作： export http_proxy=http://127.0.0.1:8123/ curl www.google.com 如果正常，就会返回抓取到的 Google 网页内容。可通过man polipo查看其帮助文档。 ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:3:5","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"浏览器自动代理 2019-07-04 更新：本部分的目标在于让浏览器根据浏览的网站的不同自动选择是否走代理，例如对于国外网站走代理，对于国内网站不走代理。方法也很简单，使用浏览器插件即可，FireFox 用 FoxyProxy，Chrome 用 SwitchyOmega。 FoxyProxy 是 Firefox 浏览器中的一个非常好用的代理插件。因为有科学上网需求的主要是浏览器，故若只是为了让浏览器科学上网，则可采用此方法。当然，如果用的是 Chrome ，则可采用 Chrome + SwitchyOmega 的方案替代之。 安装FoxyProxy插件：https://addons.mozilla.org/en-US/firefox/addon/foxyproxy-standard/ 设置FoxyProxy选项： Add Proxy: Proxy Type选SOCKS5，IP address填127.0.0.1，Port填1080，记得最后点下Save 添加Patterns: 在选项主界面，点击刚刚添加的Proxy的Patterns，根据自己的需要添加Patterns 启用FoxyProxy：单击浏览器中右上角相应的图标，选择Use Enabled Proxies By Patterns and Priority 测试：输入网址www.google.com看是否访问成功 ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:3:6","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"PAC（代理自动配置） 代理自动配置（英语：Proxy auto-config，简称 PAC）是一种网页浏览器技术，用于定义浏览器该如何自动选择适当的代理服务器来访问一个网址。 一个 PAC文件包含一个JavaScript形式的函数“FindProxyForURL(url, host)”。这个函数返回一个包含一个或多个访问规则的字符串。用户代理根据这些规则适用一个特定的代理器或者直接访问。当一个代理服务器无法响应的时候，多个访问规则提供了其他的后备访问方法。浏览器在访问其他页面以前，首先访问这个 PAC文件。 PAC文件中的 URL可能是手工配置的，也可能是是通过网页的网络代理自动发现协议（ WPAD）自动配置的。 ——引用自代理自动配置 - 维基百科，自由的百科全书 2019-07-06 更新：另外还可参见 breakwa11/gfw_whitelist: gfw_whitelist 了解关于 PAC 的更多信息 此方法主要使用了genpac（GENerate PAC file）生成 PAC 文件，并将系统设置中的网络代理方式改为自动，将其Configuration URL指向相应的 PAC 文件位置。具体过程如下： 安装genpac： #安装 pip install genpac #更新 pip install --upgrade genpac 生成 PAC文件： mkdir ~/.pac cd ~/.pac touch user-rules.txt #可在此文件中添加用户自定义规则，此处省略 genpac --pac-proxy \"SOCKS5 127.0.0.1:1080\" --output=\"ProxyAutoConfig.pac\" --user-rule-from=\"user-rules.txt\" 设置系统自动代理：设置-\u003e网络-\u003e网络代理，方式改为自动，Configuration URL改为file:///root/.pac/ProxyAutoConfig.pac（注意我用的是root用户，如果非root用户请将/root改为/home/\u003cyour username\u003e） 测试：打开浏览器，输入网址www.google.com看是否访问成功 2019-07-03 更新：该方法存在的问题是如果你的 PAC 文件失效了，可能需要重新下载 PAC 文件，即重新执行第 2 步中的genpac步骤。 ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:3:7","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"关于终端下的代理设置 终端代理环境变量 如前文所述，通用代理只有两种： HTTP 代理（使用 http 协议）和 SOCKS 代理（使用 socks4/socks4a/socks5 协议）。即代理相关环境变量中，每个变量=后面的协议部分必需是http/socks4/socks4a/socks5之一（对于curl还支持socks5h）。如下所示则全将其设置为了socks5： # Set Proxy function sp(){ export all_proxy=socks5://127.0.0.1:1080/ export ALL_PROXY=socks5://127.0.0.1:1080/ #有的命令行工具使用大写的变量名，如 curl export http_proxy=socks5://127.0.0.1:1080/ #有的命令行工具使用小写的变量名，如 curl、wget export ftp_proxy=socks5://127.0.0.1:1080/ #有的命令行工具使用小写的变量名，如 wget export FTP_PROXY=socks5://127.0.0.1:1080/ #有的命令行工具使用大写的变量名，如 curl export https_proxy=socks5://127.0.0.1:1080/ #有的命令行工具使用小写的变量名，如 wget export HTTPS_PROXY=socks5://127.0.0.1:1080/ #有的命令行工具使用大写的变量名，如 curl export no_proxy=localhost,127.0.0.1,192.168.0.0 #有的命令行工具使用小写的变量名，如 wget export NO_PROXY=localhost,127.0.0.1,192.168.0.0 #有的命令行工具使用大写的变量名，如 curl } # Unset Proxy function up() { unset all_proxy ALL_PROXY http_proxy ftp_proxy FTP_PROXY https_proxy HTTPS_PROXY no_proxy NO_PROXY } 其中的http_proxy表示访问http协议站点使用的代理，而不是使用http代理访问http协议站点。同理ftp_proxy表示访问ftp站点时使用的代理 使用程序的代理相关参数 git：已知（亲测）支持socks5、http这两种代理方式，支持上述的终端代理环境变量。也可单独设置代理以覆盖全局设置： # 设置`socks5`代理 git config --global http.proxy 'socks5://127.0.0.1:1080' git config --global https.proxy 'socks5://127.0.0.1:1080' # 设置`http`代理 git config --global https.proxy http://127.0.0.1:1080 git config --global https.proxy https://127.0.0.1:1080 # 取消代理 git config --global --unset http.proxy git config --global --unset https.proxy 对应的.gitconfig配置文件内容如下： [http] proxy = socks5://127.0.0.1:1080 [https] proxy = socks5://127.0.0.1:1080 curl：支持socks4、socks4a、socks5、http这几种代理方式，支持上述的终端代理环境变量。也可单独设置代理以覆盖全局设置： curl -i4 -m3 -x socks5://192.168.56.11:1080 https://www.google.com curl -i4 -m3 -x socks5h://192.168.56.11:1080 https://www.google.com 注意socks5和socks5h的区别，前者解析域名时不使用代理，后者解析域名时要使用代理，由于国内 DNS 可能被污染，故建议使用socks5h。详情参见man curl： –socks5-hostname \u003chost[:port]\u003e Use the specified SOCKS5 proxy (and let the proxy resolve the host name). If the port number is not specified, it is assumed at port 1080. (Added in 7.18.0) –socks5 \u003chost[:port]\u003e Use the specified SOCKS5 proxy - but resolve the host name locally. If the port number is not specified, it is assumed at port 1080. wget: 似乎只支持http协议代理，支持上述的终端代理环境变量。不可单独设置代理以覆盖全局变量 ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:3:8","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"通过已经可以科学上网的电脑实现科学上网 也就是说，如果你有一台设备通过上述的方法之一实现了科学上网，那么你就可以借助那台设备轻松地让其它和那台设备属于同一局域网的设备实现科学上网。比如你的实体机（如 Windows）实现了科学上网，那么对于你的 kali 虚拟机你就没必要想尽各种办法让它与你的实体机进行类似的配置以实现科学上网。具体方法如下： 前提条件：和可以科学上网的主机处于同一局域网 实验环境：主机 Windows10 （已实现科学上网），虚拟机 Kali Linux（需要实现科学上网），对于虚拟机 Kali，我使用了两个网卡，网络地址转换和仅主机网络，前者保证能连上 Internet，后者保证让 主机和虚拟机处于同一局域网（网段为 192.168.56.0/24） 实现步骤（以 SSR 为例）： 配置主机的 SSR 客户端，使其允许来自局域网的连接。于我而言，我是这么设置的：右键小飞机-\u003e选项设置-\u003e勾选来自局域网的连接 在虚拟机中，配置 FireFox 浏览器中的网络代理或系统代理，选择手动代理，在所有代理中填入主机的 IP 地址和其默认的端口（我的是192.168.56.100和1080） 完成 ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:4:0","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"链接 下面总结了本文中使用的所有链接： CentOS 7 配置 shadowsocks-libev 服务器端进行科学上网 | 鸣沙山侧 月牙泉畔 Polipo - Wikipedia Shadowsocks - Implementations breakwa11/gfw_whitelist: gfw_whitelist bwg dns2socks overture shadowsocks-qt5 ss-qt5 tsocks 下载链接 tsocks 官网 tsocks 手册 代理自动配置 - 维基百科，自由的百科全书 科学上网 科学上网的一些原理 | 横云断岭的专栏 请问在设置http/https代理后DNS的解析还是通过proxy吗? ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:5:0","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"缩略语 ARM: Advanced RISC Machines CPU: Central Processing Unit CST: China Standard Time DNS: Domain Name System FTP: File Transfer Protocol GFW: Great Firewall HTTP: Hypertext Transfer Protocol HTTPS: HTTP Secure IP: Internet Protocol JSON: JavaScript Object Notation KB: Kilobyte MB: Megabyte MIPS: Microprocessor without Interlocked Pipeline Stages OS: Operating System PAC: Proxy auto-config PC: Personal Computer PID: Process ID POSIX: Portable Operating System Interface, formerly IEEE-IX SOCKS: SOCKetS SS: shadowsocks SSL: Secure Socket Layer SSR: shadowsocksr TCP: Transmission Control Protocol UDP: User Datagram Protocol URL: Uniform Resource Locator VPS: Virtual Processing System WPAD: Web Proxy Autodiscovery Protocol ","date":"2021-08-27","objectID":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:6:0","tags":null,"title":"转载-Kali Linux科学上网","uri":"/kali-linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":["VPN"],"content":"自建开机启动脚本 将ss-local和bypass-lan-china.acl放入/usr/bin/（环境变量path）中 在 /etc/init.d/ 中创建自己的开机运行脚本 这里的文件名 mystart 可以修改为任何你喜欢的名称，但是必须放在/etc/init.d/目录中 cd /etc/init.d sudo vim /etc/init.d/proxy.sh 写入需要执行的命令,ss-local无需root权限 #!/bin/bash ### BEGIN INIT INFO # Provides: tuzixini # Required-Start: $local_fs $network # Required-Stop: $local_fs # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: self define auto start # Description: self define auto start ### END INIT INFO 上面的部分也必须写上，后面放上你需要开机执行的命令，这里是挂载一个硬盘 ss-local -s [服务器IP] -p [服务端端口] -b 0.0.0.0 -l [本地端口] -k [密码] -m chacha20-ietf-poly1305 --acl bypass-lan-china.acl 修改脚本文件权限(将命令中的mystart.sh替换成实际的脚本文件名称) sudo chmod 755 /etc/init.d/proxy.sh 加入开机启动(将命令中的mystart.sh替换成实际的脚本文件名称) sudo update-rc.d proxy.sh defaults 90 ok，完成，后面系统启动的时候就会自动运行这段命令。 CentOS系统： 将要开机启动的脚本放入/etc/rc.d/init.d中 cd /etc/rc.d/init.d chkconfig --add 要开机启动的脚本.sh chkconfig 要开机启动的脚本.sh on ","date":"2021-08-27","objectID":"/panda%E6%A0%B8%E5%BF%83%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE%E6%88%90%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C/:1:0","tags":null,"title":"Panda核心程序设置成开机自动运行","uri":"/panda%E6%A0%B8%E5%BF%83%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE%E6%88%90%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C/"},{"categories":["VPN"],"content":"替换shadowsock-lib包 ","date":"2021-08-27","objectID":"/panda%E6%A0%B8%E5%BF%83%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE%E6%88%90%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C/:2:0","tags":null,"title":"Panda核心程序设置成开机自动运行","uri":"/panda%E6%A0%B8%E5%BF%83%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE%E6%88%90%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C/"},{"categories":["VPN"],"content":"使用linux系统包管理命令安装shadowsock-lib apt install shadowsocks-libev ","date":"2021-08-27","objectID":"/panda%E6%A0%B8%E5%BF%83%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE%E6%88%90%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C/:2:1","tags":null,"title":"Panda核心程序设置成开机自动运行","uri":"/panda%E6%A0%B8%E5%BF%83%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE%E6%88%90%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C/"},{"categories":["VPN"],"content":"替换ss-local 进入/usr/bin目录，里面会有shadowsocks-libev的核心程序ss-local，将其替换成panda的核心二进制文件ss-local。 然后，编辑/etc/shadowsocks-libev/config.json: { \"server\":\"122.xx.xx.9\", \"server_port\":10xx, \"local_port\":128xx, \"local_address\":\"0.0.0.0\", \"password\":\"sslslsllslslslslssl\", \"timeout\":60, \"method\":\"chacha20-ietf-poly1305\" } shadowsock-libev的安装与配置文件的修改，参考： https://wsxq2.55555.io/blog/2018/10/20/Kali-Linux%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/#pc-%E8%BF%9E%E6%8E%A5%E5%88%B0-ssr-local https://wiki.archlinux.org/title/Shadowsocks centos 安装 https://zzz.buzz/zh/gfw/2018/03/21/install-shadowsocks-client-on-centos-7/ ","date":"2021-08-27","objectID":"/panda%E6%A0%B8%E5%BF%83%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE%E6%88%90%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C/:2:2","tags":null,"title":"Panda核心程序设置成开机自动运行","uri":"/panda%E6%A0%B8%E5%BF%83%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE%E6%88%90%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C/"},{"categories":["Linux"],"content":" echo 'export HISTTIMEFORMAT=\"%F %T \"' \u003e\u003e /etc/bashrc source /etc/bashrc ","date":"2021-08-27","objectID":"/history%E5%91%BD%E4%BB%A4%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4/:0:0","tags":null,"title":"history命令显示时间","uri":"/history%E5%91%BD%E4%BB%A4%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4/"},{"categories":["Linux"],"content":"Ubuntu 与别的 Linux 不同，直接修改/etc/motd文件重登录后无效。因为这里 /etc/motd 是一个符号链接，指向 /var/run/motd，应该是一个启动后在生成的文件。在版本 10.04 中，找到生成的脚本在目录 /etc/update-motd.d/ 中，那几个有序号的文件就是，包括 00-header，20-cpu-checker ，90-updates-available， 98-reboot-required，10-help-text，50-landscape-sysinfo，91-release- upgrade，99-footer。修改这几个文件，可以得到自己想要的结果。我使用的是 Ubuntu 12.04 Server LTS，目录下有这几个文件： 00-header 10-help-text 50-landscape-sysinfo 90-updates-available 91-release-upgrade 98-fsck-at-reboot 98-reboot-required 99-footer 基于我的需求，我修改到了以下几个文件： 00-header 50-landscape-sysinfo 90-updates-available 例如显示系统相关信息： System load: 0.0 Processes: 75 Usage of /: 2.7% of 73.47GB Users logged in: 2 Memory usage: 48% IP address for eth0: 61.166.76.27 Swap usage: 0% 此信息就是文件 “50-landscape-sysinfo” 里面的如下语句控制的：/usr/bin/landscape-sysinfo在前面用 “#” 号将其注释，保存即可。修改后用sudo run-parts /etc/update-motd.d去执行就会立即见到效果，而不用反复注销登录。 ","date":"2021-08-27","objectID":"/ubuntu%E4%BF%AE%E6%94%B9ssh%E6%AC%A2%E8%BF%8E%E7%95%8C%E9%9D%A2/:0:0","tags":null,"title":"Ubuntu修改SSH欢迎界面","uri":"/ubuntu%E4%BF%AE%E6%94%B9ssh%E6%AC%A2%E8%BF%8E%E7%95%8C%E9%9D%A2/"},{"categories":["GIS"],"content":"第一步：爬取PGIS数据 import requests,json session = requests.session() cookies=\"\" def getcodes(parents_code:str=430100000000)-\u003elist: headers ={ \"Accept\": \"text/plain, */*; q=0.01\", \"Accept-Encoding\": \"gzip, deflate\", \"Accept-Language\": \"zh-CN,zh;q=0.9\", \"Connection\": \"keep-alive\", \"Content-Length\": \"15\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Cookie\": cookies, \"Host\": \"65.47.1.103\", \"Origin\": \"http://65.47.1.103\", \"Referer\": \"http://65.47.1.103/PGIS_APP_Collection/app/area/main\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36\", \"X-Requested-With\": \"XMLHttpRequest\" } url = \"http://65.47.1.103/PGIS_APP_Collection/app/ztree/getOrgTree\" formdata = { \"id\": parents_code } r=session.post(url,data=formdata,headers=headers) qxdm = [{i[\"name\"]:i['id']} for i in r.json()] return qxdm # print(r.json()) # print(getcodes()) def GetGeoJson(dm:str): headers={ \"Accept\": \"application/json, text/javascript, */*; q=0.01\", \"Accept-Encoding\": \"gzip, deflate\", \"Accept-Language\": \"zh-CN,zh;q=0.9\", \"Connection\": \"keep-alive\", \"Content-Length\": \"159\", \"Content-Type\": \"application/json\", \"Cookie\": cookies, \"Host\": \"65.47.1.103\", \"Origin\": \"http://65.47.1.103\", \"Referer\": \"http://65.47.1.103/PGIS_APP_Collection/app/area/main\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36\", \"X-Requested-With\": \"XMLHttpRequest\" } url = \"http://65.47.1.103/PGIS_APP_Collection/app/collection/function/query\" pre_payload={\"from\":0,\"size\":1, \"query\":{\"bool\":{\"must\":{\"match\":{ \"zzjgdm\": dm }}}}} payload={\"endpoint\":\"/gis430100000000/fq_jyglfq_pg/_search\", \"json\":json.dumps(pre_payload) } r=session.post(url,data=json.dumps(payload),headers=headers) result = r.json() data = json.loads(r.json()['data']) result['data']=data # return result try: result = result['data']['hits']['hits'][0][\"_source\"]['shape']['coordinates'] return result except Exception as e: print(data) print(e) # x=GetGeoJson(\"430124000000\") # print(x) qx_codes:list = getcodes() quanshi = [] # 存放全市结果 # quxian = [] # 存放区县结果 # SqGeoJsons = [] # 存放社区结果 # PcsGeoJsons = [] # 存放派出所结果 for qx in qx_codes: qxname,qxcode=list(qx.items())[0] print(qxname,qxcode) QxGeoJson = GetGeoJson(qxcode) pcs_codes = getcodes(qxcode) PcsGeoJsons_ = [] for pcs in pcs_codes: pcs_name,pcs_code=list(pcs.items())[0] print('\\t',pcs_name,pcs_code) PcsGeoJson= GetGeoJson(pcs_code) sq_codes = getcodes(pcs_code) SqGeoJson_ = [] for sq in sq_codes: sq_name,sq_code=list(sq.items())[0] print('\\t\\t',sq_name,sq_code) SqGeoJson = GetGeoJson(sq_code) # SqGeoJsons.append({\"name\":sq_name,'qxdm':qxcode,'pcsdm':pcs_code,\"sqdm\":sq_code,\"coordinates\":SqGeoJson}) #总表 SqGeoJson_.append({\"name\":sq_name,'qxdm':qxcode,'pcsdm':pcs_code,\"sqdm\":sq_code,\"coordinates\":SqGeoJson}) #临时表 PcsGeoJsons_.append({\"name\":pcs_name,'qxdm':qxcode,'pcsdm':pcs_code,\"coordinates\":PcsGeoJson,'社区':SqGeoJson_}) #临时表 # PcsGeoJsons.append({\"name\":pcs_name,'qxdm':qxcode,'pcsdm':pcs_code,\"coordinates\":PcsGeoJson,'社区':SqGeoJson_}) #总表 quxian.append({\"name\":qxname,'qxdm':qxcode,\"coordinates\":QxGeoJson}) # quanshi.append({\"name\":qxname,'qxdm':qxcode,\"coordinates\":QxGeoJson,'派出所':PcsGeoJsons_}) with open(r\"结果\\全市-关系数据.json\", \"w\", encoding=\"utf-8\") as f: json.dump(quanshi, f, ensure_ascii=False) # with open(r\"结果\\区县.json\", \"w\", encoding=\"utf-8\") as f: # json.dump(quxian, f, ensure_ascii=False) # with open(r\"结果\\派出所.json\", \"w\", encoding=\"utf-8\") as f: # json.dump(PcsGeoJsons, f, ensure_ascii=False) # with open(r\"结果\\社区.json\", \"w\", encoding=\"utf-8\") as f: # json.dump(SqGeoJsons, f, ensure_ascii=False) ","date":"2021-08-25","objectID":"/%E7%88%AC%E5%8F%96pgis%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5postgis/:1:0","tags":null,"title":"爬取PGIS数据，存入POSTGIS","uri":"/%E7%88%AC%E5%8F%96pgis%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5postgis/"},{"categories":["GIS"],"content":"第二步：搭建POSTGIS（最快的空间数据库） docker一键搭建，搭建完后，使用数据库管理软件连接数据库，并新建数据库，这时我们的demo数据库只是个普通的postgresql数据库，是不支持空间相关功能的，在新建的数据库上执行CREATE EXTENSION postgis来为该数据库安装postgis扩展模块，成功之后我们的数据库就变成了空间数据库，支持空间相关的各种功能。具体请参考 ","date":"2021-08-25","objectID":"/%E7%88%AC%E5%8F%96pgis%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5postgis/:2:0","tags":null,"title":"爬取PGIS数据，存入POSTGIS","uri":"/%E7%88%AC%E5%8F%96pgis%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5postgis/"},{"categories":["GIS"],"content":"第三步：将第一步爬取的数据存入POSTGIS数据库中 代码如下： import json import geojson from geopandas import GeoDataFrame, GeoSeries from shapely.geometry import shape from sqlalchemy import create_engine # 将geodataframe写入postgis # Set up database connection engine # 数据库类型://用户名:密码@主机IP:端口/数据库名称 dbconfig = \"postgresql://postgres:password@192.168.1.100:54321/geotest\" # 创建引擎 engine = create_engine(dbconfig) def write2postgis(gdf: GeoDataFrame, tablename: str): # GeoDataFrame to PostGIS gdf.to_postgis( con=engine, name=tablename, ) def to_wkt(geojson_obj): # geojson = {\"coordinates\":[[[23.314208,37.768469],[24.039306,37.768469],[24.039306,38.214372],[23.314208,38.214372],[23.314208,37.768469],]],\"type\":\"Polygon\",} s = json.dumps(geojson_obj) g1 = geojson.loads(s) g2 = shape(g1) return g2.wkt with open(\"/opt/notebooks/全市PGIS信息/最新脚本及结果/全市-关系数据.json\", \"r\", encoding=\"utf-8\") as f: datas = json.load(f) result = [] pcs_result = [] sq_result = [] for quxian in datas: # 第一层 geojson_data = {\"type\": \"Polygon\", \"coordinates\": []} # 字段名 # 字段类型 if quxian[\"coordinates\"]: geojson_data[\"coordinates\"] = quxian[\"coordinates\"] try: polygon_wkt = to_wkt(geojson_data) except: geojson_data[\"type\"] = \"MultiPolygon\" polygon_wkt = to_wkt(geojson_data) result.append( { \"name\": quxian[\"name\"], \"code\": int(quxian[\"qxdm\"]), \"geometry\": polygon_wkt, } ) # 第二层 for pcs in quxian[\"派出所\"]: geojson_data = {\"type\": \"Polygon\", \"coordinates\": []} # 字段名 # 字段类型 if pcs[\"coordinates\"]: geojson_data[\"coordinates\"] = pcs[\"coordinates\"] try: polygon_wkt = to_wkt(geojson_data) except: geojson_data[\"type\"] = \"MultiPolygon\" polygon_wkt = to_wkt(geojson_data) pcs_result.append( { \"name\": pcs[\"name\"], \"code\": int(pcs[\"pcsdm\"]), \"qxname\": quxian[\"name\"], \"geometry\": polygon_wkt, } ) # 第三层 for sq in pcs[\"社区\"]: geojson_data = {\"type\": \"Polygon\", \"coordinates\": []} # 字段名 # 字段类型 if sq[\"coordinates\"]: geojson_data[\"coordinates\"] = sq[\"coordinates\"] try: polygon_wkt = to_wkt(geojson_data) except: geojson_data[\"type\"] = \"MultiPolygon\" polygon_wkt = to_wkt(geojson_data) sq_result.append( { \"name\": sq[\"name\"], \"code\": int(sq[\"pcsdm\"]), \"qxname\": quxian[\"name\"], \"pcsname\": pcs[\"name\"], \"geometry\": polygon_wkt, } ) quxian_df = GeoDataFrame(result) quxian_df[\"geometry\"] = GeoSeries.from_wkt( quxian_df[\"geometry\"], crs=4326 ) # 将geometry列转为geopandas的空间对象，crs坐标系为WGS84 # df.head(11) write2postgis(quxian_df, \"QuXian\") pcs_df = GeoDataFrame(pcs_result) pcs_df[\"geometry\"] = GeoSeries.from_wkt( pcs_df[\"geometry\"], crs=4326 ) # 将geometry列转为geopandas的空间对象，crs坐标系为WGS84 # df.head(11) write2postgis(pcs_df, \"PCS\") sq_df = GeoDataFrame(sq_result) sq_df[\"geometry\"] = GeoSeries.from_wkt( sq_df[\"geometry\"], crs=4326 ) # 将geometry列转为geopandas的空间对象，crs坐标系为WGS84 # df.head(11) write2postgis(sq_df, \"SheQu\") ","date":"2021-08-25","objectID":"/%E7%88%AC%E5%8F%96pgis%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5postgis/:3:0","tags":null,"title":"爬取PGIS数据，存入POSTGIS","uri":"/%E7%88%AC%E5%8F%96pgis%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5postgis/"},{"categories":["Hexo"],"content":"shoka主题的魔改笔记 ","date":"2021-08-25","objectID":"/shoka%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"shoka配置笔记","uri":"/shoka%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"},{"categories":["Hexo"],"content":"首页卡片 shoka\\source\\css\\_mixins.styl shadow-box(border = true, radius = .5rem) { border-radius: radius; border: .0625rem solid var(--grey-2) if border == true; box-shadow: 0 .625rem 1.875rem -.9375rem var(--box-bg-shadow); } 0 0.1rem 1.9rem -0.1rem #191717 ","date":"2021-08-25","objectID":"/shoka%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/:1:0","tags":null,"title":"shoka配置笔记","uri":"/shoka%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"},{"categories":["Hexo"],"content":"右侧滚动条颜色 themes\\shoka\\source\\css\\_common\\scaffolding\\scrollbar.styl ::-webkit-scrollbar { width: .3125rem; height: .3125rem; background: 0 FIREBRICK; } ","date":"2021-08-25","objectID":"/shoka%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/:2:0","tags":null,"title":"shoka配置笔记","uri":"/shoka%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"},{"categories":["Hexo"],"content":"首页卡片鼠标滑过时边框阴影-249行 themes\\shoka\\source\\css\\_common\\components\\pages\\home.styl +mobile() { flex-direction: column; height: fit-content; max-height: fit-content; } \u0026:hover { box-shadow: 0 0 2rem #000;// var(--box-bg-shadow); ","date":"2021-08-25","objectID":"/shoka%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/:3:0","tags":null,"title":"shoka配置笔记","uri":"/shoka%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"},{"categories":["Hexo"],"content":"标签后台时显示的文字 themes\\shoka\\languages\\zh-CN.yml --- name: 简体中文 favicon: show: （●´3｀●）やれやれだぜ hide: (´Д｀)大変だ！ ","date":"2021-08-25","objectID":"/shoka%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/:4:0","tags":null,"title":"shoka配置笔记","uri":"/shoka%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"},{"categories":["手机"],"content":"从 EMUI 11 回滚到 EMUI 10 华为网站下载适用于 Windows PC 的华为 HiSuite 软件（虽然Mac上有HiSuite，但这个版本不允许软件回滚） 允许通过 HDB 进行 USB 连接，为此，请转到“设置”“安全性”“更多设置” 然后打开 HDB 的开关 通过 USB 数据线将您的华为设备连接到您的计算机 选择“传输文件” 同意请求的权限 HiSuite 将要求您输入验证码以确认同步，在您插入手机后不久，该验证码将显示在您的华为设备屏幕上 在 HiSuite 主屏幕上，点击“更新”按钮 然后点击“切换到其他版本”按钮 点击“恢复” 点击“回滚” 根据您的互联网连接和一天中的时间，回滚过程可能需要 20 分钟到 45 分钟不等。完成后，您的华为设备将重新启动，重新启动后，您将返回 EMUI 10 ","date":"2021-08-24","objectID":"/%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%AE%89%E8%A3%85google%E6%A1%86%E6%9E%B6/:1:0","tags":null,"title":"华为手机安装Google框架","uri":"/%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%AE%89%E8%A3%85google%E6%A1%86%E6%9E%B6/"},{"categories":["手机"],"content":"下载Googlefier 下载地址：Download 备用地址：备用地址 ","date":"2021-08-24","objectID":"/%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%AE%89%E8%A3%85google%E6%A1%86%E6%9E%B6/:2:0","tags":null,"title":"华为手机安装Google框架","uri":"/%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%AE%89%E8%A3%85google%E6%A1%86%E6%9E%B6/"},{"categories":["手机"],"content":"使用 下面是对Googlefier操作步骤的英文翻译 1、停止并卸载弹出来的应用 2、然后Googlefier会启动一个安装，确认并安装它， 3、开关几次Playstore，同时观察账号同步情况， 4、上述操作完，继续“步骤三” 在此安装之后，重试开、关Playstore几次，在Playstore中下载安装应用试试，然后继续下一步 Google Play Services设置界面将会打开,强制停止并卸载它 ,然后另一个安装进行会自动启动 在此安装之后，重试开、关Playstore几次，在Playstore中下载安装应用试试，然后继续下一步 Google Services Framework 的设置会被打开，按下停止直到它变灰，然后双清，再重启手机，重启之后，开关商店几次，然后继续“步奏三” Google Play Services设置界面将会打开,强制停止并卸载它 ,然后另一个安装进行会自动启动 在此“安装”之后，重启手机（不要在意当前打开了什么APP），如果商店仍然可以用，那就成功了， 注意，你可以更新google services 请记住，如果这个APP可以实现你的功能，请让我们知道，在帮助按钮里有两个选项 来自XDA上的视频教程，结合YouTube翻译插件食用。 {% youtube t4sSdzwVhKk %} ","date":"2021-08-24","objectID":"/%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%AE%89%E8%A3%85google%E6%A1%86%E6%9E%B6/:3:0","tags":null,"title":"华为手机安装Google框架","uri":"/%E5%8D%8E%E4%B8%BA%E6%89%8B%E6%9C%BA%E5%AE%89%E8%A3%85google%E6%A1%86%E6%9E%B6/"},{"categories":null,"content":"主题名：stack 演示站：https://theme-stack.jimmycai.com/p/test-chinese/ 第一次看到：https://zhixuan666.github.io/ ","date":"2021-08-21","objectID":"/hugo%E6%BC%82%E4%BA%AE%E4%B8%BB%E9%A2%98/:0:0","tags":["Hugo"],"title":"Hugo漂亮主题","uri":"/hugo%E6%BC%82%E4%BA%AE%E4%B8%BB%E9%A2%98/"},{"categories":["Hexo"],"content":"前言 为了解决Typecho需要自建服务器，容易数据丢失的问题，从Typecho转移到Hexo，但是Hexo需要解决只能本地写博客，而且还要安装一堆依赖的问题，又从网上学到了Hexo+Github Acitons的组合，这样只要有浏览器就能登录Github写博客。 最稳妥的的还是使用原生的Hexo环境（node.js），这样可以本地先预览博客最终效果，再发布，这样可以减少commit次数。 只是本地写博客如果采用Hexo最原始的方式，即：先cd到Hexo目录-\u003e再hexo new post-\u003e再到_posts目录中找到新建的md文件进行编辑，就显得非常繁琐不友好了。 经过一番折腾，终于找到了vscode-hexo-utils这款神器。 ","date":"2021-08-21","objectID":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:1:0","tags":["Hexo","VSCODE"],"title":"vscode-hexo-utils使用教程","uri":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["Hexo"],"content":"介绍 vscode-hexo-utils是一款VSCODE插件，可以实现在VSCODE中方便的写Hexo博客（新建、编辑、管理MD文件），省去了先cd到Hexo目录-\u003e再hexo new post-\u003e再到_posts中找到新建的md文件进行编辑的步骤，而且支持粘贴图片后自动保存到相应目录并插入进MD中，简直美滋滋。 同时还支持按Draft、Post、Categories、Tags管理文章，具体效果如图： ","date":"2021-08-21","objectID":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:2:0","tags":["Hexo","VSCODE"],"title":"vscode-hexo-utils使用教程","uri":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["Hexo"],"content":"安装 首先得安装VSCODE…此步略。 然后在VSCODE的插件市场（Ctrl+Shift+X调出）中搜索vscode-hexo-utils，找到并安装它。 ","date":"2021-08-21","objectID":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:3:0","tags":["Hexo","VSCODE"],"title":"vscode-hexo-utils使用教程","uri":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["Hexo"],"content":"设置 安装完毕后，进入VSCODE的设置(Ctrl+,)，在新界面顶部搜索框输入@ext:fantasy.vscode-hexo-utils将插件的设置项筛选出来。这里介绍几个重要的设置。 ","date":"2021-08-21","objectID":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:4:0","tags":["Hexo","VSCODE"],"title":"vscode-hexo-utils使用教程","uri":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["Hexo"],"content":"Hexo: Generate Time Format 这里设置新建文章、插入图片时自动生成的时间格式，留空的话，生成的时间形如：2021-08-21T07:27:21+08:00，可以自定义，具体变量参考，举个栗子： 1、YYYY-MM-DD HH:mm:ss 生成的时间形如:2021-08-23 14:18:57 2、YYYY-MM-DD HH:mm 生成的时间形如:2021-08-23 14:18 ","date":"2021-08-21","objectID":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:4:1","tags":["Hexo","VSCODE"],"title":"vscode-hexo-utils使用教程","uri":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["Hexo"],"content":"Hexo: Hexo Project Root 这里设置Hexo博客所在目录，建议留空，并设置为不同步。 ","date":"2021-08-21","objectID":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:4:2","tags":["Hexo","VSCODE"],"title":"vscode-hexo-utils使用教程","uri":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["Hexo"],"content":"Hexo › Markdown: Resource 这个配置项会开启代码中的 markdown 插件，用于支持一些 hexo 自己的语法。 ","date":"2021-08-21","objectID":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:4:3","tags":["Hexo","VSCODE"],"title":"vscode-hexo-utils使用教程","uri":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["Hexo"],"content":"Hexo: Upload 设置是否自动将图片上传到图床，支持路过图床和腾讯oss，下面的两个设置对应路过图床和腾讯OSS，点击在setting.json中编辑，将自己平台的账号密码填入： \"hexo.uploadImgchr\": { \"username\": \"用户名\", \"password\": \"密码\" } ","date":"2021-08-21","objectID":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:4:4","tags":["Hexo","VSCODE"],"title":"vscode-hexo-utils使用教程","uri":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["Hexo"],"content":"Hexo: Upload Type 选择默认的图床服务 ","date":"2021-08-21","objectID":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:4:5","tags":["Hexo","VSCODE"],"title":"vscode-hexo-utils使用教程","uri":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["Hexo"],"content":"使用 首先使用VSCODE打开Hexo项目目录， 然后在VSCODE左侧找到vscode-hexo-utils插件图标。 ","date":"2021-08-21","objectID":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:5:0","tags":["Hexo","VSCODE"],"title":"vscode-hexo-utils使用教程","uri":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["Hexo"],"content":"新建文章 鼠标放在POST栏目的Bar上，就能看到新增和刷新按钮，点击新增即可按照事先在Hexo设置的模板新建文章。 ","date":"2021-08-21","objectID":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:5:1","tags":["Hexo","VSCODE"],"title":"vscode-hexo-utils使用教程","uri":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["Hexo"],"content":"在文章中插入图片 1、使用图床 不知道是不是我设置的问题，路过图床总时提示失败，后来发现是路过图床更换了域名，已联系插件作者修复。 2、不使用图床 插件会自动将图片保存至MD文件所在目录的同名子目录中。 ","date":"2021-08-21","objectID":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:5:2","tags":["Hexo","VSCODE"],"title":"vscode-hexo-utils使用教程","uri":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["Hexo"],"content":"使用插件提供的代码片段 插件默认附带了一些用来写Hexo博客的代码片段，可选择使用。 插件默认的代码片段如下，该文件的保存在C:\\Users\\Administrator\\.vscode\\extensions\\fantasy.vscode-hexo-utils-0.1.26\\snippets，可以自行添加代码片段，但是修改的东西不会同步到vscode云端，如需同步，可参考我的另一篇文章{% post_link VSCODE写HEXO博客时自动插入FrontMatter的实现 [VSCODE写HEXO博客时自动插入FrontMatter的实现] %} { \"hexo.post_path\": { \"prefix\": [\"hexo.post_path\"], \"body\": [\"{% post_path ${1:filename} %}\"], \"description\": \"Include links to other posts.\" }, \"hexo.post_link\": { \"prefix\": [\"hexo.post_link\"], \"body\": [\"{% post_link ${1:filename} ${2:[title] [escape]} %}\"], \"description\": \"Include links to other posts.\" }, \"hexo.asset_path\": { \"prefix\": [\"hexo.asset_path\"], \"body\": [\"{% asset_path ${1:filename} %}\"], \"description\": \"Include post assets.\" }, \"hexo.asset_img\": { \"prefix\": [\"hexo.asset_img\"], \"body\": [\"{% asset_img ${1:filename} ${2:[title]} %}\"], \"description\": \"Include post assets.\" }, \"hexo.asset_link\": { \"prefix\": [\"hexo.asset_link\"], \"body\": [\"{% post_link ${1:filename} ${2:[title] [escape]} %}\"], \"description\": \"Include post assets.\" }, \"hexo.raw\": { \"prefix\": [\"hexo.raw\"], \"body\": [\"{% raw %}\", \"${1:content}\", \"{% endraw %}\", \"$0\"], \"description\": \"If certain content is causing processing issues in your posts, wrap it with the raw tag to avoid rendering errors.\" }, \"hexo.more\": { \"prefix\": \"hexo.more\", \"body\": [\"\u003c!-- more --\u003e\", \"$0\"], \"description\": \"Use text placed before the \u003c!-- more --\u003e tag as an excerpt for the post. excerpt: value in the front-matter, if specified, will take precedent.\" } } ","date":"2021-08-21","objectID":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/:5:3","tags":["Hexo","VSCODE"],"title":"vscode-hexo-utils使用教程","uri":"/vscode-hexo-utils%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"},{"categories":["Hexo"],"content":"第一步 首先点VSCODE的文件-\u003e首选项-\u003e用户片段，在弹出来的对话框中选择markdown.json。输入以下内容： { \"Hexo Front Matter\": { \"prefix\": \"---\", # 触发代码块的输入字符 \"body\": [ \"---\", \"title: ${TM_FILENAME_BASE}\", # 自动将文件名作为标题 \"date: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}\", # 自动输入当前时间 \"update: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE} ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}\", # 自动输入当前时间 \"tags:\", \" - \", \" - \", \"categories:\", \" - \", \" - \", \"description: \", \"cover: \", \"keywords: \", \"---\\r\" ], \"description\": \"Hexo Front Matter\" } } ","date":"2021-08-20","objectID":"/vscode%E5%86%99hexo%E5%8D%9A%E5%AE%A2%E6%97%B6%E8%87%AA%E5%8A%A8%E6%8F%92%E5%85%A5frontmatter%E7%9A%84%E5%AE%9E%E7%8E%B0/:1:0","tags":["VSCODE","Hexo","FrontMatter"],"title":"VSCODE写HEXO博客时自动插入FrontMatter的实现","uri":"/vscode%E5%86%99hexo%E5%8D%9A%E5%AE%A2%E6%97%B6%E8%87%AA%E5%8A%A8%E6%8F%92%E5%85%A5frontmatter%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Hexo"],"content":"第二步 然后在VSCODE的设置中添加配置： \"[markdown]\": { \"editor.formatOnSave\": true, \"editor.renderWhitespace\": \"all\", \"editor.quickSuggestions\": { \"other\": true, \"comments\": true, \"strings\": true }, \"editor.acceptSuggestionOnEnter\": \"on\" } ","date":"2021-08-20","objectID":"/vscode%E5%86%99hexo%E5%8D%9A%E5%AE%A2%E6%97%B6%E8%87%AA%E5%8A%A8%E6%8F%92%E5%85%A5frontmatter%E7%9A%84%E5%AE%9E%E7%8E%B0/:2:0","tags":["VSCODE","Hexo","FrontMatter"],"title":"VSCODE写HEXO博客时自动插入FrontMatter的实现","uri":"/vscode%E5%86%99hexo%E5%8D%9A%E5%AE%A2%E6%97%B6%E8%87%AA%E5%8A%A8%E6%8F%92%E5%85%A5frontmatter%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Hexo"],"content":"第三步 经过以上两个步骤后，用VSCODE写hexo博客，只需要在hexo的source_post目录下新建markdown文件，并输入文件名，此时在编辑器中输入---，VSCODE将弹出自动补全的窗口，选中回车即可输入以下内容,省去了人工输入大量Front Matter信息。 --- title: VSCODE写HEXO博客时自动插入FrontMatter的实现 date: 2021-08-20 12:47:39 update: 2021-08-20 12:47:39 tags: - - categories: - - description: cover: keywords: --- ","date":"2021-08-20","objectID":"/vscode%E5%86%99hexo%E5%8D%9A%E5%AE%A2%E6%97%B6%E8%87%AA%E5%8A%A8%E6%8F%92%E5%85%A5frontmatter%E7%9A%84%E5%AE%9E%E7%8E%B0/:3:0","tags":["VSCODE","Hexo","FrontMatter"],"title":"VSCODE写HEXO博客时自动插入FrontMatter的实现","uri":"/vscode%E5%86%99hexo%E5%8D%9A%E5%AE%A2%E6%97%B6%E8%87%AA%E5%8A%A8%E6%8F%92%E5%85%A5frontmatter%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Hexo"],"content":"Over ","date":"2021-08-20","objectID":"/vscode%E5%86%99hexo%E5%8D%9A%E5%AE%A2%E6%97%B6%E8%87%AA%E5%8A%A8%E6%8F%92%E5%85%A5frontmatter%E7%9A%84%E5%AE%9E%E7%8E%B0/:4:0","tags":["VSCODE","Hexo","FrontMatter"],"title":"VSCODE写HEXO博客时自动插入FrontMatter的实现","uri":"/vscode%E5%86%99hexo%E5%8D%9A%E5%AE%A2%E6%97%B6%E8%87%AA%E5%8A%A8%E6%8F%92%E5%85%A5frontmatter%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":null,"content":"https://blog.51cto.com/jack88/2145833 mongodb数据备份和恢复主要分为二种： 一种是针对库的mongodump和mongorestore， 一种是针对库中表的mongoexport和mongoimport。 ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:0:0","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"一、 mongodump备份数据库 ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:1:0","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"1.常用命令格式 ​ mongodump -h IP –port 端口 -u 用户名 -p 密码 -d 数据库 -c 表 -o 文件存放路径 参数说明：-h 指明数据库宿主机的IP–port 指明数据库的端口 -u 指明数据库的用户名-p 指明数据库的密码-d 指明数据库的名字-c 指明collection的名字-o 指明到要导出的文件名-q 指明导出数据的过滤条件 ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:1:1","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"2.导出所有数据库 mongodump -o /data/mongobak/ ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:1:2","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"3.导出指定数据库 mongodump -d SERVERLOG -o /data/mongobak/SERVERLOG.bak/ ​ ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:1:3","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"二、 mongorestore恢复数据库 自行补充： 恢复其他数据库中的表到已有数据库中，已有数据库已经有表，且数据库有账号密码验证： mongorestore -u 用户名 -p 密码 --authenticationDatabase admin -d leanote --dir /leanote_install_data/ ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:2:0","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"1.常用命令格式 ​ mongorestore -h IP –port 端口 -u 用户名 -p 密码 -d 数据库 –drop 文件存在路径 ​ –drop：先删除所有的记录，然后恢复. ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:2:1","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"2.恢复所有数据库到mongodb中 ​ mongorestore /data/mongobak/ #所有库的备份路径 ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:2:2","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"3. 恢复指定的数据库 mongorestore -d SERVERLOG /data/mongobak/SERVERLOG.bak/SERVERLOG/ # SERVERLOG这个数据库的备份路径 mongorestore -d SERVERLOG_new /data/mongobak/SERVERLOG.bak/SERVERLOG/ #将SERVERLOG备份数据还原到SERVERLOG_new数据库中 ​ ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:2:3","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"三、 mongoexport导出（表或者表中部分字段） ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:3:0","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"1. 常用命令格式 mongoexport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 -f 字段 -q 条件导出 --csv -o 文件名 ​ 参数重点说明：-f 导出指定字段，以逗号分割，-f uid,name,age导出uid,name,age这三个字段-q 可以根据查询条件导出，-q ‘{ “uid” : “100” }’ 导出uid为100的数据–csv 表示导出的文件格式为csv的。这个比较有用，因为大部分的关系型数据库都是支持csv，在这里有共同点 ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:3:1","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"2. 导出整张表 mongoexport -d SERVERLOG -c users -o /data/mongobak/SERVERLOG.bak/ # users.dat connected to: 127.0.0.1 exported 4 records ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:3:2","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"3. 导出表中部分字段 mongoexport -d SERVERLOG -c users --csv -f uid,name,age -o /data/mongobak/SERVERLOG.bak/ # users.csv connected to: 127.0.0.1 exported 4 records ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:3:3","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"4. 根据条件导出数据 mongoexport -d SERVERLOG -c users -q '{uid:{$gt:1}}' -o /data/mongobak/SERVERLOG.bak/ # users.json connected to: 127.0.0.1 exported 3 records ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:3:4","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"四、 mongoimport导入（表或者表中部分字段） ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:4:0","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"1. 常用命令格式 恢复整表导出的非csv文件 mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --upsert --drop 文件名 –upsert:插入或者更新现有数据 恢复部分字段的导出文件 mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --upsertFields 字段 --drop 文件名 –upsertFields:更新部分的查询字段，必须为索引,以逗号分隔. 恢复导出的csv文件 mongoimport -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -c 表名 --type 类型 --headerline --upsert --drop 文件名 –type：导入的文件类型（默认json） ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:4:1","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"2. 恢复导出的表数据 mongoimport -d SERVERLOG -c users --upsert /data/mongobak/SERVERLOG.bak/ # users.dat connected to: 127.0.0.1 Tue Dec 3 08:26:52.852 imported 4 objects ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:4:2","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"3. 部分字段的表数据导入 mongoimport -d SERVERLOG -c users --upsertFields uid,name,age /data/mongobak/SERVERLOG.bak/ # users.datconnected to: 127.0.0.1 Tue Dec 3 08:31:15.179 imported 4 objects ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:4:3","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":null,"content":"4. 恢复csv文件 mongoimport -d SERVERLOG -c users --type csv --headerline --file /data/mongobak/SERVERLOG.bak/ # users.csv connected to: 127.0.0.1 Tue Dec 3 08:37:21.961 imported 4 objects –file:需要导入的文件 ","date":"2021-08-17","objectID":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/:4:4","tags":["MongoDB"],"title":"MongoDB数据库的备份和恢复","uri":"/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/"},{"categories":["JSON"],"content":"https://pypi.org/project/python-json2csv/ ","date":"2021-08-17","objectID":"/json%E8%BD%ACcsv%E6%A0%BC%E5%BC%8F/:0:0","tags":["JSON"],"title":"JSON转CSV格式","uri":"/json%E8%BD%ACcsv%E6%A0%BC%E5%BC%8F/"},{"categories":["JSON"],"content":"Project description Convert json array data to csv. Note: zencore-json2csv rename to python-json2csv ","date":"2021-08-17","objectID":"/json%E8%BD%ACcsv%E6%A0%BC%E5%BC%8F/:1:0","tags":["JSON"],"title":"JSON转CSV格式","uri":"/json%E8%BD%ACcsv%E6%A0%BC%E5%BC%8F/"},{"categories":["JSON"],"content":"安装 pip install python-json2csv ","date":"2021-08-17","objectID":"/json%E8%BD%ACcsv%E6%A0%BC%E5%BC%8F/:2:0","tags":["JSON"],"title":"JSON转CSV格式","uri":"/json%E8%BD%ACcsv%E6%A0%BC%E5%BC%8F/"},{"categories":["JSON"],"content":"用法 E:\\\u003ejson2csv --help Usage: json2csv [OPTIONS] Options: -f, --file FILENAME Input file name, use - for stdin. --file-encoding TEXT Input file encoding. -o, --output FILENAME Output file name, use - for stdout. --output-encoding TEXT Output file encoding. -k, --keys TEXT Output field names. Comma separated string list. -p, --path TEXT Path of the data. --help Show this message and exit. ","date":"2021-08-17","objectID":"/json%E8%BD%ACcsv%E6%A0%BC%E5%BC%8F/:3:0","tags":["JSON"],"title":"JSON转CSV格式","uri":"/json%E8%BD%ACcsv%E6%A0%BC%E5%BC%8F/"},{"categories":["JSON"],"content":"案例 ","date":"2021-08-17","objectID":"/json%E8%BD%ACcsv%E6%A0%BC%E5%BC%8F/:4:0","tags":["JSON"],"title":"JSON转CSV格式","uri":"/json%E8%BD%ACcsv%E6%A0%BC%E5%BC%8F/"},{"categories":["JSON"],"content":"案例 1 输入数据: [ [1,2,3], [2,3,4] ] 命令: cat input.txt | json2csv -o output.txt 结果: 1,2,3 2,3,4 ","date":"2021-08-17","objectID":"/json%E8%BD%ACcsv%E6%A0%BC%E5%BC%8F/:4:1","tags":["JSON"],"title":"JSON转CSV格式","uri":"/json%E8%BD%ACcsv%E6%A0%BC%E5%BC%8F/"},{"categories":["JSON"],"content":"案例 2 输入数据: [ {\"f1\": 11, \"f2\": 12, \"f3\": 13}, {\"f1\": 21, \"f3\": 23, \"f2\": 22} ] 命令: cat input.txt | json2csv -o output.txt -k f1,f2,f3 结果: 11,12,13 21,22,23 ","date":"2021-08-17","objectID":"/json%E8%BD%ACcsv%E6%A0%BC%E5%BC%8F/:4:2","tags":["JSON"],"title":"JSON转CSV格式","uri":"/json%E8%BD%ACcsv%E6%A0%BC%E5%BC%8F/"},{"categories":["JSON"],"content":"案例 3（嵌套） 输入: { \"data\": { \"list\": [ [1,2,3], [2,3,4], ] } } 命令: cat input.txt | json2csv -o output.txt -p data.list 结果: 1,2,3 2,3,4 ","date":"2021-08-17","objectID":"/json%E8%BD%ACcsv%E6%A0%BC%E5%BC%8F/:4:3","tags":["JSON"],"title":"JSON转CSV格式","uri":"/json%E8%BD%ACcsv%E6%A0%BC%E5%BC%8F/"},{"categories":["C#"],"content":"1.问题意义 据说界面程序开发,首选C#(像lebview之类的也很好) 但是,**能不能用其他语言开发核心代码,只用C#做界面?**毕竟每种语言都有自己擅长的领域. ","date":"2021-08-17","objectID":"/%E4%BD%BF%E7%94%A8csharp%E5%B8%A6%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe/:0:1","tags":["C#"],"title":"使用CSharp带参数调用外部EXE","uri":"/%E4%BD%BF%E7%94%A8csharp%E5%B8%A6%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe/"},{"categories":["C#"],"content":"2.exe程序 比如有个example.exe,能接受4个参数.用cmd的调用方法是 example.exe \"1\" \"a\" \"2\" \"3\" ","date":"2021-08-17","objectID":"/%E4%BD%BF%E7%94%A8csharp%E5%B8%A6%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe/:0:2","tags":["C#"],"title":"使用CSharp带参数调用外部EXE","uri":"/%E4%BD%BF%E7%94%A8csharp%E5%B8%A6%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe/"},{"categories":["C#"],"content":"3.C#调用方法 // 调用exe的函数 using System.Diagnostics; public bool StartProcess(string runFilePath, params string[] args) { string s = \"\"; foreach (string arg in args) { s = s + arg + \" \"; } s = s.Trim(); Process process = new Process();//创建进程对象 ProcessStartInfo startInfo = new ProcessStartInfo(runFilePath, s); // 括号里是(程序名,参数) process.StartInfo = startInfo; process.Start(); return true; } private void start_craw(object sender, EventArgs e) { string exe_path = \"E:/example.exe\"; // 被调exe string[] the_args = { \"1\",\"2\",\"3\",\"4\"}; // 被调exe接受的参数 StartProcess(exe_path, the_args); } ","date":"2021-08-17","objectID":"/%E4%BD%BF%E7%94%A8csharp%E5%B8%A6%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe/:0:3","tags":["C#"],"title":"使用CSharp带参数调用外部EXE","uri":"/%E4%BD%BF%E7%94%A8csharp%E5%B8%A6%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe/"},{"categories":["C#"],"content":"4.实战 给按键添加点击事件,点击事件触发start_craw函数 ","date":"2021-08-17","objectID":"/%E4%BD%BF%E7%94%A8csharp%E5%B8%A6%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe/:0:4","tags":["C#"],"title":"使用CSharp带参数调用外部EXE","uri":"/%E4%BD%BF%E7%94%A8csharp%E5%B8%A6%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe/"},{"categories":["C#"],"content":"5.StartProcess更多的设置 public bool StartProcess(string runFilePath, params string[] args) { string s = \"\"; foreach (string arg in args) { s = s + arg + \" \"; } s = s.Trim(); Process process = new Process();//创建进程对象 ProcessStartInfo startInfo = new ProcessStartInfo(runFilePath, s); // 括号里是(程序名,参数) process.StartInfo = startInfo; //process.StartInfo.UseShellExecute = true; //是否使用操作系统的shell启动 //startInfo.RedirectStandardInput = true; //接受来自调用程序的输入 //startInfo.RedirectStandardOutput = true; //由调用程序获取输出信息 //startInfo.CreateNoWindow = true; //不显示调用程序的窗口 process.Start(); return true; } ","date":"2021-08-17","objectID":"/%E4%BD%BF%E7%94%A8csharp%E5%B8%A6%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe/:0:5","tags":["C#"],"title":"使用CSharp带参数调用外部EXE","uri":"/%E4%BD%BF%E7%94%A8csharp%E5%B8%A6%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe/"},{"categories":["C#"],"content":"6.疑难解答 调用外部exe时,当这个exe运行出错时,会闪退,无法看清错误原因 解决: 直接去调试这个被调用的exe即可. 作者：xigua1234 链接：https://www.jianshu.com/p/43aa64992706 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-08-17","objectID":"/%E4%BD%BF%E7%94%A8csharp%E5%B8%A6%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe/:0:6","tags":["C#"],"title":"使用CSharp带参数调用外部EXE","uri":"/%E4%BD%BF%E7%94%A8csharp%E5%B8%A6%E5%8F%82%E6%95%B0%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8exe/"},{"categories":null,"content":"来源：酷安评论 分享一些配色网站 转载自公众号：平面课程表，下面是原链接 查看链接 文字我都放在这里了，有些加载会比较慢，需要xx （给出的图片是在最后一个网站随便找的，挺好看) 1.中国色 据说该网站收藏了最全的中国色，颜色皆以色卡的形式来呈现，并且还有中英文互译，可以说是十分贴心了。 网址：查看链接 2.Nipponcolors 日式传统配色该网站收藏了日本传统色彩，也是以色卡的形式来呈现，它最棒的地方是背景可以根据你所选择的颜色来变化。 网址：查看链接 3.Colorion MaterialColorion Material 网站不仅分享了几百个色板，并且还有收藏夹的功能，方便用户收藏。 {height=“500px”} 4.LOL ColorsLOL Colors 是一款非常可爱的配色网站，鼠标移动到不同颜色的水滴上会有色彩代码(Hex Code)的颜色值。 网址：查看链接 5.Color HuntColor Hunt 不仅会实时更新不同配色方案，用户还能在该网站分享自己的色彩搭配，优质的配色方案往往会获得大量的点赞。 图片说明 {height=“500px”} 6.Material PaletteMaterial Palette 主要特色是可以让用户一边选择颜色同时还能实时预览效果图，并且用户只需要选择1个或2个颜色后系统会自己匹配出一组APP UI 配色方案。 ![](Material Design Color Palette Generator - Material Palette.png){height=“585px”} 7.Palettable 在进入网页时，会随机推荐颜色，你只需要选择喜欢or不喜欢，直到搭配出想要的色板。 网址：www.palettable.io/ {height=“500px”} 8.colorfavscolorfavs 它可以根据你上传的图片来分析配色，自动检测色值。 网址：www.colorfavs.com/ 9.colrdcolrd 不仅可以保存自己喜欢的配色，也可以自己上传图片和配色方案。 网址：查看链接 10.COLOURlovers 该网站除了提供了眼花缭乱的页面色彩搭配方案外，还把DIY的原理运用其中，让那些精彩的配色不会随着时间的流逝而被遗忘。用户也可以按照自定的格式上传配色方案与大家分享。 网址：查看链接 11.WebGradientsWebGradients 网站收录了180种渐变色彩，整体风格比较柔和。点击下方图示渐变色后进入全屏预览，直接可复制CSS代码。 网址：查看链接 图片信息描述 {height=“500px”} 12.ColourcoColourco 网站会根据你鼠标的移动来变换颜色。 网址：查看链接 {height=“500px”} 13.Color Claim“ColorClaim” 是由德国的一位设计师创办的配色站点，该网站展示的都是博主收集的最喜欢的颜色组合，目前已经收录了102种组合。 网址：查看链接 14.Adobe Color CCAdobe Color CC 不仅有着超全的配色方案，还能根据色轮来调整配色。 网址：color.adobe.com/ 15.UigradientsUigradients 收藏了将近上百种渐变配色方案，以分享美丽渐变色彩为主的分享站，里面接近上百种渐变配色方案，设计师可根据自己风格来选择搭配。 网址：查看链接 {height=“500px”} 16.0 to 255 你随机点击一个颜色，它会有序呈现色彩变化的颜色列表，这时你可以选取合适的使用。 网址：查看链接 17.BrandColorsBrandColors 收集了世界上许多知名品牌的配色表，可以直接让我们参考一个品牌的配色，我们也可以在该网站上下载任何一个品牌的配色表。 网址：查看链接 {height=“500px”} 18.Design SeedsDesign Seeds是一个色彩与灵感的网站，主要从自然和有意义的生活美学中寻找创作元素。 网址：查看链接 ","date":"2021-08-16","objectID":"/%E9%85%8D%E8%89%B2/:0:0","tags":["配色"],"title":"一些配色网站","uri":"/%E9%85%8D%E8%89%B2/"},{"categories":["软件收藏"],"content":"https://github.com/WelliSolutions/HugeJsonViewer ","date":"2021-08-16","objectID":"/%E8%B6%85%E5%A4%A7json%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%B7%A5%E5%85%B7/:0:0","tags":["JSON"],"title":"超大JSON文件浏览工具","uri":"/%E8%B6%85%E5%A4%A7json%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%B7%A5%E5%85%B7/"},{"categories":["软件收藏"],"content":"2021年8月6日17点更新 这个更好：Dadroit JSON Viewer ","date":"2021-08-16","objectID":"/%E8%B6%85%E5%A4%A7json%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%B7%A5%E5%85%B7/:1:0","tags":["JSON"],"title":"超大JSON文件浏览工具","uri":"/%E8%B6%85%E5%A4%A7json%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%B7%A5%E5%85%B7/"},{"categories":["C#"],"content":"https://blog.csdn.net/dslobo/article/details/108815969 ","date":"2021-08-16","objectID":"/csharp%E8%A7%A3%E6%9E%90%E8%AF%BB%E5%8F%96json/:0:0","tags":["C#"],"title":"CSharp解析读取JSON","uri":"/csharp%E8%A7%A3%E6%9E%90%E8%AF%BB%E5%8F%96json/"},{"categories":["C#"],"content":"要读取的json文件内容 { \"accepttime\": 1600966807, \"certificate\": \"\", \"completetext\": \"\", \"completetime\": 1601010419, \"createtime\": 1600966807, \"deleteflag\": 0, \"endtimestr\": \"12:00\", \"gid\": 42, \"netbarCameraList\": [{ \"account\": \"admin\", \"address\": \"172.16.36.17\", \"cameraid\": 21, \"gid\": 42, \"name\": \"36\", \"password\": \"52358\", \"port\": 554 }], \"netbarname\": \"36新亚网吧\", \"uniacid\": 6, \"userid\": 66 } ","date":"2021-08-16","objectID":"/csharp%E8%A7%A3%E6%9E%90%E8%AF%BB%E5%8F%96json/:1:0","tags":["C#"],"title":"CSharp解析读取JSON","uri":"/csharp%E8%A7%A3%E6%9E%90%E8%AF%BB%E5%8F%96json/"},{"categories":["C#"],"content":"使用到的关键库 using Newtonsoft.Json; using Newtonsoft.Json.Linq; ","date":"2021-08-16","objectID":"/csharp%E8%A7%A3%E6%9E%90%E8%AF%BB%E5%8F%96json/:2:0","tags":["C#"],"title":"CSharp解析读取JSON","uri":"/csharp%E8%A7%A3%E6%9E%90%E8%AF%BB%E5%8F%96json/"},{"categories":["C#"],"content":"实现代码 using Newtonsoft.Json; using Newtonsoft.Json.Linq; using System; using System.IO; using System.Text; using System.Windows.Forms; namespace WindowsFormsApplication1 { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { // 读取外部json格式文件 string text = File.ReadAllText(@\"C:\\Users\\Administrator\\Desktop\\111.txt\"); byte[] mybyte = Encoding.UTF8.GetBytes(text); string aaa = Encoding.UTF8.GetString(mybyte); //Console.WriteLine(aaa); aaa为字符串类型 //将JSON反序列化为.NET对象。 JObject jo1 = (JObject)JsonConvert.DeserializeObject(aaa); //第一层 string name = jo1[\"netbarname\"].ToString(); Console.WriteLine(name); string netbarCameraList = jo1[\"netbarCameraList\"].ToString(); Console.WriteLine(netbarCameraList); //第二层 string account = jo1[\"netbarCameraList\"][0][\"account\"].ToString(); Console.WriteLine(account); string address = jo1[\"netbarCameraList\"][0][\"address\"].ToString(); Console.WriteLine(address); } } } ","date":"2021-08-16","objectID":"/csharp%E8%A7%A3%E6%9E%90%E8%AF%BB%E5%8F%96json/:3:0","tags":["C#"],"title":"CSharp解析读取JSON","uri":"/csharp%E8%A7%A3%E6%9E%90%E8%AF%BB%E5%8F%96json/"},{"categories":["Docker"],"content":"手摸手带你 Docker 从入门到实践 在下最近遇到要在服务器上安装 Mysql、Nginx、EasyMock 等工具的场景，这里记录一下我使用 Docker 安装的过程，希望也能在类似的场景中帮助到大家～ 本文前备知识需要一些 Linux 的一些基本命令，推介先看一下 \u003c半小时搞会 CentOS 入门必备基础知识\u003e 这篇文章。 CentOS 版本： 7.6 Nginx 版本： 1.16.1 Docker 版本： 19.03.12 你多学一样本事，就少说一句求人的话 ","date":"2021-08-16","objectID":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/:1:0","tags":["docker","linux"],"title":"手摸手带你Docker从入门到实践","uri":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"},{"categories":["Docker"],"content":"1. 介绍 1.1 出现的原因 前后端开发到测试到生产的过程中，经常会遇到一个问题，明明我在本地跑没问题，为什么到测试环境或者生产环境就报错了了呢，常常这是因为开发、测试、生产的环境与配置不同导致的。 折腾过环境配置的人都明白其中麻烦，换一台系统、虚拟机、机器，就又要重来一次，费力费时。由于环境和配置的原因，各种奇奇怪怪因为环境和配置的 Bug，总是像打地鼠游戏里面的地鼠一样不断冒出来 🐹 ![](c9ce28e3e43e4bb292b92fd1a4786fe9tplv-k3u1fbpfcp-zoom-1.image#vwid=1586\u0026vhei=600\" alt=“Docker” style=“zoom:80%;” /\u003e Docker 对这个问题给出了一个很好的解决方案，通过镜像将除了系统之外所需要的系统环境由下而上打包，达到服务跨平台的无缝运作。也就是说，安装的时候，把特定的环境一模一样地搬过来，从而解决「在我的电脑上能跑，在 xx 环境就跑不了」的情况。 另外一个重要的原因，就是轻量，基于容器的虚拟化，Docker 的镜像仅包含业务运行所需的 runtime 环境，一个 CentOS/Ubuntu 基础镜像仅 170M，因为轻量一个宿主机可以轻松安装数百个容器。 1.2 是什么 Docker 是基于 Go 语言实现的云开源项目，从 2013 年发布到现在一直广受关注。Docker 可以让你像使用集装箱一样快速的组合成应用，并且可以像运输标准集装箱一样，尽可能的屏蔽代码层面的差异。它将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。 程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。 本文就不对比虚拟机跟 Docker 的区别和优劣了，每个文章都有，说烂了，想了解的话可以百度一下 😂，我这里就不多说了，下面直接看看怎么安装怎么用起来吧。 ","date":"2021-08-16","objectID":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/:1:1","tags":["docker","linux"],"title":"手摸手带你Docker从入门到实践","uri":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"},{"categories":["Docker"],"content":"2. 安装 \u0026 配置 2.1 Mac 下安装 在下直接使用 Homebrew Cask 来安装，Mac 下： # Homebrew 安装 braw cask install docker 即可，安装完输入命令，直接报错！ ➜ ~ docker zsh: command not found: docker # 报错 遇到这个报错别担心，安装完之后要在应用列表里面双击 Docker 应用，输入密码之后就可以使用这个命令了 😅。 2.2 CentOS 下安装 Docker 要求 CentOS 版本必须在 6.5 及以上才可以安装。 # 安装 sudo yum install yum-utils device-mapper-persistent-data lvm2 sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo sudo yum install docker-ce # 开启 Docker sudo systemctl start docker 在 Windows 上可以直接下载安装包来安装，或者 Mac 上不使用 Homebrew 也可以去官网直接下载安装包来安装，百度一下到处都是安装方法，其他的就不用多说。 ","date":"2021-08-16","objectID":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/:1:2","tags":["docker","linux"],"title":"手摸手带你Docker从入门到实践","uri":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"},{"categories":["Docker"],"content":"3. 简单配置并跑起来 3.1 配置镜像加速 在 MacOS 的 Docker 配置 Perferences -\u003e Docker Engine 或者 Windows 的 Settings -\u003e Deamon 中的 JSON 中增加一项 registry-mirrors 如下 配置完之后在命令行中 docker info 就可以查看到我们配置的镜像加速地址了。 ➜ ~ sudo docker info ... Registry Mirrors: https://reg-mirror.qiniu.com/ http://hub-mirror.c.163.com/ https://registry.docker-cn.com/ ... 如果你的系统的 Docker 没有客户端，比如 CentOS 中，可以直接修改 deamon 配置文件： # 修改/创建 docker 的 deamon 配置文件 sudo vi /etc/docker/daemon.json # 修改为如下配置 { \"experimental\": false, \"debug\": true, \"registry-mirrors\": [ \"https://reg-mirror.qiniu.com\", \"http://hub-mirror.c.163.com\", \"https://registry.docker-cn.com\" ] } # 修改完 :wq 重启 sudo systemctl restart docker 3.2 Hello World ！ 然后就可以快乐跑起来我们第一个 Docker 指令 Hello World 了 Good start ！ 🎉 ","date":"2021-08-16","objectID":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/:1:3","tags":["docker","linux"],"title":"手摸手带你Docker从入门到实践","uri":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"},{"categories":["Docker"],"content":"4. 镜像 \u0026 容器 \u0026 仓库 镜像和容器的关系就像类和类的实例，一个镜像可以同时跑多个容器，单个容器实例又可以创建新的镜像。如下图： 下面解释一下这个图里面出现的元素 概念 说明 Docker 镜像 Images 用于创建 Docker 容器的只读模板，比如 Ubuntu 16.04系统、Nginx 1.16.0 等，是一个特殊的文件系统，包括容器运行时需要的程序、库、资源、参数等，但不包含任何动态数据，内容在构建后也不会被改变，一个镜像可以创建多个容器 Docker 容器 Container 容器是独立运行、相互隔离的一个或一组应用，是镜像创建的运行实例，实质是进程，可以看作为一个简易版的 Linux 环境 + 运行在其中的应用程序 Docker 客户端 Client 客户端通过命令行或者其他工具使用 Docker SDK (docs.docker.com/develop/sdk…) 与 Docker 的守护进程通信 Docker 主机 Host 一个物理或者虚拟的机器用于执行 Docker 守护进程和容器 Docker 仓库 Repository 集中存放镜像文件的地方，分为公有仓库和私有仓库。 Docker 注册服务器 Registry 是一个集中存储、分发镜像的服务，官方的叫 Docker Hub。一个 Docker Registry 中可包含多个仓库，每个仓库可以包含多个标签 Tag 的镜像，不同的标签对应不同的版本 Docker Machine Docker Machine 是一个简化 Docker 安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如 VirtualBox、 Digital Ocean、Microsoft Azure 容器的生命周期图示 容器的五个核心状态，也就是图中色块表示的：Created、Running、Paused、Stopped、Deleted： Created：容器已经被创建，容器所需的相关资源已经准备就绪，但容器中的程序还未处于运行状态。 Running：容器正在运行，也就是容器中的应用正在运行。 Paused：容器已暂停，表示容器中的所有程序都处于暂停 不是停止不是停止 状态。 Stopped：容器处于停止状态，占用的资源和沙盒环境都依然存在，只是容器中的应用程序均已停止。 Deleted：容器已删除，相关占用的资源及存储在 Docker 中的管理信息也都已释放和移除。 本文主要关注于使用，就不太赘述这些状态的切换等，下面直接上手。 ","date":"2021-08-16","objectID":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/:1:4","tags":["docker","linux"],"title":"手摸手带你Docker从入门到实践","uri":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"},{"categories":["Docker"],"content":"5. 基本使用 5.1 操作命令 # 开启 Docker 开机自启动 sudo systemctl enable docker # 关闭 Docker 开机自启动 sudo systemctl disable docker 5.2 镜像命令 # 去下载镜像，先从本地找，没有去镜像，最后没有去 hub，标签不写默认为 lastest docker pull [镜像名]:[标签Tag] # 列出本机的所有 image 文件，-a 显示本地所有镜像（包括中间镜像），-q 只显示镜像ID，--digests 显示镜像的摘要信息 docker image ls docker images # 删除 image 文件, -f 强制删除镜像 docker rmi [镜像名][:标签Tag] docker rmi [镜像名1][:标签Tag] [镜像名2][:标签Tag] # 删多个 docker rmi $(docker ps -a -q) # 删全部，后面是子命令 # 查询镜像名称，--no-trunc 显示完整的镜像描述，--filter=stars=30 列出star不少于指定值的镜像，--filter=is-automated=true 列出自动构建类型的镜像 docker search [关键字] # 下载镜像，标签 tag 不写默认为 lastest，也可以自己加比如 :3.2.0 docker pull [镜像名][:标签Tag] 5.3 容器命令 # 列出本机正在运行的容器，-a 列出本机所有容器包括终止运行的容器，-q 静默模式只显示容器编号，-l 显示最近创建的容器 docker container ls # 等价于下面这个命令 docker ps # 新建并启动容器 docker run [option] [容器名] # 启动容器 docker start [容器ID]/[容器Names] # 重启容器 docker restart [容器ID]/[容器Names] # 终止容器运行 docker kill [容器ID] # 强行终止，相当于向容器里面的主进程发出 SIGKILL 信号，那些正在进行中的操作会全部丢失 docker kill $(docker ps -a -q) # 强行终止所有容器 docker stop [容器ID] # 从容终止，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号 docker stop $(docker ps -a -q) # 终止所有容器 # 终止运行的容器文件，依然会占据硬盘空间，可以使用 docker container rm 命令删除，-f 强制删除可以删除正在运行的容器 docker rm [容器ID] docker rm `docker ps -aq` # 删除所有已经停止的容器，因为没停止的rm删不了需要加-f # 查看容器的输出，-t加入时间戳，-f跟随最新日志打印，--tail数字显示最后多少条，如果docker run时，没有使用-it，就要用这个命令查看输出 docker logs [容器ID] # 查看容器进程信息 docker top [容器ID]/[容器Names] docker port [容器ID]/[容器Names] # 退出容器 exit # 容器退出 ctrl + p + q # 容器退出，快捷键 # 进入容器 docker attach [容器ID] # 退出容器时会让容器停止，本机的输入直接输到容器中 docker exec -it [容器ID] # 退出容器时不会让容器停止，在已运行的容器中执行命令，不创建和启动新的容器 # 设置容器在docker启动时自动启动 docker container update --restart=always [容器名字] 这里要特别说一下 docker run 的 option，因为最常用： --name 为容器指定一个名称； -d 容器启动后进入后台，并返回容器 ID，即启动守护式容器； -P 随机端口映射； -p 80:8080 将本地 80 端口映射到容器的 8080 端口； bash 容器启动以后，内部第一个执行的命令。这里启动 bash，保证用户可以使用 Shell； -i 以交互模式运行容器，通常与 -t 同时使用； -t 为容器重新分配一个伪输入终端，容器的 Shell 会映射到当前的 Shell，然后在本机窗口输入的命令，就会传入容器，通常与 -i 同时使用； --rm 在容器终止运行后自动删除容器文件； --restart=always 设置容器自启动； -v /xxx:/yyy 映射命令，把本机的 xxx 目录映射到容器中的 yyy 目录，也就是说改变本机的 xxx 目录下的内容， 容器 yyy 目录中的内容也会改变； 比如我在 CentOS 下跑起来一个 CentOS 的 Docker 容器： # 下载 docker pull centos # 在上面下载的 centos 镜像基础上，新建一个容器名为 mycentos0901 的 centos 实例，并进入这个容器的 bash docker run -it --name mycentos0901 0d120b6ccaa8 [root@169c9fffeecd /] # 进入容器，下面输入命令，注意这里 root 后面的一串 ID ls # 可以看到centos的根目录文件列表 docker # bash: docker: command not found 这个容器没有安装docker 是不是很神奇，我们可以在一开始的 CentOS 下面执行 docker ps 来查看容器列表： 你会发现上面那个 ID，正是下面列表中跑起来的这个容器的 ID，镜像的 ID 也是我们前面 pull 下来的 CentOS 镜像 ID，名字也是我们起的 mycentos0901。 如果 docker run 之后报 Conflict. The container name \"xxxx\" is already in use by container 就直接运行 docker rm $(docker ps -a -q) 删除已停止的容器，或者精确删除 docker rm [containerID] 也可以，就可以了。 5.4 几个常见场景的命令使用 守护式启动容器 使用 centos 以后台模式启动一个容器 docker run -d --name mycentos0903 0d120b6ccaa8，启动之后 docker ps -a 查看，发现容器并不在运行中，这是因为 Docker 的运行机制：Docker 容器后台运行，必须有一个前台进程。 容器运行的命令如果不是那些一直挂起的命令，比如 top、tail ，运行结束会自动退出。所以为了让容器持续在后台运行，那么需要将运行的程序以前台进程的形式运行。 比如这里在后台运行一个命令，这个命令一直在打印 docker run -d centos /bin/sh -c \"while true; do echo hello zzyy; sleep 2; done\"，然后我们 logs 查看一下： 退出容器后对容器操作 退出容器后可以通过 exec 方法对正在运行的容器进行操作： 在容器中拷贝文件到外部 拷贝文件使用 cp 命令 docker cp [容器ID]/[容器Names]:[要拷贝的文件目录] [本机目录] # 容器文件拷贝到本机 docker cp [本机目录] [容器ID]/[容器Names]:[要拷贝的文件目录] # 本机文件拷贝到容器 cp 不仅能把容器中的文件/文件夹拷贝到本机，也可以把本机中的文件/文件夹拷贝到容器。 演示一下，这里先到容器里面创建一个无聊的文件 xixi.txt，然后拷贝到本机： 实用的时候，我们可以拷贝配置、日志等文件到本地。 ","date":"2021-08-16","objectID":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/:1:5","tags":["docker","linux"],"title":"手摸手带你Docker从入门到实践","uri":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"},{"categories":["Docker"],"content":"6. 安装 MySQL # 查询镜像 docker search mysql # 下载镜像，实测没配置镜像加速的时候会比较慢，配置了就好一些 docker pull mysql # 查看镜像 docker images # 创建并运行容器 docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=888888 -v /Users/sherlocked93/Personal/configs/mysql.d:/etc/mysql/conf.d --name localhost-mysql mysql 稍微解释一下上面的参数： -p 3307:3306 将本机的 3307 端口映射到 mysql 容器的 3306 端口，根据需要自行更改； -e MYSQL_ROOT_PASSWORD=\u003cstring\u003e 设置远程登录的 root 用户密码； --name \u003cstring\u003e 可选，设置容器别名； -v xxx/mysql.d:/etc/mysql/conf.d 将本地目录下设置文件夹映射到容器的 /etc/mysql/conf.d -v xxx/logs:/logs 将本机指定目录下的 logs 目录挂载到容器的 /logs -v xxx/data:/var/lib/mysql 将主机制定目录下的 data 目录挂载到容器的 /var/lib/mysql 运行截图： 然后去 Navicat 中就可以连接到 MySQL 了。 这也太爽了！真的是几行命令就装好了啊，比之前真是快乐多了 😂 ","date":"2021-08-16","objectID":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/:1:6","tags":["docker","linux"],"title":"手摸手带你Docker从入门到实践","uri":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"},{"categories":["Docker"],"content":"7. 安装 Nginx Nginx 的安装和其他的类似，如果你还不太了解 Nginx 如何使用，可以参看 这篇文章，看完基本就了解如何使用和配置了。 # 查询/下载镜像 docker search nginx docker pull nginx {% asset_img e7763230c080498d96d5f012581b03cetplv-k3u1fbpfcp-zoom-1.jpg %} 然后创建一个临时的容器，目的是把默认配置拷贝到本机，我这里把配置文件放到 /mnt 目录下，主要是三个配置文件夹： /etc/nginx 放置 Nginx 配置文件； /var/log/nginx/ 放置 Nginx 日志文件； /usr/share/nginx/html/ 放置 Nginx 前端静态文件都放在这个文件夹； 分别把这几个目录都拷贝到本机的 /mnt 文件夹下的 nginx、nginx_logs、html 文件夹。 刚刚创建的临时容器没用了 docker rm -f [临时容器ID] 把临时容器干掉，然后 docker run 重新创建 Nginx 容器： docker run -d --name localhost-nginx -p 8082:80 \\ -v /mnt/nginx:/etc/nginx \\ -v /mnt/nginx_logs:/var/log/nginx \\ -v /mnt/html:/usr/share/nginx/html \\ --privileged=true nginx --privileged=true 表示容器内部对挂载的目录拥有读写等特权。 其他配置刚刚上面之前已经讲过，应该不用讲了。 然后在你自己浏览器上就可以访问了，如果是云服务器，记得开放对应端口。 ","date":"2021-08-16","objectID":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/:1:7","tags":["docker","linux"],"title":"手摸手带你Docker从入门到实践","uri":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"},{"categories":["Docker"],"content":"8. 安装 Easy Mock 因为 Easy Mock 依赖 Redis 和 MongoDB，因此本地环境使用 docker-compose 来搭建 Easy Mock 应该算是最佳实践了。 安装 docker-compose 官方文档：docs.docker.com/compose/ins… 首先你得确定拥有 docker 环境，如果你是 Windows / Mac 用户，那么安装客户端，就会自带 docker-compose 了。 因为本次我们是在云服务器 CentOS7.6 上搭建，所以我们需要自行安装 docker-compose，运行如下命令，下载当前稳定版本的 docker-compose sudo curl -L \"https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 修改文件权限为可执行文件 sudo chmod +x /usr/local/bin/docker-compose 验证是否安装成功 docker-compose version 编写 docker-compose.yml 配置文件 可以参考官方文档给出的部署文档，也可以参考我下面的配置过程。 首先新建文件 docker-compose.yml 并将下面 docker-compose 文件内容复制进入 docker-compose.yml，然后将内容中注释位置替换为自己需要的本地地址 version: '3' services: mongodb: image: mongo:3.4.1 volumes: # /apps/easy-mock/data/db 是数据库文件存放地址，根据需要修改为本地地址 - '/apps/easy-mock/data/db:/data/db' networks: - easy-mock restart: always redis: image: redis:4.0.6 command: redis-server --appendonly yes volumes: # /apps/easy-mock/data/redis 是 redis 数据文件存放地址，根据需要修改为本地地址 - '/apps/easy-mock/data/redis:/data' networks: - easy-mock restart: always web: image: easymock/easymock:1.6.0 # easy-mock 官方给出的文件，这里是 npm start，这里修改为 npm run dev command: /bin/bash -c \"npm run dev:server\" ports: - 7300:7300 # 改为你自己期望的映射 volumes: # 日志地址，根据需要修改为本地地址 - '/apps/easy-mock/logs:/home/easy-mock/easy-mock/logs' networks: - easy-mock restart: always networks: easy-mock: 启动 Easy Mock 在 docker-compose 文件目录下，运行如下命令： docker-compose up -d 如果遇到 easymock docker 实例报文件权限错误 Error: EACCES: permission denied.... 要在项目根目录执行以下命令 chmod 777 /yourfile/logs 然后就可以通过浏览器上的 你的域名.com:7300 访问到 easy-mock 了！ 如果你觉得域名后面跟着端口号挺难看的，你可以通过配置 Nginx 的二级域名来访问你部署的 easy-mock，配置二级域名的方法参见 这篇文章 ","date":"2021-08-16","objectID":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/:1:8","tags":["docker","linux"],"title":"手摸手带你Docker从入门到实践","uri":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"},{"categories":["Docker"],"content":"9. 可视化管理 关于可视化查询工具，这里就简单推介一个 LazyDocker，由于是在终端运行的，而且支持键盘操作和鼠标点击，就挺骚气的，有了这个一些查询语句可以少打几次了。 ![lzd](/手摸手带你 Docker从入门到实践/520a02d65a9e4ca999013faba0241f7etplv-k3u1fbpfcp-zoom-1.image#vwid=1706\u0026vhei=960) 安装比较简单，运行下面的命令： docker run --rm -it -v \\ /var/run/docker.sock:/var/run/docker.sock \\ -v ~/.config/lazydocker:/.config/jesseduffield/lazydocker \\ lazyteam/lazydocker 可以设置一个终端的 alias alias lzd='docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock -v ~/.config/lazydocker:/.config/jesseduffield/lazydocker lazyteam/lazydocker' 然后你在终端输入 lzd 就可以浏览你的镜像、容器、日志、配置、状态等等内容了。 ","date":"2021-08-16","objectID":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/:1:9","tags":["docker","linux"],"title":"手摸手带你Docker从入门到实践","uri":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"},{"categories":["Docker"],"content":"10. 结语 由于在下目前使用 Docker 的主要场景是 MySQL、Nginx 之类工具的安装，所以本文所介绍的内容也大多属于这个场景。 篇幅原因 Docker 还有一些内容本文没有介绍，但上面的内容已基本满足日常的使用，其他 Docker 的内容可以关注一下在下的后续文章～ 网上的帖子大多深浅不一，甚至有些前后矛盾，在下的文章都是学习过程中的总结，如果发现错误，欢迎留言指出~ 参考文档： Empowering App Development for Developers | Docker 官方网站 Docker核心技术（基础篇） Docker安装mysql Docker文档 Docker-compose文档 使用 docker 运行 easy-mock - 知乎 docker-compose easy-mock - 简书 使用 docker 运行 easy-mock | CodingDiary easymock官方docker仓库：easy-mock/easy-mock-docker 使用docker安装nginx 作者其他高赞文章： JS 中可以提升幸福度的小技巧 Vue 使用中的小技巧 Nginx 从入门到实践，万字详解！ 半小时搞会 CentOS 入门必备基础知识 手摸手 Webpack 多入口配置实践 前端路由跳转基本原理 PS：本文收录在我的博客，地址 Github - SHERlocked93/blog，也欢迎大家关注我的公众号【前端下午茶】，一起加油吧。 如果你感觉文章不错的话，也别忘了给作者点赞支持一下～ ","date":"2021-08-16","objectID":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/:1:10","tags":["docker","linux"],"title":"手摸手带你Docker从入门到实践","uri":"/%E6%89%8B%E6%91%B8%E6%89%8B%E5%B8%A6%E4%BD%A0-docker%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/"},{"categories":["Hexo"],"content":"很多酷炫效果 https://jinan6.vip/posts/3112011529/ ###markdown各种特殊语法，彩色横条、folding、容器等 https://zykj.js.org/posts/e297feab/ folding没解决，暂时使用toggle，仅butterfly主题有效 效果见：https://butterfly.js.org/posts/4aa8abbe/#tag-hide 语法： ","date":"2021-08-14","objectID":"/hexo%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E6%A0%B7%E4%BE%8B%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86/:0:1","tags":["Hexo","美化","Butterfly"],"title":"hexo主题美化样例博客收集","uri":"/hexo%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E6%A0%B7%E4%BE%8B%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86/"},{"categories":["Linux"],"content":"来源参考 查看防火墙某个端口是否开放 firewall-cmd --query-port=3306/tcp 开放防火墙端口3306 firewall-cmd --zone=public --add-port=3306/tcp --permanent 注意：开放端口后要重启防火墙生效 重启防火墙 systemctl restart firewalld 关闭防火墙端口 firewall-cmd --remove-port=3306/tcp --permanent 查看防火墙状态 systemctl status firewalld 关闭防火墙 systemctl stop firewalld 打开防火墙 systemctl start firewalld 开放一段端口 firewall-cmd --zone=public --add-port=40000-45000/tcp --permanent 查看开放的端口列表 firewall-cmd --zone=public --list-ports 查看被监听Listen的端口 netstat -lntp 检查端口被哪个进程占用 netstat -lnp|grep 3306 ","date":"2021-08-14","objectID":"/centos-8-%E5%BC%80%E5%85%B3%E7%AB%AF%E5%8F%A3/:0:0","tags":["Linux","CentOS","FireWall"],"title":"CentOS 8 开关端口","uri":"/centos-8-%E5%BC%80%E5%85%B3%E7%AB%AF%E5%8F%A3/"},{"categories":["Linux"],"content":"CentOS挂载NTFS分区：https://my.oschina.net/u/4364192/blog/3326016 ","date":"2021-08-14","objectID":"/centos%E6%8C%82%E8%BD%BDntfs%E5%88%86%E5%8C%BA/:0:0","tags":["linux","centos"],"title":"CentOS挂载NTFS分区","uri":"/centos%E6%8C%82%E8%BD%BDntfs%E5%88%86%E5%8C%BA/"},{"categories":["Linux"],"content":"先安装ntfsprogs 截止到2021年4月27日，最新版仍是2017.3.23。 # 下载此软件 wget http://tuxera.com/opensource/ntfs-3g_ntfsprogs-2017.3.23.tgz # 解压 tar -zxvf ntfs-3g_ntfsprogs-2017.3.23.tgz # 进入解压后的目录 cd ntfs-3g_ntfsprogs-2017.3.23/ # 建立一个目录ntfs3g用以安装当前软件 mkdir /usr/local/ntfs3g/ # 指定编译路径 ./configure --prefix=/usr/local/ntfs3g/ # 开始编译和安装 make\u0026\u0026make install ","date":"2021-08-14","objectID":"/centos%E6%8C%82%E8%BD%BDntfs%E5%88%86%E5%8C%BA/:1:0","tags":["linux","centos"],"title":"CentOS挂载NTFS分区","uri":"/centos%E6%8C%82%E8%BD%BDntfs%E5%88%86%E5%8C%BA/"},{"categories":["Linux"],"content":"挂载NTFS分区 挂载命令格式（较非NTFS分区的挂载，其中加入了ntfs-3g参数） mount -t ntfs-3g /dev/sdb1 /mnt/udisk ","date":"2021-08-14","objectID":"/centos%E6%8C%82%E8%BD%BDntfs%E5%88%86%E5%8C%BA/:2:0","tags":["linux","centos"],"title":"CentOS挂载NTFS分区","uri":"/centos%E6%8C%82%E8%BD%BDntfs%E5%88%86%E5%8C%BA/"},{"categories":["Linux"],"content":"实现开机自动挂载 要想实现自动开机挂载NTFS格式的USB硬盘，需要进行以下操作： # 首先备份fstab表 cp /etc/fstab /etc/fstabbakup # 然后打开vi编辑器 vi /etc/fstab # 在fstab表最后一行添加如下信息 /dev/sdb1 /mnt/udisk ntfs-3g defaults 0 0 ","date":"2021-08-14","objectID":"/centos%E6%8C%82%E8%BD%BDntfs%E5%88%86%E5%8C%BA/:3:0","tags":["linux","centos"],"title":"CentOS挂载NTFS分区","uri":"/centos%E6%8C%82%E8%BD%BDntfs%E5%88%86%E5%8C%BA/"},{"categories":["cnblog"],"content":"https://www.cnblogs.com/TangXiaoHuiHui https://www.cnblogs.com/BNTang/ Silence https://www.cnblogs.com/jajian/p/9763946.html ","date":"2021-08-14","objectID":"/cnblog%E6%BC%82%E4%BA%AE%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E6%A0%B7%E6%9D%BF/:0:0","tags":["cnblog"],"title":"cnblog漂亮主题博客样板","uri":"/cnblog%E6%BC%82%E4%BA%AE%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E6%A0%B7%E6%9D%BF/"},{"categories":["Docker"],"content":"filerun 官方docker： https://hub.docker.com/r/afian/filerun/ 1、预先搭建好mariadb容器 2、使用以下命令运行filerun容器 docker run -itd --name filerun \\ --restart=unless-stopped \\ --link=mariadb -e FR_DB_HOST=数据库地址 \\ -e FR_DB_PORT=数据库端口 \\ -e FR_DB_NAME=数据库名称（需要先自行建好，filerun初始化时不会建立） \\ -e FR_DB_USER=数据库用户名 \\ -e FR_DB_PASS=数据库密码 \\ -e APACHE_RUN_USER=www-data \\ -e APACHE_RUN_USER_ID=33 \\ -e APACHE_RUN_GROUP=www-data \\ -e APACHE_RUN_GROUP_ID=33 \\ -p 616:80 \\ -v /userdatas/Sandisk/filerun/html:/var/www/html \\ -v /userdatas/Sandisk/filerun/user-files:/user-files \\ afian/filerun filerun默认监听80端口， 默认使用以下两个作为数据持久化的路径： /filerun/html:/var/www/html /filerun/user-files:/user-files 初始化的用户名密码均为：superuser 深色主题： 来源：https://feedback.filerun.com/en/communities/1/topics/501-dark-version-theme 文中提到的theme_dark.css .frBtn:hover, .x-grid3-header { background-color: #303030; } .x-btn-pressed, .x-btn-click:hover, .x-btn-pressed:hover, .x-btn-icon:hover { background-color: #262626; } .x-window, .x-toolbar, .x-panel-header, .x-panel-body, .x-panel-footer, .x-grid3, .ext-el-mask, .x-combo-list-inner, .x-tab-panel-header, .x-tab-panel-footer, .x-form-text, textarea.x-form-field, .x-superboxselect-input-field, .x-menu, .x-layout-split, .headerTbar .x-btn-icon:hover, .targetSelector .backButton:hover, .targetSelector .closeButton:hover, .targetSelector .topToolbar, .targetSelector .x-window-header { background-color: #404040; } body, .headerTbar, .x-menu-item-active, .tmbItem.typeFolder, .tmbItem .tmbInner, .x-superboxselect-item, .x-tree-node-el:hover, .fr-btn-default, .x-grid3-row-over, .ext-el-mask-msg, #loadMsg div, .x-list-over { background-color: #262626; } .headerTbar .x-btn-icon.x-btn-pressed, .headerTbar .x-btn-icon.x-btn-click, .headerTbar .x-btn-icon.x-btn-menu-active { background-color: black; } .headerTbar .xtb-sep { border-color: white; opacity: 0.3; } .tmbItem.typeFolder, .tmbItem .tmbInner { box-shadow: none; } .fr-btn-new, .fr-btn-primary, .fr-btn-primary:hover, .x-date-inner .x-date-selected a, .x-combo-list .x-combo-selected, .x-list-selected, .comment.own .text, .bubbleCount div { background-color: #2d61b7; } .fr-btn-default, .fr-btn-default:hover, .x-color-palette a, .x-color-palette em, .x-color-palette a:hover, .x-color-palette a.x-color-palette-sel, .x-superboxselect-item { border-color: transparent; } .x-window, .x-menu { border: 1px solid #262626; } .x-tab-strip-bottom, .x-tab-strip-top, .x-menu-sep, .x-toolbar.FR-NavBar, .x-layout-split, .x-grid3-header, .x-grid3-row, .targetSelector .x-window-body { border-color: #262626; } .comment.own .text .inner:after, .comment.own .text .inner:before { border-left-color: #2d61b7; } .logo3d, .logo3d a, .fr-btn-new, .headerTbar .fa, .x-btn-icon:hover i, .x-btn-icon.x-btn-pressed i, .x-btn-icon.x-btn-click i, .x-combo-list .x-combo-selected, .targetSelector .x-list-selected dt, .targetSelector .x-list-selected .fa, .frBtn, a.x-menu-item, .x-menu-item-active .x-menu-item-the-arrow, .fr-btn-default:hover { color: white; } body, .lang-select, .x-tree-node a, .tmbItem .name, .fa, .x-form-text, textarea.x-form-field, .x-superboxselect-input-field, .fr-details-fields .field .name, .x-tool, .x-grid3-hd-row td, .FR-NavBar .frBtn span, .x-tab-strip span.x-tab-strip-text, .x-fieldset legend, .footerTextPanel .x-panel-body, .eventItem .txt .fn, .targetSelector dt { color: #DADCDC; } .x-tab-strip-active span.x-tab-strip-text { color: white; } .x-tree-node .x-tree-ec-icon, .x-tree-node-el .icons i, .fa-folder, .x-tree-node-icon { color: #807e7e; } .x-tree-selected .x-tree-node-icon, .x-tree-node-el.x-tree-selected .icons i, .x-tree-selected .x-tree-ec-icon, .tmbItemSel .icon i, .tmbItemSel.typeFolder .iconsHolder i { color: #DADCDC; } a, .fr-btn-link, .fr-details-fields .field.title .value a:hover, .fr-details-fields .field.title .editIcon:hover i, .x-superboxselect-btns li:hover, .x-superboxselect-locked .x-superboxselect-item:hover { color: #3FA9F2; } .tmbItemSel .tmbInner { background-color: transparent; } .tmbItem .selOverlay { b","date":"2021-08-14","objectID":"/docker-%E6%90%AD%E5%BB%BAfilerun/:0:0","tags":["linux","docker","filerun"],"title":"Docker 搭建Filerun","uri":"/docker-%E6%90%AD%E5%BB%BAfilerun/"},{"categories":["Docker"],"content":"进入正在运行的容器中 docker exec -it 1f6091e48979 /bin/sh ","date":"2021-08-14","objectID":"/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["docker"],"title":"Docker常用命令","uri":"/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Docker"],"content":"列出本地容器镜像 （包括运行中的容器使用的镜像和未运行的静态镜像文件） docker image ls ","date":"2021-08-14","objectID":"/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":["docker"],"title":"Docker常用命令","uri":"/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Docker"],"content":"查看容器的run参数 docker run --rm -v /var/run/docker.sock:/var/run/docker.sock assaflavie/runlike YOUR-CONTAINER-Name ","date":"2021-08-14","objectID":"/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:3:0","tags":["docker"],"title":"Docker常用命令","uri":"/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Docker"],"content":"重启整个docker服务（非重启容器） ，可解决容器运行久后，长期占用内存而不释放的问题。 systemctl restart docker ","date":"2021-08-14","objectID":"/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:4:0","tags":["docker"],"title":"Docker常用命令","uri":"/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Docker"],"content":"修改容器重启策略， portainer面板中可以修改 docker update --restart=on-failure:3 abebf7571666 hopeful_morse ","date":"2021-08-14","objectID":"/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:5:0","tags":["docker"],"title":"Docker常用命令","uri":"/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Docker"],"content":"更多请参考 http://honshen.xyz/2021/02/02/Docker/%E7%AC%AC2%E7%AB%A0-Docker%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86/ ","date":"2021-08-14","objectID":"/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:6:0","tags":["docker"],"title":"Docker常用命令","uri":"/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Docker"],"content":"宿主机环境装备 先在宿主机建立用户数据目录 mkdir /userdatas/mycode 给上面目录授权（否则将会出现docker挂载该目录时拒绝访问的错误） chmod 777 /userdatas/mycode ","date":"2021-08-14","objectID":"/docker%E6%90%AD%E5%BB%BAvscode-server/:0:1","tags":["docker","vscode"],"title":"Docker搭建VSCODE-Server","uri":"/docker%E6%90%AD%E5%BB%BAvscode-server/"},{"categories":["Docker"],"content":"启动vscode-server容器 docker run -it -d \\ --restart=always \\ --name code-server -p 6688:8080 \\ -v \"/userdatas/mycode:/home/coder\" \\ codercom/code-server:latest ","date":"2021-08-14","objectID":"/docker%E6%90%AD%E5%BB%BAvscode-server/:0:2","tags":["docker","vscode"],"title":"Docker搭建VSCODE-Server","uri":"/docker%E6%90%AD%E5%BB%BAvscode-server/"},{"categories":["Docker"],"content":"登录密码的修改 进入宿主机/userdatas/mycode/.config/code-server目录，其中config.yaml中password后面的值就是密码。 修改密码也是在此文件。 修改密码后，需要重启容器docker restart code-server才能生效。 访问xxx.xx:6688即可享用vscode WebIDE ","date":"2021-08-14","objectID":"/docker%E6%90%AD%E5%BB%BAvscode-server/:0:3","tags":["docker","vscode"],"title":"Docker搭建VSCODE-Server","uri":"/docker%E6%90%AD%E5%BB%BAvscode-server/"},{"categories":["Docker"],"content":"Python开发环境打磨 ","date":"2021-08-14","objectID":"/docker%E6%90%AD%E5%BB%BAvscode-server/:1:0","tags":["docker","vscode"],"title":"Docker搭建VSCODE-Server","uri":"/docker%E6%90%AD%E5%BB%BAvscode-server/"},{"categories":["Docker"],"content":"安装pip管理包 vscode服务端（即docker容器）是基于debian系统，未安装pip，需要进入容器中进行安装，进入容器的方法有两种。 一、WebIDE界面进入 登录WebIDE后，在WebIDE的终端中进行。 sudo apt update sudo apt install python3-pip 二、在宿主机中进入 宿主机运行以下命令进入容器 docker exec -it code-server /bin/bash 然后执行 一、WebIDE界面安装 步骤中的代码。 ","date":"2021-08-14","objectID":"/docker%E6%90%AD%E5%BB%BAvscode-server/:1:1","tags":["docker","vscode"],"title":"Docker搭建VSCODE-Server","uri":"/docker%E6%90%AD%E5%BB%BAvscode-server/"},{"categories":["Docker"],"content":"配置远程调试运行环境 在WebIDE左侧的插件商店中安装python插件 重启容器docker restart code-server 然后再次进入WebIDE,进入左侧的运行和调试，点击创建 launch.json,在编辑界面输入以下内容并保存： { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"Python: 当前文件\", \"type\": \"python\", \"request\": \"launch\", \"program\": \"${file}\", \"console\": \"internalConsole\" } ] } 然后就可以按Ctrl+F5愉快的执行。 ","date":"2021-08-14","objectID":"/docker%E6%90%AD%E5%BB%BAvscode-server/:1:2","tags":["docker","vscode"],"title":"Docker搭建VSCODE-Server","uri":"/docker%E6%90%AD%E5%BB%BAvscode-server/"},{"categories":["Docker"],"content":"设置WebIDE不显示配置文件 在WebIDE的设置当中搜索files.exclude,添加一条规则**/.* ### 安装等宽字体JetBrains Mono 下载地址：https://www.jetbrains.com/lp/mono/ 安装方法见：https://blog.csdn.net/jiaobuchong/article/details/108891406 ","date":"2021-08-14","objectID":"/docker%E6%90%AD%E5%BB%BAvscode-server/:1:3","tags":["docker","vscode"],"title":"Docker搭建VSCODE-Server","uri":"/docker%E6%90%AD%E5%BB%BAvscode-server/"},{"categories":["VPN"],"content":"cover: 所有shell 这种情况可以修改/etc/profile、/etc/environment、、HOME/.bashrc、HOME/.zshrc配置文件，一般来说，只需要修改.bashrc或.zshrc就可以使所有的shell走代理（除非特殊情况）。 # set export {http,https}_proxy=\"http://127.0.0.1:1280\" # unset unset {http,https}_proxy # test curl -v checkip.dyndns.org curl --head -v www.google.com 若希望立即见效，则?source 或HOME/.zshrc?或?sourceHOME/.bashrc。 因为linux终端不支持sock5，需要使用privoxy将HTTP流量转到本地sock5代理端口 1.安装Privoxy sudo apt-get install privoxy 2.配置Privoxy 修改/etc/privoxy/config文件（先清空原文件内容，再将以下内容粘贴进去） user-manual /usr/share/doc/privoxy/user-manual confdir /etc/privoxy logdir /var/log/privoxy actionsfile match-all.action # Actions that are applied to all sites and maybe overruled later on. actionsfile default.action # Main actions file actionsfile user.action # User customizations filterfile default.filter filterfile user.filter # User customizations logfile logfile toggle 1 enable-remote-toggle 0 enable-remote-http-toggle 0 enable-edit-actions 0 enforce-blocks 0 buffer-limit 4096 enable-proxy-authentication-forwarding 0 forwarded-connect-retries 0 accept-intercepted-requests 0 allow-cgi-request-crunching 0 split-large-forms 0 keep-alive-timeout 5 tolerate-pipelining 1 socket-timeout 300 #listen-address 127.0.0.1:8118 #listen-address [::1]:8118 listen-address 0.0.0.0:8118 forward-socks5 / 127.0.0.1:1280 . 3.重载配置文件 sudo service privoxy restart 二、设置全局代理 1.使用Privoxy将Socks5代理转换为http代理 详细步骤参考使用树莓派建立公共Http代理服务器 2.输入以下命令 export http_proxy=127.0.0.1:8118 export https_proxy=127.0.0.1:8118 export ftp_proxy=127.0.0.1:1280 http和https协议走Privoxy的http代理，ftp协议可以走socks代理 3.设置为默认代理 将上述命令添加到/etc/profile 文件末端，就可以使每次开启终端都自动设置代理。 vi /etc/profile 在后面添加如下内容： export http_proxy=127.0.0.1:8118 export https_proxy=127.0.0.1:8118 export ftp_proxy=127.0.0.1:1280 添加完成后保存退出，执行以下命令即可生效。 source /etc/profile 4.部分程序需要单独设置，如git ","date":"2021-08-14","objectID":"/linux%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/:1:0","tags":["linux","proxy","vpn"],"title":"Linux设置全局代理","uri":"/linux%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/"},{"categories":["Docker"],"content":"nextcloud安装 docker run -itd --name nextcloud -v /userdatas/Sandisk/nextcloud:/var/www/html --link mariadb -p 800:80 nextcloud https://zhuanlan.zhihu.com/p/353252517 ","date":"2021-08-14","objectID":"/nextcloud%E5%AE%89%E8%A3%85%E6%94%B9%E9%80%A0%E6%94%AF%E6%8C%81%E8%A7%86%E9%A2%91%E7%BC%A9%E7%95%A5%E5%9B%BE%E5%92%8C%E6%8C%82%E8%BD%BDsamba%E4%B8%8A%E4%BC%A0%E5%8A%A0%E9%80%9F/:1:0","tags":["docker","nextcloud"],"title":"NextCloud安装、改造，支持视频缩略图和、挂载Samba、上传加速","uri":"/nextcloud%E5%AE%89%E8%A3%85%E6%94%B9%E9%80%A0%E6%94%AF%E6%8C%81%E8%A7%86%E9%A2%91%E7%BC%A9%E7%95%A5%E5%9B%BE%E5%92%8C%E6%8C%82%E8%BD%BDsamba%E4%B8%8A%E4%BC%A0%E5%8A%A0%E9%80%9F/"},{"categories":["Docker"],"content":"解除文件上传时“块大小”的限制， 方法来源 docker exec --user www-data 容器ID php occ config:app:set files max_chunk_size --value 0 ","date":"2021-08-14","objectID":"/nextcloud%E5%AE%89%E8%A3%85%E6%94%B9%E9%80%A0%E6%94%AF%E6%8C%81%E8%A7%86%E9%A2%91%E7%BC%A9%E7%95%A5%E5%9B%BE%E5%92%8C%E6%8C%82%E8%BD%BDsamba%E4%B8%8A%E4%BC%A0%E5%8A%A0%E9%80%9F/:2:0","tags":["docker","nextcloud"],"title":"NextCloud安装、改造，支持视频缩略图和、挂载Samba、上传加速","uri":"/nextcloud%E5%AE%89%E8%A3%85%E6%94%B9%E9%80%A0%E6%94%AF%E6%8C%81%E8%A7%86%E9%A2%91%E7%BC%A9%E7%95%A5%E5%9B%BE%E5%92%8C%E6%8C%82%E8%BD%BDsamba%E4%B8%8A%E4%BC%A0%E5%8A%A0%E9%80%9F/"},{"categories":["Docker"],"content":"重建nextcloud索引 针对通过非nextcloud客户端（手机、PC、网页端）途径放入nextcloud目录的文件 docker exec -u www-data nextcloud php occ files:scan --all 使用该命令重建索引，如果报下面错误： Starting scan for user 1 out of 1 (xxx) Home storage for user xxx not writable Make sure you're running the scan command only as the user the web server runs as +---------+-------+--------------+ | Folders | Files | Elapsed time | +---------+-------+--------------+ | 0 | 0 | 00:00:00 | +---------+-------+--------------+ 那么，你需要将移入的文件（或目录）的所有这改为:33:tape。 chown -R 33:tape * ","date":"2021-08-14","objectID":"/nextcloud%E5%AE%89%E8%A3%85%E6%94%B9%E9%80%A0%E6%94%AF%E6%8C%81%E8%A7%86%E9%A2%91%E7%BC%A9%E7%95%A5%E5%9B%BE%E5%92%8C%E6%8C%82%E8%BD%BDsamba%E4%B8%8A%E4%BC%A0%E5%8A%A0%E9%80%9F/:3:0","tags":["docker","nextcloud"],"title":"NextCloud安装、改造，支持视频缩略图和、挂载Samba、上传加速","uri":"/nextcloud%E5%AE%89%E8%A3%85%E6%94%B9%E9%80%A0%E6%94%AF%E6%8C%81%E8%A7%86%E9%A2%91%E7%BC%A9%E7%95%A5%E5%9B%BE%E5%92%8C%E6%8C%82%E8%BD%BDsamba%E4%B8%8A%E4%BC%A0%E5%8A%A0%E9%80%9F/"},{"categories":["Docker"],"content":"生成缩略图 使用时会发现，Nextcloud 上传的视频不能生成缩略图。其实 Nextcloud 本身支持生成视频缩略图，需要安装 ffmpeg 并修改配置： docker exec -it nextcloud bash apt update apt install ffmpeg 停止NextCloud容器，再修改/var/www/html/config/config.php配置文件，添加： 'enable_previews' =\u003e true, 'enabledPreviewProviders' =\u003e array ( 0 =\u003e 'OC\\\\Preview\\\\Image', 1 =\u003e 'OC\\\\Preview\\\\Movie', 2 =\u003e 'OC\\\\Preview\\\\TXT', ), 再次启动容器即可生效。 ","date":"2021-08-14","objectID":"/nextcloud%E5%AE%89%E8%A3%85%E6%94%B9%E9%80%A0%E6%94%AF%E6%8C%81%E8%A7%86%E9%A2%91%E7%BC%A9%E7%95%A5%E5%9B%BE%E5%92%8C%E6%8C%82%E8%BD%BDsamba%E4%B8%8A%E4%BC%A0%E5%8A%A0%E9%80%9F/:4:0","tags":["docker","nextcloud"],"title":"NextCloud安装、改造，支持视频缩略图和、挂载Samba、上传加速","uri":"/nextcloud%E5%AE%89%E8%A3%85%E6%94%B9%E9%80%A0%E6%94%AF%E6%8C%81%E8%A7%86%E9%A2%91%E7%BC%A9%E7%95%A5%E5%9B%BE%E5%92%8C%E6%8C%82%E8%BD%BDsamba%E4%B8%8A%E4%BC%A0%E5%8A%A0%E9%80%9F/"},{"categories":["Docker"],"content":"支持挂载Samba Nextcloud 不仅是一个私有网盘，它还支持管理其他外部存储。可以把Samba共享，FTP，WebDAV等挂载到目录下统一访问管理。 Nextcloud默认是没有开启外部存储功能的，需在手动启用插件。 然后在设置里可以看到： Docker部署的 Nextcloud 默认是无法挂载 Samba 的，这里会显示： 需要在容器内安装smbclient： docker exec -it nextcloud bash apt install smbclient libsmbclient-dev pecl install smbclient docker-php-ext-enable smbclient 重启Docker服务即可。 ","date":"2021-08-14","objectID":"/nextcloud%E5%AE%89%E8%A3%85%E6%94%B9%E9%80%A0%E6%94%AF%E6%8C%81%E8%A7%86%E9%A2%91%E7%BC%A9%E7%95%A5%E5%9B%BE%E5%92%8C%E6%8C%82%E8%BD%BDsamba%E4%B8%8A%E4%BC%A0%E5%8A%A0%E9%80%9F/:5:0","tags":["docker","nextcloud"],"title":"NextCloud安装、改造，支持视频缩略图和、挂载Samba、上传加速","uri":"/nextcloud%E5%AE%89%E8%A3%85%E6%94%B9%E9%80%A0%E6%94%AF%E6%8C%81%E8%A7%86%E9%A2%91%E7%BC%A9%E7%95%A5%E5%9B%BE%E5%92%8C%E6%8C%82%E8%BD%BDsamba%E4%B8%8A%E4%BC%A0%E5%8A%A0%E9%80%9F/"},{"categories":["Docker"],"content":"自制Docker镜像 以上两处调整，在升级 Nextcloud 镜像后又需要重新执行一次。我们可以用原镜像为基础定制一个 Nextcloud 镜像。 新建文件 Dockerfile ，内容如下： FROM nextcloud:latest LABEL maintainer=\"engr-z\" RUN apt update \u0026\u0026 apt upgrade -y RUN apt install ffmpeg smbclient libsmbclient-dev -y RUN pecl install smbclient RUN docker-php-ext-enable smbclient 然后在该目录下执行： docker build -t my_nextcloud:latest ./ 执行完后会生成新的镜像： 我们只需要用该镜像运行即可。 Nextcloud 升级 1.执行 docker pull nextcloud:latest 下载最新镜像，再构建自己的镜像。 2.停止正在运行的Nextcloud并删除：docker stop nextcloud 3.重新运行镜像，参数和原来一样。 通过 Web 进入 Nextcloud 就会出现： 不推荐在该界面上点击更新。因为在更新内容多的情况，尤其是第三方应用更新，时间较长，浏览器可能会超时，推荐使用 occ 更新。 occ命令是Nextcloud的命令行界面，Nextcloud管理员可以通过occ执行许多常见的服务器操作。命令格式： sudo -u www-data php occ \u003cyour_command\u003e 在Docker中运行的Nextcloud执行occ会出现权限问题： 正确执行： docker exec --user www-data nextcloud php occ upgrade 写这篇文章时，Nextcloud 21刚刚发布，性能提升巨大。我自己也一直用 Nextcloud 管理家庭的照片和视频，非常Nice。 ","date":"2021-08-14","objectID":"/nextcloud%E5%AE%89%E8%A3%85%E6%94%B9%E9%80%A0%E6%94%AF%E6%8C%81%E8%A7%86%E9%A2%91%E7%BC%A9%E7%95%A5%E5%9B%BE%E5%92%8C%E6%8C%82%E8%BD%BDsamba%E4%B8%8A%E4%BC%A0%E5%8A%A0%E9%80%9F/:6:0","tags":["docker","nextcloud"],"title":"NextCloud安装、改造，支持视频缩略图和、挂载Samba、上传加速","uri":"/nextcloud%E5%AE%89%E8%A3%85%E6%94%B9%E9%80%A0%E6%94%AF%E6%8C%81%E8%A7%86%E9%A2%91%E7%BC%A9%E7%95%A5%E5%9B%BE%E5%92%8C%E6%8C%82%E8%BD%BDsamba%E4%B8%8A%E4%BC%A0%E5%8A%A0%E9%80%9F/"},{"categories":["Nginx"],"content":"一、Nginx负载均衡 ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:1:0","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"1、示意图 ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:1:1","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"2、好处 均摊请求，让服务端整体吞吐率提高，满足不断增长的业务需求。 相比于单点服务，当其中一台服务器挂掉后，还可以继续让剩下的服务器继续服务，提高了容灾性。 ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:1:2","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"二、负载均衡的分类 ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:2:0","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"1、GSLB（全局负载均衡） 一般是以国家或省为单位进行全局负载的。 示意图如下： ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:2:1","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"2、SLB 示意图： ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:2:2","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"三、基于LVS的中间件架构 LVS（Linux Virtual Server ）Linux 虚拟服务器 ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:3:0","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"1、四层负载均衡 即在OSI七层模型中的传输层。因为第四层支持TCP/IP协议。四层负载均衡只需要对客户端的请求进行TCP/IP协议的包转发就能实现负载均衡。 优势 非常快，只需要最底层进行应用处理，不需要进行一些复杂的逻辑，值需要负责包的转发即可。 示意图 ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:3:1","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"2、七层负载均衡 因为是在应用层，因此可以完成很多应用方面的协议请求，比如HTTP协议的负载均衡可以实现HTTP信息的改写，头信息的改写，安全应用规则的控制，转发，rewrite等等方面的规则控制。因此在七层负载均衡里面可以做的事情就更多一些，Nginx就是一个典型的七层负载均衡的SLB。 SLB（Server Load Balancing）服务器负载均衡。 示意图 ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:3:2","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"Nginx负载均衡实现原理 通过 proxy_pass 转发到后端的服务器上，只是不是转发到一台，而是一组虚拟的服务池（即 upstream server）。在upstream 组里面实现了对于多台服务器请求的不断轮询。 当用户的请求过来后，就会通过 upstream_module 这个模块将用户的请求分发到不同的服务上，从而实现负载均衡。 故 proxy_pass 和 upstream 是两个核心的配置。 ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:3:3","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"示意图 ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:3:4","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"配置语法 ngx_http_upstream_module官方文档 ： http://nginx.org/en/docs/http/ngx_http_upstream_module.html Syntax: upstream name { ... } Default: — Context: http ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:3:5","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"示例： ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:3:6","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"a、用一台服务器来实现负载均衡，配置如下： upstream chrdai { server 192.168.0.133:8001; server 192.168.0.133:8002; server 192.168.0.133:8003; } server { listen 80; server_name localhost; #charset koi8-r; access_log /var/log/nginx/proxy_cache_access.log main; location / { proxy_pass http://chrdai; include proxy_params; } } ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:3:7","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"b、 另外三台真实服务器的配置如下： 我这里是通过同一台服务器的不同端口模拟的。 第一台（/etc/nginx/conf.d/realserver1.conf）： 第二台（/etc/nginx/conf.d/realserver2.conf）： 第三台（/etc/nginx/conf.d/realserver3.conf）： ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:3:8","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"c、分别在三台真实服务器（当然我这里是在一台服务器中用三个端口模拟的）的项目目录下建立index.html文件。 第一台（/opt/app/code1）： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eupstream\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003eTest upstream1\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 第二台（/opt/app/code2）： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eupstream\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003eTest upstream2\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 第三台（/opt/app/code3）： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eupstream\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003eTest upstream3\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:3:9","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"c、刷新页面，发现页面可以在三个站点间轮询显示。‘ 说明我们的负载均衡配置成功。 注意：upstream只能配置在 http 这一层，即 server 层的外面。 下面我们来模拟其中一台服务器挂掉后，负载均衡是如何工作的。 如果是真实服务器，可以将nginx进程kill掉，但是由于我这里是在同一台服务器下面的三个端口来模拟的，所以不能直接kill掉Nginx进程。 我这里通过在 iptables 中添加一条规则来将所有来自 8002 端口的请求都 drop 掉，即不在对外提供 8002 端口的服务。 iptables -I INPUT -p tcp --dport 8002 -j DROP 此时我们在来访问页面，发现只会显示 upstream1 和 upstream3，upstream2已经被略过了。 说明当我们的负载均衡发现如果有一台服务器挂掉后，会自动略过这台服务器。打他提高了容灾性。 ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:3:10","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":" 四、负载均衡调度中的状态 状态 说明 down 当前的server暂时不参与负载均衡 backup 预留的备份服务器 max_fails 允许请求失败的次数 fail_timeout 经过max_fails失败后，服务暂停的时间（默认是10秒） max_conns 限制最大的接收连接数 max_conns的应用场景是，当我们把两个不同配置的服务器加在了同一个upstream下时，比如一个是四核，一个是8核的服务器，总不能让两台服务器承受相同的请求连接数吧，默认的轮询策略会均匀分配，这时我们就可以通过这个参数来限制后端服务最大的请求数。 ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:4:0","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"示例： upstream chrdai { //8001不启用 server 192.168.0.133:8001 down; //8002设为备份机 server 192.168.0.133:8002 backup; server 192.168.0.133:8003 max_fails=1 fail_timeout=10s; } server { listen 80; server_name localhost; #charset koi8-r; access_log /var/log/nginx/proxy_cache_access.log main; location / { proxy_pass http://chrdai; include proxy_params; } } 此时我们在访问，发现只有8003 在提供服务。 下面我们用iptables规则来限制来自8003的请求，看8002能否从备份状态恢复为提供服务状态。 iptables -I INPUT -p tcp --dport 8003 -j DROP 服务端经过一段时间的尝试，发现8003挂了，果然将8002转正了。 我们再次刷新页面，在8003没有恢复之前，都是访问的8002。 下面我们来将8003的服务恢复过来。 iptables -F 再次刷新页面，发现又是由8003来提供服务了，8002继续轮为备胎。 ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:4:1","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"结论： 当我们负载均衡中其中一台服务器挂掉后，会略过该服务器，剩下的服务器继续提供服务。 当所有的主服务器都挂掉后，备用服务器会转正。 当主服务器恢复后，继续由主服务器提供服务，备用服务器继续轮为备胎。 ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:4:2","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"五、Nginx的调度算法 ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:5:0","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"调度算法 调度算法名称 说明 轮询 按时间顺序逐一分配到不同的后端服务器 加权轮询 weight值越大，分配到的访问几率越高 ip_hash 每个请求按访问IP的的hash结果分配，这样来自同一个IP的固定访问一个后端服务器 url_hash 按照访问的url的hash结果来分配请求，使每个url定向到同一个后端服务器 least_conn 最少链接数，哪个机器连接数少，就分给哪个机器 hash关键数值 hash自定义的key ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:6:0","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"1、加权轮询示例： upstream chrdai { server 192.168.0.133:8001; server 192.168.0.133:8002 weight=5; server 192.168.0.133:8003; } //理论上来讲，如果请求7次，应该有 5 次会请求 8002 所对应的这台服务器 ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:6:1","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"2、ip_has策略示例： upstream chrdai { ip_hash; server 192.168.0.133:8001; server 192.168.0.133:8002; server 192.168.0.133:8003; } 服务器会根据 REMOTE_ADDR 做hash，同一个ip的请求，不管请求多少次，都会请求相同的一台服务器。 它的缺点是，如果中间有一层代理，那么取到的就不是客户端真实的ip，这样就无法基于用户真实的ip来做轮询了。而会跟代理服务器的ip来固定走一台服务器。 如果按照ip来分配，往往取不到用户端真实的ip。还有一个问题就是当服务端使用了缓存，假如一个用户先访问了服务器1，服务器1缓存了一部分资源，下一次访问的时候被轮询到了服务器2，那么上一次的缓存就无效了，Nginx又增加了更加友好的hash策略。 ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:6:2","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"3、hash关键数值轮询策略 ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:6:3","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"配置语法： //version\u003e1.7.2Syntax：hash key [consistent]; Default：-; Context：upstream; ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:6:4","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"4、url_hash 示例： upstream chrdai { hash $request_uri; server 192.168.0.133:8001; server 192.168.0.133:8002; server 192.168.0.133:8003; } 在 /opt/app/cod1 目录下新建三个文件。 url1.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eupstream\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003eserver1 url1\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e url2.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eupstream\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003eserver1 url2\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e url3.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eupstream\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003eserver1 url3\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e /opt/app/code2 和 /opt/app/code3 目录下也创建三个 urlx.html，页面内容和上面同理，修改一下 server的值和url的值即可。 此时由于我们的hash策略是根据 reques_uri 来的，所以会有如下结果。 a、当我们访问 http://192.168.0.133/url1.html 时，由于一开始就进入了 server1 这台服务器，不管怎么刷新，以后也永远进入server1这台服务器，因为它是根据 request_uri来做的hash。 b、当我们访问 http://192.168.0.133/url2.html 时，由于一开始就进入了 server3 这台服务器，不管怎么刷新，以后也永远进入server3这台服务器。 c、当我们访问 http://192.168.0.133/url3.html 时，由于一开始就进入了 server2 这台服务器，不管怎么刷新，以后也永远进入server3这台服务器。 ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:6:5","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Nginx"],"content":"总结： 加权轮询和轮询都是基于请求来进行分配的。 ip_hash策略，当中间有代理服务或者有设置缓存都有一定的局限性。 通常使用自定义的 url_hash策略来控制轮询。 当加权轮询策略和ip_hash 或者 url_hash 策略混用的时候，因为weight控制的是轮询策略下的权重，ip_hash是根据请求来源的ip加入轮询的算法。所以用了ip_hash或者url_hash的策略，就不需要添加weight的参数了。 本文为袋鼠学习中的总结，如有转载请注明出处：https://www.cnblogs.com/chrdai/protected/p/11397397.html ","date":"2021-08-14","objectID":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/:7:0","tags":["linux","nginx"],"title":"Nginx负载均衡","uri":"/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"},{"categories":["Linux"],"content":"Linux系统shell脚本实现： https://www.cnblogs.com/zhenbianshu/p/5867440.html ","date":"2021-08-14","objectID":"/ssh%E8%87%AA%E5%8A%A8%E7%99%BB%E9%99%86%E7%9A%84%E5%AE%9E%E7%8E%B0/:1:0","tags":["ssh"],"title":"ssh自动登陆的实现","uri":"/ssh%E8%87%AA%E5%8A%A8%E7%99%BB%E9%99%86%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Linux"],"content":"需要先安装expect https://blog.csdn.net/wangtaoking1/article/details/78268574 ","date":"2021-08-14","objectID":"/ssh%E8%87%AA%E5%8A%A8%E7%99%BB%E9%99%86%E7%9A%84%E5%AE%9E%E7%8E%B0/:1:1","tags":["ssh"],"title":"ssh自动登陆的实现","uri":"/ssh%E8%87%AA%E5%8A%A8%E7%99%BB%E9%99%86%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Linux"],"content":"Python脚本实现： https://mp.weixin.qq.com/s/vwmAa3kDc1zYdyTE18aA5w ","date":"2021-08-14","objectID":"/ssh%E8%87%AA%E5%8A%A8%E7%99%BB%E9%99%86%E7%9A%84%E5%AE%9E%E7%8E%B0/:2:0","tags":["ssh"],"title":"ssh自动登陆的实现","uri":"/ssh%E8%87%AA%E5%8A%A8%E7%99%BB%E9%99%86%E7%9A%84%E5%AE%9E%E7%8E%B0/"},{"categories":["Linux"],"content":"来源：https://github.com/FunctionClub/Fail2ban ","date":"2021-08-14","objectID":"/ssh%E9%98%B2%E7%88%86%E7%A0%B4/:0:0","tags":["ssh"],"title":"ssh防爆破","uri":"/ssh%E9%98%B2%E7%88%86%E7%A0%B4/"},{"categories":["Linux"],"content":"原理 Fail2ban会通过检查日志来匹配错误信息，从而使用iptables来防止暴力破解。理论上只要是能够在服务器本地输出错误日志和访问日志的程序都可以使用Fail2ban来保驾护航。 ","date":"2021-08-14","objectID":"/ssh%E9%98%B2%E7%88%86%E7%A0%B4/:1:0","tags":["ssh"],"title":"ssh防爆破","uri":"/ssh%E9%98%B2%E7%88%86%E7%A0%B4/"},{"categories":["Linux"],"content":"脚本介绍 一键安装部署Fail2ban，自动配置防SSH爆破。可自定义ip封禁时间，最高重试次数。 ","date":"2021-08-14","objectID":"/ssh%E9%98%B2%E7%88%86%E7%A0%B4/:2:0","tags":["ssh"],"title":"ssh防爆破","uri":"/ssh%E9%98%B2%E7%88%86%E7%A0%B4/"},{"categories":["Linux"],"content":"安装 wget https://raw.githubusercontent.com/FunctionClub/Fail2ban/master/fail2ban.sh \u0026\u0026 bash fail2ban.sh 2\u003e\u00261 | tee fail2ban.log ","date":"2021-08-14","objectID":"/ssh%E9%98%B2%E7%88%86%E7%A0%B4/:3:0","tags":["ssh"],"title":"ssh防爆破","uri":"/ssh%E9%98%B2%E7%88%86%E7%A0%B4/"},{"categories":["Linux"],"content":"卸载 wget https://raw.githubusercontent.com/FunctionClub/Fail2ban/master/uninstall.sh \u0026\u0026 bash uninstall.sh ","date":"2021-08-14","objectID":"/ssh%E9%98%B2%E7%88%86%E7%A0%B4/:4:0","tags":["ssh"],"title":"ssh防爆破","uri":"/ssh%E9%98%B2%E7%88%86%E7%A0%B4/"},{"categories":["Linux"],"content":"脚本运行截图 ","date":"2021-08-14","objectID":"/ssh%E9%98%B2%E7%88%86%E7%A0%B4/:5:0","tags":["ssh"],"title":"ssh防爆破","uri":"/ssh%E9%98%B2%E7%88%86%E7%A0%B4/"},{"categories":["typecho"],"content":"https://savokiss.com/ https://www.zmki.cn/5366.html?#webstackxz webstackmod作者 http://viggoz.com/ webstack作者 ","date":"2021-08-14","objectID":"/typecho%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86/:0:0","tags":["typecho"],"title":"typecho博客收集","uri":"/typecho%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86/"},{"categories":["typecho"],"content":"typecho框架博客 https://www.qian.blue/archives/SanQianZhiTu-random_img.html 上面博客使用的主题（Typecho-Cuteen–58元）来源： https://blog.zwying.com/archives/39.html 漂亮主題 https://couqiao.net/ handsome主题元88元 https://www.ihewro.com/archives/489/ handsome主題老版本地址： https://github.com/hsce/typecho-theme-handsome Typecho 开发者：关于最近的 Typecho 安全漏洞 https://paper.seebug.org/428/ Jekyll 框架 深綠色主題，養眼 https://blog.kelu.org/tech/2019/01/22/build-your-own-webdav.html ","date":"2021-08-14","objectID":"/typecho%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86/:1:0","tags":["typecho"],"title":"typecho博客收集","uri":"/typecho%E5%8D%9A%E5%AE%A2%E6%94%B6%E9%9B%86/"},{"categories":["Docker"],"content":"转载自：https://p3terx.com/archives/docker-watchtower.html ","date":"2021-08-14","objectID":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/:0:0","tags":["docker"],"title":"Watchtower - 自动更新 Docker 镜像与容器","uri":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/"},{"categories":["Docker"],"content":"前言 Docker 容器的部署有一种在手机上装 App 的感觉，但 Docker 容器并不会像手机 App 那样会自动更新，而如果我们需要更新容器一般需要以下四个步骤： 停止容器：docker stop \u003cCONTAINER\u003e 删除容器：docker rm \u003cCONTAINER\u003e 更新镜像：docker pull \u003cIMAGE\u003e 启动容器：docker run \u003cARG\u003e ... \u003cIMAGE\u003e 停止容器这个步骤可以在删除容器时使用 -f 参数来代替，即使这样还是需要三个步骤。如果部署了大量的容器需要更新使用这种传统的方式工作量是巨大的。 Watchtower 是一个可以实现自动化更新 Docker 基础镜像与容器的实用工具。它监视正在运行的容器以及相关的镜像，当检测到 reg-istry 中的镜像与本地的镜像有差异时，它会拉取最新镜像并使用最初部署时相同的参数重新启动相应的容器，一切好像什么都没发生过，就像更新手机上的 App 一样。 ","date":"2021-08-14","objectID":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/:1:0","tags":["docker"],"title":"Watchtower - 自动更新 Docker 镜像与容器","uri":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/"},{"categories":["Docker"],"content":"快速开始 Watch-tower 本身被打包为 Docker 镜像，因此可以像运行任何其他容器一样运行它： docker run -d \\ --name watchtower \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower 然后所有容器都会自动更新，也包括 Watch-tower 本身。 ","date":"2021-08-14","objectID":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/:2:0","tags":["docker"],"title":"Watchtower - 自动更新 Docker 镜像与容器","uri":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/"},{"categories":["Docker"],"content":"选项参数 点击查看 ","date":"2021-08-14","objectID":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/:3:0","tags":["docker"],"title":"Watchtower - 自动更新 Docker 镜像与容器","uri":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/"},{"categories":["Docker"],"content":"自动清除旧镜像 官方给出的默认启动命令在长期使用后会堆积非常多的标签为 none 的旧镜像，如果放任不管会占用大量的磁盘空间。要避免这种情况可以加入 --cleanup 选项，这样每次更新都会把旧的镜像清理掉。 docker run -d \\ --name watchtower \\ --restart unless-stopped \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower \\ --cleanup --cleanup 选项可以简写为 -c： docker run -d \\ --name watchtower \\ --restart unless-stopped \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower -c ","date":"2021-08-14","objectID":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/:4:0","tags":["docker"],"title":"Watchtower - 自动更新 Docker 镜像与容器","uri":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/"},{"categories":["Docker"],"content":"选择性自动更新 某些容器可能需要稳定的运行，经常更新或重启可能会造成一些问题，这时我们可以使用一些选项参数来选择与控制容器的更新。 ","date":"2021-08-14","objectID":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/:5:0","tags":["docker"],"title":"Watchtower - 自动更新 Docker 镜像与容器","uri":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/"},{"categories":["Docker"],"content":"容器更新列表 假设我们只想更新 nginx、redis 这两个容器，我们可以把容器名称追加到启动命令的最后面，就像下面这个例子： docker run -d \\ --name watchtower \\ --restart unless-stopped \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower -c \\ nginx redis 博主觉得把需要更新的容器名称写在启动命令中不利于管理，于是想了个更好的方法，建立一个更新列表文件。 $ cat ~/.watchtower.list aria2-pro unlockmusic mtg ... 通过变量的方式去调用这个列表： docker run -d \\ --name watchtower \\ --restart unless-stopped \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower -c \\ $(cat ~/.watchtower.list) 这样只需要调整列表后删除 Watch-tower 容器并重新执行上面的命令重新启动 Watch-tower 即可。 ","date":"2021-08-14","objectID":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/:5:1","tags":["docker"],"title":"Watchtower - 自动更新 Docker 镜像与容器","uri":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/"},{"categories":["Docker"],"content":"设置单个容器自动更新特征 给容器中添加 com.centurylinklabs.watchtower.enable 这个 LA-BEL 并设置它的值为 false，或者在启动命令中加入 --label com.centurylinklabs.watchtower.enable=false 参数可以排除相应的容器。下面这个例子是博主的 openwrt-mini 镜像的容器启动命令，Watch-tower 将永远忽略它的更新，即使它包含在自动更新列表中。 docker run -d \\ --name openwrt-mini \\ --restart always \\ --network openwrt \\ --privileged \\ --label com.centurylinklabs.watchtower.enable=false \\ p3terx/openwrt-mini \\ /sbin/init 当容器启动命令中加入 --label com.centurylinklabs.watchtower.enable=true 参数，并且给 Watch-tower 加上 --label-enable 选项时，Watch-tower 将只更新这些包含此参数的容器。 docker run -d \\ --name watchtower \\ --restart unless-stopped \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower -c \\ --label-enable --label-enable 可以简写为 -e： docker run -d \\ --name watchtower \\ --restart unless-stopped \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower -ce 因为需要在容器启动时进行设置，且设置后就无法直接更改，只能重建容器，所以这种方式的灵活性不如更新列表法。尤其是在设置 com.centurylinklabs.watchtower.enable=false 参数后容器将永远被 Watch-tower 忽略，也包括后面将要提到的手动更新方式，所以一般不推荐这样做，除非你愿意手动重建的原生方式更新。 ","date":"2021-08-14","objectID":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/:5:2","tags":["docker"],"title":"Watchtower - 自动更新 Docker 镜像与容器","uri":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/"},{"categories":["Docker"],"content":"设置自动更新检查频率 默认情况下 Watch-tower 每 5 分钟会轮询一次，如果你觉得这个频率太高了可以使用如下选项来控制更新检查的频率，但二者只能选择其一。 --interval, -i - 设置更新检测时间间隔，单位为秒。比如每隔 1 个小时检查一次更新： docker run -d \\ --name watchtower \\ --restart unless-stopped \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower -c \\ --interval 3600 --schedule, -s - 设置定时检测更新时间。格式为 6 字段 Cron 表达式，而非传统的 5 字段，即第一位是秒。比如每天凌晨 2 点检查一次更新： docker run -d \\ --name watchtower \\ --restart unless-stopped \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower -c \\ --schedule \"0 0 2 * * *\" ","date":"2021-08-14","objectID":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/:6:0","tags":["docker"],"title":"Watchtower - 自动更新 Docker 镜像与容器","uri":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/"},{"categories":["Docker"],"content":"手动更新 前面的使用方式都是让 Watch-tower 以 detached（后台）模式在运行并自动更新容器，而 Watch-tower 也支持以 foreground（前台）模式来使用，即运行一次退出并删掉容器，来实现手动更新容器。这对于偶尔更新一次那些不在自动更新列表中的容器非常有用。 对于 foreground 模式，需要加上 --run-once 这个专用的选项。下面的例子 Docker 会运行一次 Watch-tower 并检查 aria2-pro 容器的基础镜像更新，最后删掉本次运行创建的 Watch-tower 容器。 docker run --rm \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower -c \\ --run-once \\ aria2-pro --run-once 可以简写为 -R： docker run --rm \\ -v /var/run/docker.sock:/var/run/docker.sock \\ containrrr/watchtower -cR \\ aria2-pro 需要注意的是当这个容器设置过 com.centurylinklabs.watchtower.enable=false 参数时不会更新。 ","date":"2021-08-14","objectID":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/:7:0","tags":["docker"],"title":"Watchtower - 自动更新 Docker 镜像与容器","uri":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/"},{"categories":["Docker"],"content":"尾巴 以上是博主在使用 Watch-tower 中总结的一些使用方式和方法，当然它还有一些其它的功能与使用方式，比如电子邮件通知、监视私人注册表的镜像、更新远程主机上的容器等，这些对于一般用户来说可能很少会用到，所以这里就不赘述了，感兴趣的小伙伴可以去研究 Watchtower 官方文档。 ","date":"2021-08-14","objectID":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/:8:0","tags":["docker"],"title":"Watchtower - 自动更新 Docker 镜像与容器","uri":"/watchtower-%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0-docker-%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8/"},{"categories":["Linux"],"content":"来源：https://github.com/perfectstorm88/bblog/issues/5#关于未来的趋势看法 ","date":"2021-08-14","objectID":"/%E5%85%B3%E4%BA%8E%E5%A0%A1%E5%9E%92%E6%9C%BA/:0:0","tags":["linux","堡垒机"],"title":"关于堡垒机","uri":"/%E5%85%B3%E4%BA%8E%E5%A0%A1%E5%9E%92%E6%9C%BA/"},{"categories":["Linux"],"content":"索引 前言 开发环境 堡垒机 VPN 云堡垒机 关于未来的趋势看法： 参考 ","date":"2021-08-14","objectID":"/%E5%85%B3%E4%BA%8E%E5%A0%A1%E5%9E%92%E6%9C%BA/:1:0","tags":["linux","堡垒机"],"title":"关于堡垒机","uri":"/%E5%85%B3%E4%BA%8E%E5%A0%A1%E5%9E%92%E6%9C%BA/"},{"categories":["Linux"],"content":"前言 医院、政府类项目中对安全的合规要求比较高，会把网络整得很复杂，由此给项目实施相关人员带来诸多不便，令很多人头大得很。俗话说“难者不会、会者不难”，从原理上搞清楚，解决问题就只剩操作步骤了。 本文的尝试是用通俗的语言还原安全相关的网络原理，非专业网络工程师也能看懂，比如产品经理、前后端的开发人员、测试人员、项目经理等。 ","date":"2021-08-14","objectID":"/%E5%85%B3%E4%BA%8E%E5%A0%A1%E5%9E%92%E6%9C%BA/:2:0","tags":["linux","堡垒机"],"title":"关于堡垒机","uri":"/%E5%85%B3%E4%BA%8E%E5%A0%A1%E5%9E%92%E6%9C%BA/"},{"categories":["Linux"],"content":"开发环境 先从我们最熟悉的开发环境说起，如下图所示： {% asset_img 4124540583.png [dddd] %} 在我们自己的开发环境，为了效率考虑，作为技术的开发运维都是直接访问数据库、后端服务器、web服务器，作为访问用户的产品经理、测试人员，也是直接访问web服务器提供的服务。 ","date":"2021-08-14","objectID":"/%E5%85%B3%E4%BA%8E%E5%A0%A1%E5%9E%92%E6%9C%BA/:3:0","tags":["linux","堡垒机"],"title":"关于堡垒机","uri":"/%E5%85%B3%E4%BA%8E%E5%A0%A1%E5%9E%92%E6%9C%BA/"},{"categories":["Linux"],"content":"堡垒机 对于一个要部署上线的系统，安全就变得很重要了，作为技术的开发运维不能再随意访问、操作数据库和服务器了。因此就引入了一个叫做堡垒机的东东，对数据库和服务器进行保护，如下图所示： {% asset_img 2053743094.png %} 堡垒机只能让你访问被授权的主机事先防范“事先防范、访问过程对你的行为进行监控事中控制事中控制、出了安全事故可以回看操作录像(事后溯源）。 堡垒机的原理也不复杂，网上有开源代码,见jumpserver，感兴趣的也可以自己部署一套玩玩。有的堡垒机需要专门的客户端软件，有的可以直接通过浏览器访问，相信未来以浏览器作为访问方式的会越来越多。 使用堡垒机访问数据库和服务器有多种协议，比如ssh协议用来访问linux系统、DRP协议用来访问windows桌面。 别看现在堡垒机很常见，但是出现的历史却很短，也才十几年的时间；技术人员比较讨论堡垒机，因为每次通过堡垒机操作太麻烦，但是企业大客户和政府事业单位的领导非常喜欢这玩意，所以要适应这个东西，以后会更常见的。 ","date":"2021-08-14","objectID":"/%E5%85%B3%E4%BA%8E%E5%A0%A1%E5%9E%92%E6%9C%BA/:4:0","tags":["linux","堡垒机"],"title":"关于堡垒机","uri":"/%E5%85%B3%E4%BA%8E%E5%A0%A1%E5%9E%92%E6%9C%BA/"},{"categories":["Linux"],"content":"VPN 对于医院、政府类项目，生产环境都在封闭内网，之前都需要去企业现场才能干活，有个VPN之后，在家里就可以干活了。 尤其现在VPN客户端都挺好用，可以同时访问互联网和企业内网，只要网络够快、VPN服务器够好，在家里跟去企业现场没太大区别，所以技术人员还是很喜欢用VPN的。 现在很多情况下，运维/开发都不需要去客户驻场了，所以经常的应用场景如下所示：需要先连上VPN，再登陆堡垒机，然后才能通过堡垒机上的软件进行干活。 {% asset_img 2594537473.png %} 原理如上图所示，但实际上我们在干活时还会碰到很多意外： 1、比如有的企业会对VPN进行限制，把VPN的访问权限限制在一个很小的区域，所以在内网能打开的网页通过VPN就不能打开了。 2、在这种情况下，也是有方法可以解决的，就是让网管给你开放一台经过授权的windows主机，然后通过这条线去打开网页：操作者-》VPN-》堡垒机-》windows主机-》打开网页。 ","date":"2021-08-14","objectID":"/%E5%85%B3%E4%BA%8E%E5%A0%A1%E5%9E%92%E6%9C%BA/:5:0","tags":["linux","堡垒机"],"title":"关于堡垒机","uri":"/%E5%85%B3%E4%BA%8E%E5%A0%A1%E5%9E%92%E6%9C%BA/"},{"categories":["Linux"],"content":"云堡垒机 最近随着云计算越来越普及，医院、政府类项目很多都在上云，云堡垒机也应运而生，其使用场景如下图所示，不必在通过VPN，可以直接登录堡垒机使用。 {% asset_img 189612217.png %} ","date":"2021-08-14","objectID":"/%E5%85%B3%E4%BA%8E%E5%A0%A1%E5%9E%92%E6%9C%BA/:6:0","tags":["linux","堡垒机"],"title":"关于堡垒机","uri":"/%E5%85%B3%E4%BA%8E%E5%A0%A1%E5%9E%92%E6%9C%BA/"},{"categories":["Linux"],"content":"关于未来的趋势看法： 堡垒机会越来越多，甚至公司内部、团队内部的一些重要数据资产，也有采用堡垒机的方式进行保护 现在堡垒机的运维客户端很多还需要安装软件，以后会越来越多地采用浏览器方式直接访问，而且云堡垒机的场景会越来越多 VPN技术单一，也比较成熟了，现在还有不少乱七八糟的客户端，会越来越少的 ","date":"2021-08-14","objectID":"/%E5%85%B3%E4%BA%8E%E5%A0%A1%E5%9E%92%E6%9C%BA/:7:0","tags":["linux","堡垒机"],"title":"关于堡垒机","uri":"/%E5%85%B3%E4%BA%8E%E5%A0%A1%E5%9E%92%E6%9C%BA/"},{"categories":["Linux"],"content":"参考 堡垒机哲学史 堡垒机是干什么的？ 云堡垒机应用场景 堡垒机运维审计系统运维审计系统的基本原理与部署方式 VPN和防火墙有什么关系？ 什么是VPN以及VPN的工作原理是什么？新手指南（2020年） VPN保护企业内网安全？VPN了解一下 商业VPN和个人VPN有什么区别？ : ","date":"2021-08-14","objectID":"/%E5%85%B3%E4%BA%8E%E5%A0%A1%E5%9E%92%E6%9C%BA/:8:0","tags":["linux","堡垒机"],"title":"关于堡垒机","uri":"/%E5%85%B3%E4%BA%8E%E5%A0%A1%E5%9E%92%E6%9C%BA/"},{"categories":["Docker"],"content":"docker安装 docker run -itd \\ --name=filebrowser \\ # 镜像别名 -v /:/srv \\ # filebrowser 管理的路径 -v /etc/filebrowser/config.json:/etc/config.json \\ # filebrowser 配置 -v /etc/filebrowser/database.db:/etc/database.db \\ # filebrowser 数据库 -p 80:80 \\ # filebrowser 映射端口 filebrowser/filebrowser 一键安装脚本,下面的可以不用看了 bash \u003c(curl -s -L https://233blog.com/filebrowser.sh) 另一个详细教程文章 https://233blog.com/post/26/ ","date":"2021-08-14","objectID":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/:0:0","tags":["docker","linux"],"title":"安装配置Filebrowser","uri":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/"},{"categories":["Docker"],"content":"第一步 curl -fsSL https://raw.githubusercontent.com/filebrowser/get/master/get.sh | bash ","date":"2021-08-14","objectID":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/:1:0","tags":["docker","linux"],"title":"安装配置Filebrowser","uri":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/"},{"categories":["Docker"],"content":"第二步 生成初始化配置文件 sudo filebrowser -d /etc/filebrowser/filebrowser.db config init ","date":"2021-08-14","objectID":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/:2:0","tags":["docker","linux"],"title":"安装配置Filebrowser","uri":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/"},{"categories":["Docker"],"content":"第三步 修改配置文件（通过命令） # 设置监听地址 sudo filebrowser -d /etc/filebrowser/filebrowser.db config set --address 0.0.0.0 # 设置监听端口 sudo filebrowser -d /etc/filebrowser/filebrowser.db config set --port 8088 # 设置语言环境 sudo filebrowser -d /etc/filebrowser/filebrowser.db config set --locale zh-cn # 设置日志位置 sudo filebrowser -d /etc/filebrowser/filebrowser.db config set --log /var/log/filebrowser.log # 添加一个用户,其中的root和password分别是用户名和密码，根据自己的需求更改。 sudo filebrowser -d /etc/filebrowser/filebrowser.db users add root password --perm.admin ","date":"2021-08-14","objectID":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/:3:0","tags":["docker","linux"],"title":"安装配置Filebrowser","uri":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/"},{"categories":["Docker"],"content":"第四步 打开8088端口 firewall-cmd --zone=public --add-port=8088/tcp --permanent # 开放端口后要重启防火墙生效 # 重启防火墙 systemctl restart firewalld ","date":"2021-08-14","objectID":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/:4:0","tags":["docker","linux"],"title":"安装配置Filebrowser","uri":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/"},{"categories":["Docker"],"content":"第五步 前台运行 启动file browser 配置修改好以后，就可以启动 File Browser 了，使用-d参数指定配置数据库路径，-r参数指定使用的目录。示例： filebrowser -d /etc/filebrowser/filebrowser.db -r /tmp/ ","date":"2021-08-14","objectID":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/:5:0","tags":["docker","linux"],"title":"安装配置Filebrowser","uri":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/"},{"categories":["Docker"],"content":"第六步 后台运行 File Browser 默认是前台运行，如何让它后台运行呢？ ","date":"2021-08-14","objectID":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/:6:0","tags":["docker","linux"],"title":"安装配置Filebrowser","uri":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/"},{"categories":["Docker"],"content":"第一种 nohup 大法： 运行：nohup filebrowser -d /etc/filebrowser.db \u003e/dev/null 2\u003e\u00261 \u0026 停止运行：kill -9 $(pidof filebrowser) 开机启动：sed -i '/exit 0/i\\nohup filebrowser -d \\/etc\\/filebrowser.db \u003e\\/dev\\/null 2\u003e\u00261 \u0026' /etc/rc.local 取消开机启动：sed -i '/nohup filebrowser -d \\/etc\\/filebrowser.db \u003e\\/dev\\/null 2\u003e\u00261 \u0026/d' /etc/rc.local ","date":"2021-08-14","objectID":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/:6:1","tags":["docker","linux"],"title":"安装配置Filebrowser","uri":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/"},{"categories":["Docker"],"content":"第二种 systemd 大法（推荐） 编写service文件：vi /etc/systemd/system/filebrowser.service 参照：https://blog.csdn.net/ywd1992/article/details/93030495 ExecStart根据自己的实际目录修改 [Unit] Description=File Browser After=network.target [Service] ExecStart=/usr/local/bin/filebrowser -d /etc/filebrowser/filebrowser.db [Install] WantedBy=multi-user.target 然后输入 systemctl daemon-reload systemctl start filebrowser systemctl enable filebrowser 停止运行：systemctl stop filebrowser 开机启动：systemctl enable filebrowser 取消开机启动：systemctl disable filebrowser 查看运行状态：systemctl status filebrowser 我推荐使用 systemd 的方法来后台运行，当然，前提是你所使用的操作系统支持 systemd。 ","date":"2021-08-14","objectID":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/:6:2","tags":["docker","linux"],"title":"安装配置Filebrowser","uri":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/"},{"categories":["Docker"],"content":"HTTPS File Browser 2.0 起开始内建 HTTPS 支持，只需要配置 SSL 证书即可。 配置 SSL：filebrowser -d /etc/filebrowser.db config set --cert example.com.crt --key example.com.key，其中example.com.crt和example.com.key分别是 SSL 证书和**路径，根据自身情况进行更改。配置完 SSL 后，只可以使用 HTTPS 访问，不可以使用 HTTP。 取消 SSL：filebrowser -d /etc/filebrowser.db config set --cert \"\" --key \"\" 当然，你也可以使用 Nginx 等 Web 服务器对 File Browser 进行反向代理，以达到 HTTPS 访问的目的。 还有就是使用 Caddy，这是一个开源、支持 HTTP/2 的 Web 服务器，它的一个显著特点就是默认启用 HTTPS 访问，会自己申请 SSL 证书，同时支持大量的插件，File Browser 就可以作为其插件运行。 参考： https://blog.csdn.net/Homewm/article/details/87931165 https://www.pianshen.com/article/3979763347/ ","date":"2021-08-14","objectID":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/:7:0","tags":["docker","linux"],"title":"安装配置Filebrowser","uri":"/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEfilebrowser/"},{"categories":["Linux"],"content":"作为Linux管理员，您可能需要对某些实例进行故障排除和修复引导问题，这通常是通过从Grub菜单将系统引导到紧急模式（Emergency mode）/恢复模式（Recovery mode）来实现的。在本文中，您将学习诊断问题并从紧急模式恢复系统。 将CentOS、RHEL 7/8引导到紧急模式（Emergency mode）/恢复模式（Recovery mode） 启动您的CentOS 7/8、RHEL 7/8 Linux机器，当出现引导加载程序菜单时，请按Enter键以外的任何键以中断倒计时： 按e键编辑当前条目，以便我们可以修改默认的引导加载程序条目并登录到紧急模式： 现在，使用光标键导航到以linux开头的行，您需要将systemd.unit=emergency.target添加到行尾，如上图方框所示。 按Ctrl+x键以使用修改后的配置启动。 输入root密码登录到紧急模式（Emergency mode）： 使用mount命令重新安装对/文件系统的读/写操作，这将使您能够编辑文件系统： # mount -o remount,rw / 参考：mount命令_Linux mount命令使用详解：用于加载文件系统到指定的加载点。 这时，您应该能够从紧急模式中拯救出故障的系统。 ","date":"2021-08-14","objectID":"/%E5%B0%86centos-78rhel-78%E5%BC%95%E5%AF%BC%E5%88%B0%E7%B4%A7%E6%80%A5%E6%A8%A1%E5%BC%8F%E6%81%A2%E5%A4%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95/:0:0","tags":["centos","恢复模式"],"title":"将CentOS、RHEL 7/8引导到紧急模式（Emergency mode）/恢复模式（Recovery mode）","uri":"/%E5%B0%86centos-78rhel-78%E5%BC%95%E5%AF%BC%E5%88%B0%E7%B4%A7%E6%80%A5%E6%A8%A1%E5%BC%8F%E6%81%A2%E5%A4%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":["Docker","安全"],"content":"出处 https://www.ddosi.com/xp_captcha/ https://github.com/smxiazi/NEW_xp_CAPTCHA ","date":"2021-08-14","objectID":"/%E6%90%AD%E5%BB%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%B8%8Eburpsuite%E8%81%94%E5%8A%A8/:0:1","tags":["docker","linux","burpsuite","安全","验证码识别"],"title":"搭建验证码识别服务并与BurpSuite联动","uri":"/%E6%90%AD%E5%BB%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%B8%8Eburpsuite%E8%81%94%E5%8A%A8/"},{"categories":["Docker","安全"],"content":"xp_CAPTCHA白嫖版白嫖版 ","date":"2021-08-14","objectID":"/%E6%90%AD%E5%BB%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%B8%8Eburpsuite%E8%81%94%E5%8A%A8/:1:0","tags":["docker","linux","burpsuite","安全","验证码识别"],"title":"搭建验证码识别服务并与BurpSuite联动","uri":"/%E6%90%AD%E5%BB%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%B8%8Eburpsuite%E8%81%94%E5%8A%A8/"},{"categories":["Docker","安全"],"content":"说明 xp_CAPTCHA 白嫖版白嫖版 验证码识别 burp插件 ","date":"2021-08-14","objectID":"/%E6%90%AD%E5%BB%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%B8%8Eburpsuite%E8%81%94%E5%8A%A8/:1:1","tags":["docker","linux","burpsuite","安全","验证码识别"],"title":"搭建验证码识别服务并与BurpSuite联动","uri":"/%E6%90%AD%E5%BB%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%B8%8Eburpsuite%E8%81%94%E5%8A%A8/"},{"categories":["Docker","安全"],"content":"安装 需要python3 小于3.7的版本 安装 muggle_ocr 模块（大概400M左右） python3 -m pip install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com muggle-ocr 运行 server.py 见文末 等待显示出 Starting server, listen at: 0.0.0.0:8899 访问 http://127.0.0.1:8899/ 显示下面界面即为正常。 linux 下安装可能会需要 安装即可 yum install libglvnd-glx-1.0.1-0.8.git5baa1e5.el7.x86_64 ","date":"2021-08-14","objectID":"/%E6%90%AD%E5%BB%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%B8%8Eburpsuite%E8%81%94%E5%8A%A8/:1:2","tags":["docker","linux","burpsuite","安全","验证码识别"],"title":"搭建验证码识别服务并与BurpSuite联动","uri":"/%E6%90%AD%E5%BB%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%B8%8Eburpsuite%E8%81%94%E5%8A%A8/"},{"categories":["Docker","安全"],"content":"验证码识别率 ","date":"2021-08-14","objectID":"/%E6%90%AD%E5%BB%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%B8%8Eburpsuite%E8%81%94%E5%8A%A8/:1:3","tags":["docker","linux","burpsuite","安全","验证码识别"],"title":"搭建验证码识别服务并与BurpSuite联动","uri":"/%E6%90%AD%E5%BB%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%B8%8Eburpsuite%E8%81%94%E5%8A%A8/"},{"categories":["Docker","安全"],"content":"使用方法 把图片base64编码后POST发送至接口http://localhost:8899/base64 的base64参数即可，返回结果为识别的后的结果。 ","date":"2021-08-14","objectID":"/%E6%90%AD%E5%BB%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%B8%8Eburpsuite%E8%81%94%E5%8A%A8/:1:4","tags":["docker","linux","burpsuite","安全","验证码识别"],"title":"搭建验证码识别服务并与BurpSuite联动","uri":"/%E6%90%AD%E5%BB%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%B8%8Eburpsuite%E8%81%94%E5%8A%A8/"},{"categories":["Docker","安全"],"content":"burp联动识别验证码爆破 如果 server.py 在服务器上跑的话，xp_CAPTCHA.py需要修改对应的IP。 修改完后导入burp Attack type处选择 Pitchfork,在http头部位置插入xiapao:验证码的URL地址 此处导入字典 选择验证码识别 然后把线程设置为1 ","date":"2021-08-14","objectID":"/%E6%90%AD%E5%BB%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%B8%8Eburpsuite%E8%81%94%E5%8A%A8/:1:5","tags":["docker","linux","burpsuite","安全","验证码识别"],"title":"搭建验证码识别服务并与BurpSuite联动","uri":"/%E6%90%AD%E5%BB%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%B8%8Eburpsuite%E8%81%94%E5%8A%A8/"},{"categories":["Docker","安全"],"content":"源码 server.py #!/usr/bin/env python # -*- conding:utf-8 -*- from http.server import HTTPServer, BaseHTTPRequestHandler import muggle_ocr import re,time,base64,os host = ('0.0.0.0', 8899) class Resquest(BaseHTTPRequestHandler): def handler(self): print(\"data:\", self.rfile.readline().decode()) self.wfile.write(self.rfile.readline()) def do_GET(self): print(self.requestline) if self.path != '/': self.send_error(404, \"Page not Found!\") return data = '\u003ctitle\u003exp_CAPTCHA\u003c/title\u003e\u003cbody style=\"text-align:center\"\u003e\u003ch1\u003e验证码识别：xp_CAPTCHA\u003c/h1\u003e\u003ca href=\"http://www.nmd5.com\"\u003eauthor:算命縖子\u003c/a\u003e\u003c/body\u003e' self.send_response(200) self.send_header('Content-type', 'text/html; charset=UTF-8') self.end_headers() self.wfile.write(data.encode()) def do_POST(self): #print(self.headers) #print(self.command) if self.path != '/base64': self.send_error(404, \"Page not Found!\") return img_name = time.time() req_datas = self.rfile.read(int(self.headers['content-length'])) req_datas = req_datas.decode() base64_img = re.search('base64=(.*?)$',req_datas) #print(base64_img.group(1)) #post base64参数的内容 with open(\"temp/%s.png\"%img_name, 'wb') as f: f.write(base64.b64decode(base64_img.group(1))) f.close() #验证码识别 sdk = muggle_ocr.SDK(model_type=muggle_ocr.ModelType.Captcha) with open(r\"temp/%s.png\"%img_name, \"rb\") as f: b = f.read() text = sdk.predict(image_bytes=b) print(text) #识别的结果 #删除掉图片文件，以防占用太大的内存 os.remove(\"temp/%s.png\"%img_name) self.send_response(200) self.send_header('Content-type', 'application/json') self.end_headers() self.wfile.write(text.encode('utf-8')) if __name__ == '__main__': os.makedirs('temp', exist_ok=True) server = HTTPServer(host, Resquest) print(\"Starting server, listen at: %s:%s\" % host) server.serve_forever() xp_CAPTCHA.py #!/usr/bin/env python #coding:gbk from burp import IBurpExtender from burp import IIntruderPayloadGeneratorFactory from burp import IIntruderPayloadGenerator import base64 import json import re import urllib2 import ssl host = ('127.0.0.1', 8899) class BurpExtender(IBurpExtender, IIntruderPayloadGeneratorFactory): def registerExtenderCallbacks(self, callbacks): #注册payload生成器 callbacks.registerIntruderPayloadGeneratorFactory(self) #插件里面显示的名字 callbacks.setExtensionName(\"xp_CAPTCHA\") print 'xp_CAPTCHA 中文名:瞎跑验证码\\nblog：http://www.nmd5.com/\\nT00ls：https://www.t00ls.net/ \\nThe loner安全团队 author:算命縖子\\n\\n用法：\\n在head头部添加xiapao:验证码的URL\\n\\n如：\\n\\nPOST /login HTTP/1.1\\nHost: www.baidu.com\\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:84.0) Gecko/20100101 Firefox/84.0\\nAccept: text/plain, */*; q=0.01\\nAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\\nContent-Type: application/x-www-form-urlencoded; charset=UTF-8\\nX-Requested-With: XMLHttpRequest\\nxiapao:http://www.baidu.com/get-validate-code\\nContent-Length: 84\\nConnection: close\\nCookie: JSESSIONID=24D59677C5EDF0ED7AFAB8566DC366F0\\n\\nusername=admin\u0026password=admin\u0026vcode=8888\\n\\n' def getGeneratorName(self): return \"xp_CAPTCHA\" def createNewInstance(self, attack): return xp_CAPTCHA(attack) class xp_CAPTCHA(IIntruderPayloadGenerator): def __init__(self, attack): tem = \"\".join(chr(abs(x)) for x in attack.getRequestTemplate()) #request内容 cookie = re.findall(\"Cookie: (.+?)\\r\\n\", tem)[0] #获取cookie xp_CAPTCHA = re.findall(\"xiapao:(.+?)\\r\\n\", tem)[0] ssl._create_default_https_context = ssl._create_unverified_context #忽略证书，防止证书报错 print xp_CAPTCHA+'\\n' print 'cookie:' + cookie+'\\n' self.xp_CAPTCHA = xp_CAPTCHA self.cookie = cookie self.max = 1 #payload最大使用次数 self.num = 0 #标记payload的使用次数 self.attack = attack def hasMorePayloads(self): #如果payload使用到了最大次数reset就清0 if self.num == self.max: return False # 当达到最大次数的时候就调用reset else: return True def getNextPayload(self, payload): # 这个函数请看下文解释 xp_CAPTCHA_url = self.xp_CAPTCHA #验证码url print xp_CAPTCHA_url headers = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36\",\"Cookie\":self.cookie} request = urllib2.Request(xp_CAPTCHA_url,headers=headers) CAPTCHA = ","date":"2021-08-14","objectID":"/%E6%90%AD%E5%BB%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%B8%8Eburpsuite%E8%81%94%E5%8A%A8/:1:6","tags":["docker","linux","burpsuite","安全","验证码识别"],"title":"搭建验证码识别服务并与BurpSuite联动","uri":"/%E6%90%AD%E5%BB%BA%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E5%B9%B6%E4%B8%8Eburpsuite%E8%81%94%E5%8A%A8/"},{"categories":["Linux"],"content":"转载自https://www.cnblogs.com/linuxk/p/12033796.html ","date":"2021-08-14","objectID":"/%E6%9C%8D%E5%8A%A1%E5%9C%A8%E5%86%85%E7%BD%91nginx%E8%AE%B0%E5%BD%95%E7%94%A8%E6%88%B7%E6%BA%90ip%E5%92%8C%E6%BA%90%E7%AB%AF%E5%8F%A3/:0:0","tags":["linux","nginx"],"title":"服务在“内网”，nginx记录用户源IP和源端口","uri":"/%E6%9C%8D%E5%8A%A1%E5%9C%A8%E5%86%85%E7%BD%91nginx%E8%AE%B0%E5%BD%95%E7%94%A8%E6%88%B7%E6%BA%90ip%E5%92%8C%E6%BA%90%E7%AB%AF%E5%8F%A3/"},{"categories":["Linux"],"content":"服务器架构前面加了防火墙，Nginx如何获取客户端真实ip？？？ 在大部分实际业务场景中，网站访问请求并不是简单地从用户（访问者）的浏览器直达网站的源站服务器，中间可能经过所部署的CDN、高防IP、WAF等代理服务器。例如，网站可能采用这样的部署架构：用户 \u003e CDN/高防IP/WAF \u003e 源站服务器。这种情况下，访问请求在经过多层加速或代理转发后，源站服务器该如何获取发起请求的真实客户端IP？ 一般情况下，透明的代理服务器在将用户的访问请求转发到下一环节的服务器时，会在HTTP的请求头中添加一条X-Forwarded-For记录，用于记录用户的真实IP，其记录格式为X-Forwarded-For:用户IP。如果期间经历多个代理服务器，则X-Forwarded-For将以该格式记录用户真实IP和所经过的代理服务器IP：X-Forwarded-For:用户IP, 代理服务器1-IP, 代理服务器2-IP, 代理服务器3-IP, ……。 因此，常见的Web应用服务器可以使用X-Forwarded-For的方式获取访问者真实IP。 Nginx配置方案 1、确认nginx安装时已经安装http_realip_module模块 为实现负载均衡，Nginx使用http_realip_module模块来获取真实IP。# nginx -V | grep http_realip_module命令查看是否已安装该模块。如未安装，则需要重新编译Nginx服务并加装该模块。方法如下： wget http://nginx.org/download/nginx-1.14.2.tar.gz tar zxvf nginx-1.14.2.tar.gz cd nginx-1.14.2 ./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --without-http-cache --with-http_ssl_module --with-http_realip_module make make install kill -USR2 `cat /usr/local/nginx/logs/nginx.pid` kill -QUIT `cat /usr/local/nginx/logs/ nginx.pid.oldbin` 2、修改Nginx对应server的配置 打开www.conf配置文件，在location / {} 中加入以下内容： set_real_ip_from ip_range1; #真实服务器上一级代理的IP地址或者IP段,可以写多行 set_real_ip_from ip_range2; ... set_real_ip_from ip_rangex; real_ip_header X-Forwarded-For; #从哪个header头检索出需要的IP地址 real_ip_recursive on; #递归排除set_real_ip_from里面出现的IP,其余没有出现的认为是用户真实IP 说明: 其中，ip_range1，2，…，x 指WAF的回源IP地址，需要分多条分别添加。 如何获取WAF的回源IP地址？？？ 打开WAF界面–\u003e设置–\u003e产品信息–\u003e即可查看到回源IP段，将这里的IP段按照上面的方式写进nginx配置当中即可，查看nginx访问日志就是客户端真实ip了。不过要说的是阿里的回源IP段真多，用notepad++处理好配置再写上去更方便！ 3、修改日志记录格式 log_format一般在nginx.conf配置文件中的http配置部分。在log_format中，添加x-forwarded-for字段，替换原来remote-address字段，即将log_format修改为以下内容： log_format main '$http_x_forwarded_for - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" '; Don’t forget the beginner’s mind ","date":"2021-08-14","objectID":"/%E6%9C%8D%E5%8A%A1%E5%9C%A8%E5%86%85%E7%BD%91nginx%E8%AE%B0%E5%BD%95%E7%94%A8%E6%88%B7%E6%BA%90ip%E5%92%8C%E6%BA%90%E7%AB%AF%E5%8F%A3/:1:0","tags":["linux","nginx"],"title":"服务在“内网”，nginx记录用户源IP和源端口","uri":"/%E6%9C%8D%E5%8A%A1%E5%9C%A8%E5%86%85%E7%BD%91nginx%E8%AE%B0%E5%BD%95%E7%94%A8%E6%88%B7%E6%BA%90ip%E5%92%8C%E6%BA%90%E7%AB%AF%E5%8F%A3/"},{"categories":["Linux"],"content":" https://mefj.com.cn/lur2853.html ","date":"2021-08-14","objectID":"/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E9%95%9C%E5%83%8F%E5%BF%AB%E7%85%A7%E8%BF%81%E7%A7%BB%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/:0:0","tags":["ECS","VMWARE"],"title":"阿里云ECS镜像快照迁移到虚拟机","uri":"/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E9%95%9C%E5%83%8F%E5%BF%AB%E7%85%A7%E8%BF%81%E7%A7%BB%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"categories":["Linux"],"content":"找到ECS实例创建快照 {% asset_img image-1.png %} {% asset_img image-2.png %} ","date":"2021-08-14","objectID":"/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E9%95%9C%E5%83%8F%E5%BF%AB%E7%85%A7%E8%BF%81%E7%A7%BB%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/:0:1","tags":["ECS","VMWARE"],"title":"阿里云ECS镜像快照迁移到虚拟机","uri":"/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E9%95%9C%E5%83%8F%E5%BF%AB%E7%85%A7%E8%BF%81%E7%A7%BB%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"categories":["Linux"],"content":"等待镜像创建100% {% asset_img image-3.png %} {% asset_img image-4.png %} ","date":"2021-08-14","objectID":"/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E9%95%9C%E5%83%8F%E5%BF%AB%E7%85%A7%E8%BF%81%E7%A7%BB%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/:0:2","tags":["ECS","VMWARE"],"title":"阿里云ECS镜像快照迁移到虚拟机","uri":"/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E9%95%9C%E5%83%8F%E5%BF%AB%E7%85%A7%E8%BF%81%E7%A7%BB%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"categories":["Linux"],"content":"导出到阿里云OSS存储。阿里云镜像不可以直接下载到本地，只能通过OSS下载到本地 {% asset_img image-5.png %} {% asset_img image-6.png %} {% asset_img image-7.png %} {% asset_img image-8.png %} --\u003e ","date":"2021-08-14","objectID":"/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E9%95%9C%E5%83%8F%E5%BF%AB%E7%85%A7%E8%BF%81%E7%A7%BB%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/:0:3","tags":["ECS","VMWARE"],"title":"阿里云ECS镜像快照迁移到虚拟机","uri":"/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E9%95%9C%E5%83%8F%E5%BF%AB%E7%85%A7%E8%BF%81%E7%A7%BB%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"categories":["Linux"],"content":"下载到本地，OSS流量比较贵，建议没有特殊情况不要随意使用，我这里镜像下载了10个多GB，费用在五六块钱 {% asset_img image-9.png %} ","date":"2021-08-14","objectID":"/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E9%95%9C%E5%83%8F%E5%BF%AB%E7%85%A7%E8%BF%81%E7%A7%BB%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/:0:4","tags":["ECS","VMWARE"],"title":"阿里云ECS镜像快照迁移到虚拟机","uri":"/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E9%95%9C%E5%83%8F%E5%BF%AB%E7%85%A7%E8%BF%81%E7%A7%BB%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"categories":["Linux"],"content":"本地找到下载镜像文件格式为**.raw.tar.gz**的文件，解压到本地 {% asset_img image-10.png %} ","date":"2021-08-14","objectID":"/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E9%95%9C%E5%83%8F%E5%BF%AB%E7%85%A7%E8%BF%81%E7%A7%BB%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/:0:5","tags":["ECS","VMWARE"],"title":"阿里云ECS镜像快照迁移到虚拟机","uri":"/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E9%95%9C%E5%83%8F%E5%BF%AB%E7%85%A7%E8%BF%81%E7%A7%BB%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"categories":["Linux"],"content":"使用qemu工具将raw格式转换成VMware可以使用的vmdk格式 {% asset_img image-11.png %} {% asset_img image-12.png %} 注：raw为最原始的虚拟机镜像文件，vmdk是vmware的虚拟机镜像文件，如果要查看raw文件中的内容可以先把raw文件转换为vmdk文件，然后再用vmware虚拟机打开vmdk文件。 ","date":"2021-08-14","objectID":"/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E9%95%9C%E5%83%8F%E5%BF%AB%E7%85%A7%E8%BF%81%E7%A7%BB%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/:0:6","tags":["ECS","VMWARE"],"title":"阿里云ECS镜像快照迁移到虚拟机","uri":"/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E9%95%9C%E5%83%8F%E5%BF%AB%E7%85%A7%E8%BF%81%E7%A7%BB%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"categories":["Linux"],"content":"创建虚拟机，选择现有磁盘（这步很重要） {% asset_img image-13.png %} ","date":"2021-08-14","objectID":"/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E9%95%9C%E5%83%8F%E5%BF%AB%E7%85%A7%E8%BF%81%E7%A7%BB%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/:0:7","tags":["ECS","VMWARE"],"title":"阿里云ECS镜像快照迁移到虚拟机","uri":"/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E9%95%9C%E5%83%8F%E5%BF%AB%E7%85%A7%E8%BF%81%E7%A7%BB%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"categories":["Linux"],"content":"启动创建的虚拟机即可 ","date":"2021-08-14","objectID":"/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E9%95%9C%E5%83%8F%E5%BF%AB%E7%85%A7%E8%BF%81%E7%A7%BB%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/:0:8","tags":["ECS","VMWARE"],"title":"阿里云ECS镜像快照迁移到虚拟机","uri":"/%E9%98%BF%E9%87%8C%E4%BA%91ecs%E9%95%9C%E5%83%8F%E5%BF%AB%E7%85%A7%E8%BF%81%E7%A7%BB%E5%88%B0%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"categories":["Docker"],"content":"一、在线配置生成工具 https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN ","date":"2021-08-14","objectID":"/%E5%9C%A8%E7%BA%BFnginx%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E5%92%8Cnginx%E9%85%8D%E7%BD%AEui%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:1:0","tags":["linux","nginx","docker"],"title":"在线nginx配置生成工具和nginx配置UI管理工具","uri":"/%E5%9C%A8%E7%BA%BFnginx%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E5%92%8Cnginx%E9%85%8D%E7%BD%AEui%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"categories":["Docker"],"content":"二、nginx配置webUI管理工具 均为docker容器部署 ","date":"2021-08-14","objectID":"/%E5%9C%A8%E7%BA%BFnginx%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E5%92%8Cnginx%E9%85%8D%E7%BD%AEui%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:2:0","tags":["linux","nginx","docker"],"title":"在线nginx配置生成工具和nginx配置UI管理工具","uri":"/%E5%9C%A8%E7%BA%BFnginx%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E5%92%8Cnginx%E9%85%8D%E7%BD%AEui%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"categories":["Docker"],"content":"nginx proxy manager 优点 可容器化部署，轻量化（两个容器占用共71M+45M内存）、无汉化 缺点 谈不上缺点的缺点—-两个容器 https://nginxproxymanager.com/ 部署： 新建docker-compose.yml version: '3' services: app: container_name: NginxProxyManager-WEB image: 'jc21/nginx-proxy-manager:latest' ports: - '80:80' - '81:81' - '443:443' environment: DB_MYSQL_HOST: \"db\" DB_MYSQL_PORT: 3306 DB_MYSQL_USER: \"npm\" DB_MYSQL_PASSWORD: \"npm\" DB_MYSQL_NAME: \"npm\" volumes: - /tmp/NginxProxyManager/data:/data - /tmp/NginxProxyManager/letsencrypt:/etc/letsencrypt db: container_name: NginxProxyManager-DB image: 'jc21/mariadb-aria:latest' environment: MYSQL_ROOT_PASSWORD: 'npm' MYSQL_DATABASE: 'npm' MYSQL_USER: 'npm' MYSQL_PASSWORD: 'npm' volumes: - /tmp/NginxProxyManager/mysql:/var/lib/mysql 然后在上述文件目录下执行：docker-compose up -d 如果已有数据库，则运行以下命令： docker run -itd --name=NginxProxyManager-WEB \\ --restart=unless-stopped \\ --link=db \\ -e DB_MYSQL_HOST: \"db\" \\ -e DB_MYSQL_PORT: 3306 \\ -e DB_MYSQL_USER: \"npm\" \\ -e DB_MYSQL_PASSWORD: \"npm\" \\ -e DB_MYSQL_NAME: \"npm\" \\ -v /tmp/NginxProxyManager/data:/data \\ -v /tmp/NginxProxyManager/letsencrypt:/etc/letsencrypt \\ jc21/nginx-proxy-manager:latest ","date":"2021-08-14","objectID":"/%E5%9C%A8%E7%BA%BFnginx%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E5%92%8Cnginx%E9%85%8D%E7%BD%AEui%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:2:1","tags":["linux","nginx","docker"],"title":"在线nginx配置生成工具和nginx配置UI管理工具","uri":"/%E5%9C%A8%E7%BA%BFnginx%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E5%92%8Cnginx%E9%85%8D%E7%BD%AEui%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"categories":["Docker"],"content":"nginx webui 优点 国人使用JAVA开发的，语言友善，只有一个容器，便于管理 缺点 占用资源很大（同样环境中该容器占用205M内存） http://www.nginxwebui.cn/ ","date":"2021-08-14","objectID":"/%E5%9C%A8%E7%BA%BFnginx%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E5%92%8Cnginx%E9%85%8D%E7%BD%AEui%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:2:2","tags":["linux","nginx","docker"],"title":"在线nginx配置生成工具和nginx配置UI管理工具","uri":"/%E5%9C%A8%E7%BA%BFnginx%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E5%92%8Cnginx%E9%85%8D%E7%BD%AEui%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"categories":["Docker"],"content":"类似地，貌似通过修改容器配置文件，可以实现端口映射等其他最初运行容器时未设置的参数。 端口映射的修改请看：如何给已运行容器修改 / 添加端口映射 ","date":"2021-08-14","objectID":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/:0:0","tags":["linux","docker"],"title":"如何给已经运行的容器添加映射路径","uri":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/"},{"categories":["Docker"],"content":"方法一 通过修改已有容器配置文件实现 ","date":"2021-08-14","objectID":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/:1:0","tags":["linux","docker"],"title":"如何给已经运行的容器添加映射路径","uri":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/"},{"categories":["Docker"],"content":"准备 如果要操作的容器在运行，停掉正在运行的容器 ","date":"2021-08-14","objectID":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/:1:1","tags":["linux","docker"],"title":"如何给已经运行的容器添加映射路径","uri":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/"},{"categories":["Docker"],"content":"第一步 获取容器所使用的镜像ID docker inspect 容器名称|grep Id 镜像ID形如：bde9b0f3a3a40521e60f10dfbce9a15d3ea0d0708ef65c303cea73656fbc5acb ","date":"2021-08-14","objectID":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/:1:2","tags":["linux","docker"],"title":"如何给已经运行的容器添加映射路径","uri":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/"},{"categories":["Docker"],"content":"第二步 打开已停止容器的配置文件, 配置文件位置：/var/lib/docker/containers/第一步获取到的镜像ID/config.v2.json 旧版本的可能是旧版本的docker可能是config.json. ","date":"2021-08-14","objectID":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/:1:3","tags":["linux","docker"],"title":"如何给已经运行的容器添加映射路径","uri":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/"},{"categories":["Docker"],"content":"第三步 找到MountPoints区域,未做过路径映射的应该是空的: \"MountPoints\":{}，然后用形如如下格式的内容替换你可以从其他做过路径映射的容器的配置文件中获取你可以从其他做过路径映射的容器的配置文件中获取: \"MountPoints\": { \"/mnt\": { # 容器路径 \"Source\": \"/home/\u003cuser-name\u003e\", # 宿主机路径 \"Destination\": \"/mnt\", # 容器路径 \"RW\": true, \"Name\": \"\", \"Driver\": \"\", \"Type\": \"bind\", \"Propagation\": \"rprivate\", \"Spec\": { \"Type\": \"bind\", \"Source\": \"/home/\u003cuser-name\u003e\", # 宿主机路径 \"Target\": \"/mnt\" # 容器路径 }, \"SkipMountpointCreation\": false } } ","date":"2021-08-14","objectID":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/:1:4","tags":["linux","docker"],"title":"如何给已经运行的容器添加映射路径","uri":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/"},{"categories":["Docker"],"content":"第四步 重启整个 docker 服务: service docker restart ","date":"2021-08-14","objectID":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/:1:5","tags":["linux","docker"],"title":"如何给已经运行的容器添加映射路径","uri":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/"},{"categories":["Docker"],"content":"方法二 通过将现有容器提交为镜像实现 ","date":"2021-08-14","objectID":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/:2:0","tags":["linux","docker"],"title":"如何给已经运行的容器添加映射路径","uri":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/"},{"categories":["Docker"],"content":"第一步 停掉要操作的容器docker stop 容器名字。 docker ps -a获取该容器的容器ID ","date":"2021-08-14","objectID":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/:2:1","tags":["linux","docker"],"title":"如何给已经运行的容器添加映射路径","uri":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/"},{"categories":["Docker"],"content":"第二步 将当前容器提交为新的镜像docker commit 容器ID 指定新的镜像名称（须与原来的不同） ","date":"2021-08-14","objectID":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/:2:2","tags":["linux","docker"],"title":"如何给已经运行的容器添加映射路径","uri":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/"},{"categories":["Docker"],"content":"第三步 在第二步创建的镜像上重新运行容器（经过实验，原来的映射等参数均丢失，需要全部重新指定） docker run -it -v \"$PWD/somedir\":/somedir 新容器名称 /bin/bash 原文在此，仅作翻译：https://stackoverflow.com/a/53516263 ","date":"2021-08-14","objectID":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/:2:3","tags":["linux","docker"],"title":"如何给已经运行的容器添加映射路径","uri":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84/"},{"categories":["Docker"],"content":"准备 如果要操作的容器在运行，停掉正在运行的容器 ","date":"2021-08-14","objectID":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E4%BF%AE%E6%94%B9-%E6%B7%BB%E5%8A%A0%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/:0:1","tags":["linux","docker"],"title":"如何给已运行容器修改 \\ 添加端口映射","uri":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E4%BF%AE%E6%94%B9-%E6%B7%BB%E5%8A%A0%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/"},{"categories":["Docker"],"content":"第一步 获取容器所使用的镜像ID docker inspect 容器名称|grep Id 镜像ID形如：bde9b0f3a3a40521e60f10dfbce9a15d3ea0d0708ef65c303cea73656fbc5acb ","date":"2021-08-14","objectID":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E4%BF%AE%E6%94%B9-%E6%B7%BB%E5%8A%A0%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/:0:2","tags":["linux","docker"],"title":"如何给已运行容器修改 \\ 添加端口映射","uri":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E4%BF%AE%E6%94%B9-%E6%B7%BB%E5%8A%A0%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/"},{"categories":["Docker"],"content":"第二步 打开已停止容器的配置文件, 配置文件位置：/var/lib/docker/containers/第一步获取到的镜像ID/hostconfig.json. ","date":"2021-08-14","objectID":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E4%BF%AE%E6%94%B9-%E6%B7%BB%E5%8A%A0%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/:0:3","tags":["linux","docker"],"title":"如何给已运行容器修改 \\ 添加端口映射","uri":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E4%BF%AE%E6%94%B9-%E6%B7%BB%E5%8A%A0%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/"},{"categories":["Docker"],"content":"第三步 找到PortBindings区域并根据需要修改: ....... . . . \"PortBindings\": { \"80/tcp\": [{ \"HostIp\": \"\", \"HostPort\": \"8000\" }] }, \"RestartPolicy\": { \"Name\": \"always\", \"MaximumRetryCount\": 0 }, . . . . ....... ","date":"2021-08-14","objectID":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E4%BF%AE%E6%94%B9-%E6%B7%BB%E5%8A%A0%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/:0:4","tags":["linux","docker"],"title":"如何给已运行容器修改 \\ 添加端口映射","uri":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E4%BF%AE%E6%94%B9-%E6%B7%BB%E5%8A%A0%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/"},{"categories":["Docker"],"content":"第四步 重启整个 docker 服务: service docker restart ","date":"2021-08-14","objectID":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E4%BF%AE%E6%94%B9-%E6%B7%BB%E5%8A%A0%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/:0:5","tags":["linux","docker"],"title":"如何给已运行容器修改 \\ 添加端口映射","uri":"/%E5%A6%82%E4%BD%95%E7%BB%99%E5%B7%B2%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E4%BF%AE%E6%94%B9-%E6%B7%BB%E5%8A%A0%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/"},{"categories":["Other"],"content":"https://shop.obweb.cn/#/ ","date":"2021-08-14","objectID":"/%E6%97%A0%E9%99%90%E7%BD%91%E7%9B%98%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%89%B9%E6%AE%8A%E4%BC%98%E6%83%A0%E7%A0%81%E7%AD%89%E8%B4%AD%E4%B9%B0/:0:0","tags":null,"title":"无限网盘、云服务特殊优惠码等购买","uri":"/%E6%97%A0%E9%99%90%E7%BD%91%E7%9B%98%E4%BA%91%E6%9C%8D%E5%8A%A1%E7%89%B9%E6%AE%8A%E4%BC%98%E6%83%A0%E7%A0%81%E7%AD%89%E8%B4%AD%E4%B9%B0/"},{"categories":null,"content":"引用本地图 参考：原文链接 首先在hexo的配置文件_config.yml中增加一句： permalink: :title/ 再在source文件夹中新建images文件夹，插入的图片要保存进此文件夹。 插入语法html(可控制图片大小): \u003cimg src=\"/four heroes.jpg\" alt=\"dota插图\" style=\"zoom:80%;\" /\u003e # 或 \u003cimg src=\"/images/four heroes.jpg\" width=50% height=50% align=center/\u003e ","date":"2021-08-14","objectID":"/hexo%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/:1:0","tags":null,"title":"Hexo引用本地图片","uri":"/hexo%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/"},{"categories":null,"content":"label标签彩色文字样例，仅butterfly主题生效 臣亮言：{% label 先帝 %}创业未半，而{% label 中道崩殂 blue %}。今天下三分，{% label 益州疲敝 pink %}，此诚{% label 危急存亡之秋 red %}也！然侍衞之臣，不懈于内；{% label 忠志之士 purple %}，忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气；不宜妄自菲薄，引喻失义，以塞忠谏之路也。 宫中、府中，俱为一体；陟罚臧否，不宜异同。若有{% label 作奸 orange %}、{% label 犯科 green %}，及为忠善者，宜付有司，论其刑赏，以昭陛下平明之治；不宜偏私，使内外异法也。 ","date":"2021-08-14","objectID":"/hexo%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/:1:1","tags":null,"title":"Hexo引用本地图片","uri":"/hexo%E5%BC%95%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/"},{"categories":null,"content":"自己打磨 ","date":"2021-08-12","objectID":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/:1:0","tags":["butterfly"],"title":"Butterfly主题折腾","uri":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"chrome浏览网页，检查并试图修改元素看变化，如果自己要的效果变了就是自己要找的元素，再以此为关键字用sublime text去搜索主题目录及其子目录文件。 ","date":"2021-08-12","objectID":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/:1:1","tags":["butterfly"],"title":"Butterfly主题折腾","uri":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"修改首页卡片高度 修改文件\\themes\\butterfly\\source\\css\\_page\\homepage.styl \u0026 \u003e .recent-post-item display: flex flex-direction: row align-items: center height: 20em # 修改此处，可在chrome先边修改边预览，再改此处 border-radius: 12px 8px 8px 12px background: var(--card-bg) box-shadow: var(--card-box-shadow) transition: all .3s ","date":"2021-08-12","objectID":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/:1:2","tags":["butterfly"],"title":"Butterfly主题折腾","uri":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"修改首页卡片背景颜色 修改文件themes\\butterfly\\source\\css\\var.styl // Global color \u0026 SVG $light-blue = $theme-color $dark-black = #000000 $light-grey = #EEEEEE $grey = #858585 $white = #FFFFFF # 修改此处，可在chrome先边修改边预览，再改此处 $whitesmoke = #f5f5f5 $font-black = #4C4948 $card-bg = $white $text-highlight-color = $font-color $text-hover = $theme-color $text-bg-hover = $theme-color 更好的卡片背景色（文章文字等的颜色同样适用）修改方法， 将上面文件中的$card-bg改为如下式样： $card-bg = $themeColorEnable \u0026\u0026 hexo-config('theme_color.card-bg_color') ? alpha(convert(hexo-config('theme_color.card-bg_color')), .1) : $card-green 然后再主题配置文件的theme_color块 # 美化/特效 # 自定義主題色 # 顏色值必須被雙引號包裹，就像\"#000\"而不是#000。否則將會在構建的時候報錯！ theme_color: enable: true main: \"#49B1F5\" paginator: \"#00c4b6\" button_hover: \"#FF7242\" text_selection: \"#00c4b6\" link_color: \"#99a9bf\" meta_color: \"#858585\" hr_color: \"#A4D8FA\" code_foreground: \"#F47466\" code_background: \"rgba(27, 31, 35, .05)\" toc_color: \"#00c4b6\" blockquote_padding_color: \"#49b1f5\" blockquote_background_color: \"#49b1f5\" card-bg_color: \"#3D3D11\" #卡片背景 备选，海蓝色#00ffe0d1 修改正文字体颜色 themes\\butterfly\\source\\css\\_global\\index.styl :root --global-font-size: $font-size --global-bg: $body-bg // --font-color: $font-black --font-color: #ffffff ","date":"2021-08-12","objectID":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/:1:3","tags":["butterfly"],"title":"Butterfly主题折腾","uri":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"修改导航栏高度 修改themes\\butterfly\\source\\css\\_layout\\head.styl #nav position: absolute top: 0 z-index: 90 display: flex flex-wrap: wrap align-items: center padding: 0 36px width: 100% // 修改此处 height: 60px font-size: 1.3em opacity: 0 transition: all .5s 好看主题：https://ethant.top/ 其图片地址：https://cdn.jsdelivr.net/gh/tzy13755126023/BLOG_SOURCE/theme_f/main.jpg ","date":"2021-08-12","objectID":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/:1:4","tags":["butterfly"],"title":"Butterfly主题折腾","uri":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"CSS 修改 来源：https://butterfly.lete114.top/article/Butterfly-config.html 新建 Hexo-Butterfly\\themes\\Butterfly-Master\\source\\css\\Lete.css(css 文件名自定义) ","date":"2021-08-12","objectID":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/:2:0","tags":["butterfly"],"title":"Butterfly主题折腾","uri":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"手机端显示 /*移动端优化：去除归档、标签、最新文章、公告、、只保留网站统计*/ @media screen and (max-width: 800px) { #aside_content div:not(:last-child) { display: none; font-size: 13px; } } ","date":"2021-08-12","objectID":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/:2:1","tags":["butterfly"],"title":"Butterfly主题折腾","uri":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"滚动条 /* 滚动条 */ ::-webkit-scrollbar { width: 10px; height: 10px; } ::-webkit-scrollbar-thumb { background-color: #e58a8a; background-image: -webkit-linear-gradient( 45deg, rgba(255, 255, 255, 0.4) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.4) 50%, rgba(255, 255, 255, 0.4) 75%, transparent 75%, transparent); border-radius: 2em; } ::-webkit-scrollbar-corner { background-color: transparent; } ::-moz-selection { color: #fff; background-color: #e58a8a; } ","date":"2021-08-12","objectID":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/:2:2","tags":["butterfly"],"title":"Butterfly主题折腾","uri":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"进阶修改 来源：https://ouoholly.github.io/post/my-custom-config-on-hexo-butterfly-theme/ 主題顏色 如果想進階修改主題顏色的話，可到以下文件修改參數： .\\themes\\Butterfly\\source\\css\\var.styl ","date":"2021-08-12","objectID":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/:3:0","tags":["butterfly"],"title":"Butterfly主题折腾","uri":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"主頁文章：不顯示圖片cover 在 .\\themes\\Butterfly\\_config.yml 設定 index_post_cover: none 在 .\\themes\\Butterfly\\source\\css\\_layout\\page.styl , 2.1 - 把 .recent-post-info 設定 width: 100% 2.2 - 在描述 index_post_cover 那裡添加下面三行： else if hexo-config('index_post_cover') == 'none' .post_cover display: none ","date":"2021-08-12","objectID":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/:3:1","tags":["butterfly"],"title":"Butterfly主题折腾","uri":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"右下角按鈕：改為默認顯示，按才隱藏 右下角的 黑夜模式、繁簡轉換 、字體大小 按鈕原本是默認隱藏的，要按那個轉轉的設置按鈕才會彈出來。 我想把這些功能按鈕改成默認顯示，按那個轉轉設置按鈕就收起來，再按再彈出來這樣和原本反過來的效果。 於是把 .\\themes\\Butterfly\\source\\css\\_layout\\rightside.styl 裡改成下面這樣： #rightside position: fixed right: -38px bottom: 40px opacity: 0 transition: all .5s #rightside-config-hide transform: translate(0, 0) .rightside-in animation: rightsideIn .3s .rightside-out animation: rightsideOut .3s transform: translate(30px, 0) !important \u0026 \u003e div \u0026 \u003e i, \u0026 \u003e a, \u0026 \u003e div display: block margin-bottom: 2px width: 30px height: 30px background-color: $light-blue color: $white text-align: center text-decoration: none font-size: 16px line-height: 29px cursor: pointer \u0026:hover background-color: $ruby #rightside_config i animation: avatar_turn_around 2s linear infinite #mobile-toc-button display: none @media screen and (max-width: $bg) #rightside #mobile-toc-button display: block @keyframes rightsideOut 0% transform: translate(0, 0) 100% transform: translate(30px, 0) @keyframes rightsideIn 0% transform: translate(30px, 0) 100% transform: translate(0, 0) ","date":"2021-08-12","objectID":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/:3:2","tags":["butterfly"],"title":"Butterfly主题折腾","uri":"/%E8%AE%B0%E5%BD%95butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"categories":["Linux"],"content":" ... ","date":"2021-07-14","objectID":"/cf%E9%BB%98%E8%AE%A4%E8%BD%AC%E5%8F%91%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8/:0:0","tags":["linux","centos"],"title":"CF默认转发的端口列表","uri":"/cf%E9%BB%98%E8%AE%A4%E8%BD%AC%E5%8F%91%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8/"},{"categories":null,"content":"Make sure all the code blocks highlighted correctly. All the code samples are come from the demo of https://highlightjs.org Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. #[derive(Debug)] pub enum State { Start, Transient, Closed, } impl From\u003c\u0026'a str\u003e for State { fn from(s: \u0026'a str) -\u003e Self { match s { \"start\" =\u003e State::Start, \"closed\" =\u003e State::Closed, _ =\u003e unreachable!(), } } } [ { \"title\": \"apples\", \"count\": [12000, 20000], \"description\": {\"text\": \"...\", \"sensitive\": false} }, { \"title\": \"oranges\", \"count\": [17500, null], \"description\": {\"text\": \"...\", \"sensitive\": false} } ] @requires_authorization def somefunc(param1='', param2=0): r'''A docstring''' if param1 \u003e param2: # interesting print 'Gre\\'ater' return (param2 - param1 + 1 + 0b10l) or None class SomeClass: pass \u003e\u003e\u003e message = '''interpreter ... prompt''' \u003c!DOCTYPE html\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003cstyle\u003ebody {width: 500px;}\u003c/style\u003e \u003cscript type=\"application/javascript\"\u003e function $init() {return true;} \u003c/script\u003e \u003cbody\u003e \u003cp checked class=\"title\" id='title'\u003eTitle\u003c/p\u003e \u003c!-- here goes the rest of the page --\u003e \u003c/body\u003e function $initHighlight(block, cls) { try { if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0F) + ` class=\"${cls}\"`; } catch (e) { /* handle exception */ } for (var i = 0 / 2; i \u003c classes.length; i++) { if (checkCondition(classes[i]) === undefined) console.log('undefined'); } return ( \u003cdiv\u003e \u003cweb-component\u003e{block}\u003c/web-component\u003e \u003c/div\u003e ) } export $initHighlight; #include \u003ciostream\u003e int main(int argc, char *argv[]) { /* An annoying \"Hello World\" example */ for (auto i = 0; i \u003c 0xFFFF; i++) cout \u003c\u003c \"Hello, World!\" \u003c\u003c endl; char c = '\\n'; unordered_map \u003cstring, vector\u003cstring\u003e \u003e m; m[\"key\"] = \"\\\\\\\\\"; // this is an error return -2e3 + 12l; } CREATE TABLE \"topic\" ( \"id\" serial NOT NULL PRIMARY KEY, \"forum_id\" integer NOT NULL, \"subject\" varchar(255) NOT NULL ); ALTER TABLE \"topic\" ADD CONSTRAINT forum_id FOREIGN KEY (\"forum_id\") REFERENCES \"forum\" (\"id\"); -- Initials insert into \"topic\" (\"forum_id\", \"subject\") values (2, 'D''artagnian'); #import \u003cUIKit/UIKit.h\u003e #import \"Dependency.h\" @protocol WorldDataSource @optional - (NSString*)worldName; @required - (BOOL)allowsToLive; @end @property (nonatomic, readonly) NSString *title; - (IBAction) show; @end /** * @author John Smith \u003cjohn.smith@example.com\u003e */ package l2f.gameserver.model; public abstract class L2Char extends L2Object { public static final Short ERROR = 0x0001; public void moveTo(int x, int y, int z) { _ai = null; log(\"Should not be called\"); if (1 \u003e 5) { // wtf!? return; } } } import Foundation @objc class Person: Entity { var name: String! var age: Int! init(name: String, age: Int) { /* /* ... */ */ } // Return a descriptive string for this person func description(offset: Int = 0) -\u003e String { return \"\\(name) is \\(age + offset) years old\" } } @font-face { font-family: Chunkfive; src: url('Chunkfive.otf'); } body, .usertext { color: #F0F0F0; background: #600; font-family: Chunkfive, sans; } @import url(print.css); @media print { a[href^=http]::after { content: attr(href) } } # The Greeter class class Greeter def initialize(name) @name = name.capitalize end def salute puts \"Hello #{@name}!\" end end g = Greeter.new(\"world\") g.salute # Makefile BUILDDIR = _build EXTRAS ?= $(BUILDDIR)/extras .PHONY: main clean main: @echo \"Building main facility...\" build_main $(BUILDDIR) clean: rm -rf $(BUILDDIR)/* package main import \"fmt\" func main() { ch := make(chan float64) ch \u003c- 1.0e10 // magic number x, ok := \u003c- ch defer fmt.Println(`exitting now\\`) go println(len(\"hello world!\")) return } #!/bin/bash ###### CONFIG ACCEPTED_HOSTS=\"/root/.hag_accepted.conf\" BE_VERBOSE=false if [ \"$UID\" -ne 0 ] then echo \"Superuser rights required\" exit 2 fi genApacheConf(){ echo -e \"# Host ${HOME_DIR}$1/$2 :\" } ; boilerplate","date":"2019-07-25","objectID":"/code-highlight/:0:0","tags":null,"title":"Code Highlight Style test","uri":"/code-highlight/"},{"categories":null,"content":"title: Categories date: 2013-12-24 23:30:09 categories: This post contains 3 categories. Make sure your theme can display all of the categories. ","date":"0001-01-01","objectID":"/categories/:1:0","tags":null,"title":"","uri":"/categories/"},{"categories":null,"content":"title: Elements date: 2013-12-24 23:29:08 tags: The purpose of this post is to help you make sure all of HTML elements can display properly. If you use CSS reset, don’t forget to redefine the style by yourself. Heading 1 ","date":"0001-01-01","objectID":"/elements/:1:0","tags":null,"title":"","uri":"/elements/"},{"categories":null,"content":"Heading 2 ","date":"0001-01-01","objectID":"/elements/:2:0","tags":null,"title":"","uri":"/elements/"},{"categories":null,"content":"Heading 3 Heading 4 Heading 5 Heading 6 ","date":"0001-01-01","objectID":"/elements/:2:1","tags":null,"title":"","uri":"/elements/"},{"categories":null,"content":"Paragraph Lorem ipsum dolor sit amet, test link consectetur adipiscing elit. Strong text pellentesque ligula commodo viverra vehicula. Italic text at ullamcorper enim. Morbi a euismod nibh. Underline text non elit nisl. Deleted text tristique, sem id condimentum tempus, metus lectus venenatis mauris, sit amet semper lorem felis a eros. Fusce egestas nibh at sagittis auctor. Sed ultricies ac arcu quis molestie. Donec dapibus nunc in nibh egestas, vitae volutpat sem iaculis. Curabitur sem tellus, elementum nec quam id, fermentum laoreet mi. Ut mollis ullamcorper turpis, vitae facilisis velit ultricies sit amet. Etiam laoreet dui odio, id tempus justo tincidunt id. Phasellus scelerisque nunc sed nunc ultricies accumsan. Interdum et malesuada fames ac ante ipsum primis in faucibus. Sed erat diam, blandit eget felis aliquam, rhoncus varius urna. Donec tellus sapien, sodales eget ante vitae, feugiat ullamcorper urna. Praesent auctor dui vitae dapibus eleifend. Proin viverra mollis neque, ut ullamcorper elit posuere eget. Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna. Maecenas ornare arcu at mi suscipit, non molestie tortor ultrices. Aenean convallis, diam et congue ultricies, erat magna tincidunt orci, pulvinar posuere mi sapien ac magna. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Praesent vitae placerat mauris. Nullam laoreet ante posuere tortor blandit auctor. Sed id ligula volutpat leo consequat placerat. Mauris fermentum dolor sed augue malesuada sollicitudin. Vivamus ultrices nunc felis, quis viverra orci eleifend ut. Donec et quam id urna cursus posuere. Donec elementum scelerisque laoreet. ","date":"0001-01-01","objectID":"/elements/:3:0","tags":null,"title":"","uri":"/elements/"},{"categories":null,"content":"List Types ","date":"0001-01-01","objectID":"/elements/:4:0","tags":null,"title":"","uri":"/elements/"},{"categories":null,"content":"Definition List (dl) Definition List TitleThis is a definition list division. ","date":"0001-01-01","objectID":"/elements/:4:1","tags":null,"title":"","uri":"/elements/"},{"categories":null,"content":"Ordered List (ol) List Item 1 List Item 2 List Item 3 ","date":"0001-01-01","objectID":"/elements/:4:2","tags":null,"title":"","uri":"/elements/"},{"categories":null,"content":"Unordered List (ul) List Item 1 List Item 2 List Item 3 ","date":"0001-01-01","objectID":"/elements/:4:3","tags":null,"title":"","uri":"/elements/"},{"categories":null,"content":"Checkbox List (ul) List Item 1 unchecked List Item 2 checked List Item 3 checked ","date":"0001-01-01","objectID":"/elements/:4:4","tags":null,"title":"","uri":"/elements/"},{"categories":null,"content":"Table Table Header 1 Table Header 2 Table Header 3 Division 1 Division 2 Division 3 Division 1 Division 2 Division 3 Division 1 Division 2 Division 3 ","date":"0001-01-01","objectID":"/elements/:5:0","tags":null,"title":"","uri":"/elements/"},{"categories":null,"content":"Misc Stuff - abbr, acronym, sub, sup, kbd, etc. Lorem superscript dolor subscript amet, consectetuer adipiscing elit. Nullam dignissim convallis est. Quisque aliquam. cite. Nunc iaculis suscipit dui. Nam sit amet sem. Aliquam libero nisi, imperdiet at, tincidunt nec, gravida vehicula, nisl. Praesent mattis, massa quis luctus fermentum, turpis mi volutpat justo, eu volutpat enim diam eget metus. Maecenas ornare tortor. Donec sed tellus eget sapien fringilla nonummy. NBA Mauris a ante. Suspendisse quam sem, consequat at, commodo vitae, feugiat in, nunc. Morbi imperdiet augue quis tellus. AVE. Use Crtl + C to stop. ","date":"0001-01-01","objectID":"/elements/:6:0","tags":null,"title":"","uri":"/elements/"},{"categories":null,"content":"title: Excerpts date: 2013-12-25 00:23:23 tags: The following contents should be invisible in home/archive page. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce eget urna vitae velit eleifend interdum at ac nisi. In nec ligula lacus. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Sed eu cursus erat, ut dapibus quam. Aliquam eleifend dolor vitae libero pharetra adipiscing. Etiam adipiscing dolor a quam tempor, eu convallis nulla varius. Aliquam sollicitudin risus a porta aliquam. Ut nec velit dolor. Proin eget leo lobortis, aliquam est sed, mollis mauris. Fusce vitae leo pretium massa accumsan condimentum. Fusce malesuada gravida lectus vel vulputate. Donec bibendum porta nibh ut aliquam. Sed lorem felis, congue non fringilla eu, aliquam eu eros. Curabitur orci libero, mollis sed semper vitae, adipiscing in lectus. Aenean non egestas odio. Donec sollicitudin nisi quis lorem gravida, in pharetra mauris fringilla. Duis sit amet faucibus dolor, id aliquam neque. In egestas, odio gravida tempor dictum, mauris felis faucibus purus, sit amet commodo lacus diam vitae est. Ut ut quam eget massa semper sodales. Aenean non ipsum cursus, blandit lectus in, ornare odio. Curabitur ultrices porttitor vulputate. ","date":"0001-01-01","objectID":"/excerpts/:1:0","tags":null,"title":"","uri":"/excerpts/"},{"categories":null,"content":"title: Gallery Post date: 2013-12-25 00:16:18 photos: assets/wallpaper-2572384.jpg assets/wallpaper-2311325.jpg assets/wallpaper-878514.jpg http://placehold.it/350x150.jpg This post contains 4 photos: Widescreen wallpaper Portrait photo Dual widescreen wallpaper Small photo All photos should be displayed properly. From Wallbase.cc ","date":"0001-01-01","objectID":"/gallery-post/:0:0","tags":null,"title":"","uri":"/gallery-post/"},{"categories":null,"content":"title: Hello World date: 2013-12-24 17:49:32 tags: Welcome to Hexo! This is your very first post. Check documentation to learn how to use. ","date":"0001-01-01","objectID":"/hello-world/:1:0","tags":null,"title":"","uri":"/hello-world/"},{"categories":null,"content":"title: Images date: 2013-12-26 22:46:49 cover: https://cdn.jsdelivr.net/gh/amehime/shoka@latest/images/avatar.jpg This is a image test post. ","date":"0001-01-01","objectID":"/images/:1:0","tags":null,"title":"","uri":"/images/"},{"categories":null,"content":"date: 2013-12-24 23:44:13 link: http://www.google.com/ This is a link post without a title. The title should be the link with or without protocol. Clicking on the link should open Google in a new tab or window. ","date":"0001-01-01","objectID":"/link-post-without-title/:1:0","tags":null,"title":"","uri":"/link-post-without-title/"},{"categories":null,"content":"title: Link Post date: 2013-12-24 23:30:04 link: http://www.google.com/ This is a link post. Clicking on the link should open Google in a new tab or window. ","date":"0001-01-01","objectID":"/link-post/:1:0","tags":null,"title":"","uri":"/link-post/"},{"categories":null,"content":"title: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam justo turpis, tincidunt ac convallis id. date: 2013-12-24 23:31:06 tags: This post has a long title. Make sure the title displayed right. ","date":"0001-01-01","objectID":"/long-title/:1:0","tags":null,"title":"","uri":"/long-title/"},{"categories":null,"content":"title: Markdown Style test date: 2018-7-24 23:31:06 tags: This post is originated from here and is used for testing markdown style. This post contains nearly every markdown usage. Make sure all the markdown elements below show up correctly. ","date":"0001-01-01","objectID":"/markdown/:1:0","tags":null,"title":"","uri":"/markdown/"},{"categories":null,"content":"Headers # H1 ## H2 ### H3 #### H4 ##### H5 ###### H6 Alternatively, for H1 and H2, an underline-ish style: Alt-H1 ====== Alt-H2 ------ H1 ","date":"0001-01-01","objectID":"/markdown/:2:0","tags":null,"title":"","uri":"/markdown/"},{"categories":null,"content":"H2 ","date":"0001-01-01","objectID":"/markdown/:3:0","tags":null,"title":"","uri":"/markdown/"},{"categories":null,"content":"H3 H4 H5 H6 Alternatively, for H1 and H2, an underline-ish style: Alt-H1 ","date":"0001-01-01","objectID":"/markdown/:3:1","tags":null,"title":"","uri":"/markdown/"},{"categories":null,"content":"Alt-H2 ","date":"0001-01-01","objectID":"/markdown/:4:0","tags":null,"title":"","uri":"/markdown/"},{"categories":null,"content":"Emphasis Emphasis, aka italics, with *asterisks* or _underscores_. Strong emphasis, aka bold, with **asterisks** or __underscores__. Combined emphasis with **asterisks and _underscores_**. Strikethrough uses two tildes. ~~Scratch this.~~ Emphasis, aka italics, with asterisks or underscores. Strong emphasis, aka bold, with asterisks or underscores. Combined emphasis with asterisks and underscores. Strikethrough uses two tildes. Scratch this. ","date":"0001-01-01","objectID":"/markdown/:5:0","tags":null,"title":"","uri":"/markdown/"},{"categories":null,"content":"Lists 1. First ordered list item 2. Another item * Unordered sub-list. 1. Actual numbers don't matter, just that it's a number 1. Ordered sub-list 4. And another item. You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown). To have a line break without a paragraph, you will need to use two trailing spaces. Note that this line is separate, but within the same paragraph. (This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.) * Unordered list can use asterisks - Or minuses + Or pluses - Paragraph In unordered list For example like this. Common Paragraph with some text. And more text. First ordered list item Another item Unordered sub-list. Actual numbers don’t matter, just that it’s a number Ordered sub-list And another item. You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we’ll use three here to also align the raw Markdown). To have a line break without a paragraph, you will need to use two trailing spaces. Note that this line is separate, but within the same paragraph. (This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.) Unordered list can use asterisks Or minuses Or pluses Paragraph In unordered list For example like this. Common Paragraph with some text. And more text. ","date":"0001-01-01","objectID":"/markdown/:6:0","tags":null,"title":"","uri":"/markdown/"},{"categories":null,"content":"Inline HTML \u003cp\u003eTo reboot your computer, press \u003ckbd\u003ectrl\u003c/kbd\u003e+\u003ckbd\u003ealt\u003c/kbd\u003e+\u003ckbd\u003edel\u003c/kbd\u003e.\u003c/p\u003e To reboot your computer, press ctrl+alt+del. \u003cdl\u003e \u003cdt\u003eDefinition list\u003c/dt\u003e \u003cdd\u003eIs something people use sometimes.\u003c/dd\u003e \u003cdt\u003eMarkdown in HTML\u003c/dt\u003e \u003cdd\u003eDoes *not* work **very** well. Use HTML \u003cem\u003etags\u003c/em\u003e.\u003c/dd\u003e \u003c/dl\u003e Definition list Is something people use sometimes. \u003cdt\u003eMarkdown in HTML\u003c/dt\u003e \u003cdd\u003eDoes *not* work **very** well. Use HTML \u003cem\u003etags\u003c/em\u003e.\u003c/dd\u003e ","date":"0001-01-01","objectID":"/markdown/:7:0","tags":null,"title":"","uri":"/markdown/"},{"categories":null,"content":"Links [I'm an inline-style link](https://www.google.com) [I'm an inline-style link with title](https://www.google.com \"Google's Homepage\") [I'm a reference-style link][Arbitrary case-insensitive reference text] [I'm a relative reference to a repository file](../blob/master/LICENSE) [You can use numbers for reference-style link definitions][1] Or leave it empty and use the [link text itself] Some text to show that the reference links can follow later. [arbitrary case-insensitive reference text]: https://hexo.io [1]: https://hexo.io/docs/ [link text itself]: https://hexo.io/api/ I’m an inline-style link I’m an inline-style link with title I’m a reference-style link I’m a relative reference to a repository file You can use numbers for reference-style link definitions Or leave it empty and use the link text itself Some text to show that the reference links can follow later. ","date":"0001-01-01","objectID":"/markdown/:8:0","tags":null,"title":"","uri":"/markdown/"},{"categories":null,"content":"Images hover to see the title text: Inline-style: ![alt text](https://hexo.io/icon/favicon-196x196.png \"Logo Title Text 1\") Reference-style: ![alt text][logo] [logo]: https://hexo.io/icon/favicon-196x196.png \"Logo Title Text 2\" hover to see the title text: Inline-style: Logo Title Text 1 Reference-style: Logo Title Text 2 ","date":"0001-01-01","objectID":"/markdown/:9:0","tags":null,"title":"","uri":"/markdown/"},{"categories":null,"content":"Code and Syntax Highlighting Inline code has back-ticks around it. var s = \"JavaScript syntax highlighting\"; alert(s); s = \"Python syntax highlighting\" print s No language indicated, so no syntax highlighting. But let's throw in a \u003cb\u003etag\u003c/b\u003e. ","date":"0001-01-01","objectID":"/markdown/:10:0","tags":null,"title":"","uri":"/markdown/"},{"categories":null,"content":"Tables | |ASCII |HTML | |----------------|-------------------------------|-----------------------------| |Single backticks|`'Isn't this fun?'` |'Isn't this fun?' | |Quotes |`\"Isn't this fun?\"` |\"Isn't this fun?\" | |Dashes |`-- is en-dash, --- is em-dash`|-- is en-dash, --- is em-dash| ASCII HTML Single backticks 'Isn't this fun?' ‘Isn’t this fun?’ Quotes \"Isn't this fun?\" “Isn’t this fun?” Dashes -- is en-dash, --- is em-dash – is en-dash, — is em-dash Colons can be used to align columns. | Tables | Are | Cool | | ------------- |:-------------:| -----:| | col 3 is | right-aligned | | | col 2 is | centered | | | zebra stripes | are neat | Tables Are Cool col 3 is right-aligned col 2 is centered zebra stripes are neat The outer pipes (|) are optional, and you don’t need to make the raw Markdown line up prettily. You can also use inline Markdown. Markdown | Less | Pretty --- | --- | --- *Still* | `renders` | **nicely** 1 | 2 | 3 Markdown Less Pretty Still renders nicely 1 2 3 You can find more information about LaTeX mathematical expressions here. ","date":"0001-01-01","objectID":"/markdown/:11:0","tags":null,"title":"","uri":"/markdown/"},{"categories":null,"content":"Blockquotes Blockquotes are very handy in email to emulate reply text. This line is part of the same quote. Quote break. This is a very long line that will still be quoted properly when it wraps. Oh boy let’s keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can put Markdown into a blockquote. ","date":"0001-01-01","objectID":"/markdown/:12:0","tags":null,"title":"","uri":"/markdown/"},{"categories":null,"content":"Horizontal Rule Three or more… --- Hyphens *** Asterisks ___ Underscores Hyphens Asterisks Underscores ","date":"0001-01-01","objectID":"/markdown/:13:0","tags":null,"title":"","uri":"/markdown/"},{"categories":null,"content":"Line Breaks Here's a line for us to start with. This line is separated from the one above by two newlines, so it will be a *separate paragraph*. This line is also a separate paragraph, but... This line is only separated by a single newline, so it's a separate line in the *same paragraph*. Here’s a line for us to start with. This line is separated from the one above by two newlines, so it will be a separate paragraph. This line is also a separate paragraph, but… This line is only separated by a single newline, so it’s a separate line in the same paragraph. This is a regular paragraph. \u003ctable\u003e \u003ctr\u003e \u003ctd\u003eFoo\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e This is another regular paragraph. This is a regular paragraph. Foo This is another regular paragraph. ","date":"0001-01-01","objectID":"/markdown/:14:0","tags":null,"title":"","uri":"/markdown/"},{"categories":null,"content":"Youtube videos \u003ca href=\"https://www.youtube.com/watch?feature=player_embedded\u0026v=ARted4RniaU \" target=\"_blank\"\u003e\u003cimg src=\"https://img.youtube.com/vi/ARted4RniaU/0.jpg\" alt=\"IMAGE ALT TEXT HERE\" width=\"240\" height=\"180\" border=\"10\" /\u003e\u003c/a\u003e Pure markdown version: [![IMAGE ALT TEXT HERE](https://img.youtube.com/vi/ARted4RniaU/0.jpg)](https://www.youtube.com/watch?v=ARted4RniaU) Pure markdown version: ","date":"0001-01-01","objectID":"/markdown/:15:0","tags":null,"title":"","uri":"/markdown/"},{"categories":null,"content":"date: 2013-12-25 22:57:49 tags: This post doesn’t have a title. Make sure it’s accessible. ","date":"0001-01-01","objectID":"/no-title/:1:0","tags":null,"title":"","uri":"/no-title/"},{"categories":null,"content":"title: Tag Plugins date: 2013-12-25 00:14:39 tags: This post is used for testing tag plugins. See docs for more info. ","date":"0001-01-01","objectID":"/tag-plugins/:1:0","tags":null,"title":"","uri":"/tag-plugins/"},{"categories":null,"content":"Block Quote ","date":"0001-01-01","objectID":"/tag-plugins/:2:0","tags":null,"title":"","uri":"/tag-plugins/"},{"categories":null,"content":"Normal blockquote Praesent diam elit, interdum ut pulvinar placerat, imperdiet at magna. ","date":"0001-01-01","objectID":"/tag-plugins/:2:1","tags":null,"title":"","uri":"/tag-plugins/"},{"categories":null,"content":"Quote from a book {% blockquote David Levithan, Wide Awake %} Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. {% endblockquote %} ","date":"0001-01-01","objectID":"/tag-plugins/:2:2","tags":null,"title":"","uri":"/tag-plugins/"},{"categories":null,"content":"Quote from Twitter {% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %} NEW: DevDocs now comes with syntax highlighting. http://devdocs.io {% endblockquote %} ","date":"0001-01-01","objectID":"/tag-plugins/:2:3","tags":null,"title":"","uri":"/tag-plugins/"},{"categories":null,"content":"Quote from an article on the web {% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %} Every interaction is both precious and an opportunity to delight. {% endblockquote %} ","date":"0001-01-01","objectID":"/tag-plugins/:2:4","tags":null,"title":"","uri":"/tag-plugins/"},{"categories":null,"content":"Code Block ","date":"0001-01-01","objectID":"/tag-plugins/:3:0","tags":null,"title":"","uri":"/tag-plugins/"},{"categories":null,"content":"Normal code block alert('Hello World!'); ","date":"0001-01-01","objectID":"/tag-plugins/:3:1","tags":null,"title":"","uri":"/tag-plugins/"},{"categories":null,"content":"With caption {% codeblock Array.map %} array.map(callback[, thisArg]) {% endcodeblock %} ","date":"0001-01-01","objectID":"/tag-plugins/:3:2","tags":null,"title":"","uri":"/tag-plugins/"},{"categories":null,"content":"With caption and URL {% codeblock .compact http://underscorejs.org/#compact Underscore.js %} .compact([0, 1, false, 2, ‘’, 3]); =\u003e [1, 2, 3] {% endcodeblock %} ","date":"0001-01-01","objectID":"/tag-plugins/:3:3","tags":null,"title":"","uri":"/tag-plugins/"},{"categories":null,"content":"With marked lines Line 1,7-8,10 should be marked with different color. {% codeblock lang:js mark:1,7-8,10 %} const http = require(‘http’); const hostname = ‘127.0.0.1’; const port = 1337; http.createServer((req, res) =\u003e { res.writeHead(200, { ‘Content-Type’: ’text/plain’ }); res.end(‘Hello World\\n’); }).listen(port, hostname, () =\u003e { console.log(Server running at http://${hostname}:${port}/); }); {% endcodeblock %} Note: Theme’s style should support .highlight.line.marked (recommend to use the selection or current line color). ","date":"0001-01-01","objectID":"/tag-plugins/:3:4","tags":null,"title":"","uri":"/tag-plugins/"},{"categories":null,"content":"Gist {% gist 996818 %} ","date":"0001-01-01","objectID":"/tag-plugins/:3:5","tags":null,"title":"","uri":"/tag-plugins/"},{"categories":null,"content":"jsFiddle {% jsfiddle ccWP7 %} ","date":"0001-01-01","objectID":"/tag-plugins/:3:6","tags":null,"title":"","uri":"/tag-plugins/"},{"categories":null,"content":"Pullquote ","date":"0001-01-01","objectID":"/tag-plugins/:4:0","tags":null,"title":"","uri":"/tag-plugins/"},{"categories":null,"content":"Left {% pullquote left %} Lorem ipsum dolor sit amet, consectetur adipiscing elit. {% endpullquote %} Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas tempus molestie arcu, et fringilla mauris placerat ac. Nullam luctus bibendum risus. Ut cursus sed ipsum feugiat egestas. Suspendisse elementum, velit eu consequat consequat, augue lorem dapibus libero, eget pulvinar dolor est sit amet nulla. Suspendisse a porta tortor, et posuere mi. Pellentesque ultricies, mi quis volutpat malesuada, erat felis vulputate nisl, ac congue ante tortor ut ante. Proin aliquam sem vel mauris tincidunt, eget scelerisque tortor euismod. Nulla tincidunt enim nec commodo dictum. Mauris id sapien et orci gravida luctus id ut dui. In vel vulputate odio. Duis vel turpis molestie, scelerisque enim eu, lobortis eros. Cras at ipsum gravida, sagittis ante vel, viverra tellus. Nunc mauris turpis, elementum ullamcorper nisl pretium, ultrices cursus justo. Mauris porttitor commodo eros, ac ornare orci interdum in. Cras fermentum cursus leo sed mattis. In dignissim lorem sem, sit amet elementum mauris venenatis ac. ","date":"0001-01-01","objectID":"/tag-plugins/:4:1","tags":null,"title":"","uri":"/tag-plugins/"},{"categories":null,"content":"Right {% pullquote right %} Lorem ipsum dolor sit amet, consectetur adipiscing elit. {% endpullquote %} Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ligula justo, lobortis sit amet semper vel, dignissim sit amet libero. Praesent ac tempus ligula. Maecenas at gravida odio. Etiam tristique volutpat lacus eu faucibus. Donec non tempus arcu. Phasellus adipiscing, mauris nec mollis egestas, ipsum nunc auctor velit, et rhoncus lorem ipsum at ante. Praesent et sem in velit volutpat auctor. Duis vel mauris nulla. Maecenas mattis interdum ante, quis sagittis nibh cursus et. Nulla facilisi. Morbi convallis gravida tortor, ut fermentum enim gravida et. Nunc vel dictum nisl, non ultrices libero. Proin vestibulum felis eget orci consectetur lobortis. Vestibulum augue nulla, iaculis vitae augue vehicula, dignissim ultrices libero. Sed imperdiet urna et quam ultrices tincidunt nec ac magna. Etiam vel pharetra elit. ","date":"0001-01-01","objectID":"/tag-plugins/:4:2","tags":null,"title":"","uri":"/tag-plugins/"},{"categories":null,"content":"title: Tags date: 2013-12-24 23:29:53 tags: This post contains 3 tags. Make sure your theme can display all of the tags. ","date":"0001-01-01","objectID":"/tags/:1:0","tags":null,"title":"","uri":"/tags/"},{"categories":null,"content":"title: Videos date: 2013-12-25 00:19:15 tags: This is a video test post. Youtube {% youtube TIbZDRXM-Tg %} Vimeo {% vimeo 82090131 %} ","date":"0001-01-01","objectID":"/videos/:1:0","tags":null,"title":"","uri":"/videos/"},{"categories":null,"content":"title: 中文測試 date: 2013-12-24 23:31:30 tags: This is a Chinese test post. 善我王上魚、產生資西員合兒臉趣論。畫衣生這著爸毛親可時，安程幾？合學作。觀經而作建。都非子作這！法如言子你關！手師也。 以也座論頭室業放。要車時地變此親不老高小是統習直麼調未，行年香一？ 就竟在，是我童示讓利分和異種百路關母信過明驗有個歷洋中前合著區亮風值新底車有正結，進快保的行戰從：弟除文辦條國備當來際年每小腳識世可的的外的廣下歌洲保輪市果底天影；全氣具些回童但倒影發狀在示，數上學大法很，如要我……月品大供這起服滿老？應學傳者國：山式排只不之然清同關；細車是！停屋常間又，資畫領生，相們制在？公別的人寫教資夠。資再我我！只臉夫藝量不路政吃息緊回力之；兒足灣電空時局我怎初安。意今一子區首者微陸現際安除發連由子由而走學體區園我車當會，經時取頭，嚴了新科同？很夫營動通打，出和導一樂，查旅他。坐是收外子發物北看蘭戰坐車身做可來。道就學務。 國新故。 工步他始能詩的，裝進分星海演意學值例道……於財型目古香亮自和這乎？化經溫詩。只賽嚴大一主價世哥受的沒有中年即病行金拉麼河。主小路了種就小為廣不？ From 亂數假文產生器 - Chinese Lorem Ipsum ","date":"0001-01-01","objectID":"/%E4%B8%AD%E6%96%87%E6%B8%AC%E8%A9%A6/:1:0","tags":null,"title":"","uri":"/%E4%B8%AD%E6%96%87%E6%B8%AC%E8%A9%A6/"},{"categories":null,"content":"title: 日本語テスト date: 2013-12-24 23:33:26 tags: This is a Japanese test post. 私は昨日ついにその助力家というのの上よりするたなけれ。 最も今をお話団はちょうどこの前後なかろでくらいに困りがいるたをは帰着考えたなかって、そうにもするでうたらない。 がたを知っないはずも同時に九月をいよいよたありた。 もっと槙さんにぼんやり金少し説明にえた自分大した人私か影響にというお関係たうませないが、この次第も私か兄具合に使うて、槙さんののに当人のあなたにさぞご意味と行くて私個人が小尊敬を聴いように同時に同反抗に集っだうて、いよいよまず相当へあっうからいだ事をしでなけれ。 それでそれでもご時日をしはずはたったいやと突き抜けるますて、その元がは行ったてという獄を尽すていけですた。 この中道具の日その学校はあなたごろがすまなりかとネルソンさんの考えるですん、辺の事実ないというご盲従ありたですと、爺さんのためが薬缶が結果までの箸の当時してならて、多少の十月にためからそういう上からとにかくしましないと触れべきものたで、ないうですと多少お人達したのでたた。 From すぐ使えるダミーテキスト - 日本語 Lorem ipsum ","date":"0001-01-01","objectID":"/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%83%86%E3%82%B9%E3%83%88/:1:0","tags":null,"title":"","uri":"/%E6%97%A5%E6%9C%AC%E8%AA%9E%E3%83%86%E3%82%B9%E3%83%88/"},{"categories":["Docker"],"content":"python官方镜像地址： http://hub.docker.com/_/python 拉取官方的python镜像 docker pull python:3.7-alpine 交互式方式生成一个python容器 docker run -it --name python37 --rm python:3.7-alpine /bin/sh 进入交互式容器，查看当前python版本 python --version 设置pip的阿里云镜像源 mkdir $HOME/.pip/ tee $HOME/.pip/pip.conf \u003c\u003c-'EOF' [global] trusted-host=mirrors.aliyun.com index-url=https://mirrors.aliyun.com/pypi/simple EOF 确认一下是否配置成功 cat $HOME/.pip/pip.conf 我们的python使用的是alpine系统 alpine使用的是apk包管理器 命令如： apk add apk update apk del alpine默认的镜像源也比较慢，我们也换成国内的 设置alpine镜像源 echo http://mirrors.ustc.edu.cn/alpine/v3.7/main \u003e /etc/apk/repositories echo http://mirrors.ustc.edu.cn/alpine/v3.7/community \u003e\u003e /etc/apk/repositories 设置后要执行 apk update \u0026\u0026 apk upgrade 安装flask python -m pip install -U flask 编写test.py from flask import Flask app = Flask(__name__) @app.route('/') def hello(): return 'Hello World!' @app.route('/abc') def abc(): return 'Hello abc' if __name__ == '__main__': app.run() ","date":"0001-01-01","objectID":"/%E8%BD%AC%E8%BD%BD%E5%9F%BA%E4%BA%8Ealpine%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84flask%E9%95%9C%E5%83%8F/:0:0","tags":["alpine","flask","Python","docker"],"title":"【转载】基于alpine镜像构建自己的flask镜像","uri":"/%E8%BD%AC%E8%BD%BD%E5%9F%BA%E4%BA%8Ealpine%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84flask%E9%95%9C%E5%83%8F/"},{"categories":["Docker"],"content":"第一种执行这个py文件方式 python test.py 然后在另一个终端以交互式方式进入这个python容器 docker exec -it python37 /bin/sh 下载curl命令 apk add curl 使用curl访问flask服务 curl localhost:5000 curl localhost:5000/abc ","date":"0001-01-01","objectID":"/%E8%BD%AC%E8%BD%BD%E5%9F%BA%E4%BA%8Ealpine%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84flask%E9%95%9C%E5%83%8F/:0:1","tags":["alpine","flask","Python","docker"],"title":"【转载】基于alpine镜像构建自己的flask镜像","uri":"/%E8%BD%AC%E8%BD%BD%E5%9F%BA%E4%BA%8Ealpine%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84flask%E9%95%9C%E5%83%8F/"},{"categories":["Docker"],"content":"第二种执行这个py文件的方式 # 设置环境变量 export FLASK_APP=/test.py # flask运行起来 flask run ","date":"0001-01-01","objectID":"/%E8%BD%AC%E8%BD%BD%E5%9F%BA%E4%BA%8Ealpine%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84flask%E9%95%9C%E5%83%8F/:0:2","tags":["alpine","flask","Python","docker"],"title":"【转载】基于alpine镜像构建自己的flask镜像","uri":"/%E8%BD%AC%E8%BD%BD%E5%9F%BA%E4%BA%8Ealpine%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84flask%E9%95%9C%E5%83%8F/"},{"categories":["Docker"],"content":"第三种执行这个py文件的方式 FLASK_APP=test.py flask run ","date":"0001-01-01","objectID":"/%E8%BD%AC%E8%BD%BD%E5%9F%BA%E4%BA%8Ealpine%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84flask%E9%95%9C%E5%83%8F/:0:3","tags":["alpine","flask","Python","docker"],"title":"【转载】基于alpine镜像构建自己的flask镜像","uri":"/%E8%BD%AC%E8%BD%BD%E5%9F%BA%E4%BA%8Ealpine%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84flask%E9%95%9C%E5%83%8F/"},{"categories":["Docker"],"content":"根据上面的操作步骤，我们可以来编写Dockerfile生成自己的flask镜像 ","date":"0001-01-01","objectID":"/%E8%BD%AC%E8%BD%BD%E5%9F%BA%E4%BA%8Ealpine%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84flask%E9%95%9C%E5%83%8F/:1:0","tags":["alpine","flask","Python","docker"],"title":"【转载】基于alpine镜像构建自己的flask镜像","uri":"/%E8%BD%AC%E8%BD%BD%E5%9F%BA%E4%BA%8Ealpine%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84flask%E9%95%9C%E5%83%8F/"},{"categories":["Docker"],"content":"先退出上面的交互式容器，按：ctrl+D 创建一个flask目录，并进入 mkdir flask cd flask 创建一个pip.conf文件，将pip镜像源写进去 tee pip.conf \u003c\u003c-'EOF' [global] trusted-host=mirrors.aliyun.com index-url=https://mirrors.aliyun.com/pypi/simple EOF 编写Dockerfile文件 FROM python:3.7-alpine RUN echo http://mirrors.ustc.edu.cn/alpine/v3.7/main \u003e /etc/apk/repositories \u0026\u0026 \\ echo http://mirrors.ustc.edu.cn/alpine/v3.7/community \u003e\u003e /etc/apk/repositories RUN apk update \u0026\u0026 apk upgrade RUN mkdir $HOME/.pip/ COPY ./pip.conf $HOME/.pip/ RUN pip install flask EXPOSE 5000 CMD [\"flask\", \"run\"] 执行docker build命令进行镜像构建 docker build -t myflask:1.0 . 确认是否构建成功 docker images ok！镜像构建成功！ 怎么运行？？ 创建一个myapp目录 mkdir myapp 放入上面的test.py文件 from flask import Flask app = Flask(__name__) @app.route('/') def hello(): return 'Hello World!' @app.route('/abc') def abc(): return 'Hello abc' if __name__ == '__main__': app.run() 然后通过刚刚构建的镜像生成我们的容器 docker run --name myapp --rm -d -p 8080:5000 -v ~/myapp:/app -e FLASK_APP=/app/test.py myflask:1.0 确认容器是否启动 docker ps 恩，启动了！ 但是我们无法通过外网访问服务器ip的8080端口访问到容器里面 为什么？ flash默认只允许本机访问！ 怎么办？ 停掉刚刚生成的容器 docker stop myapp 重新生成容器，指定允许ip为0.0.0.0，然外部可以访问 docker run --name myapp --rm -d -p 8080:5000 -v ~/myapp:/app -e FLASK_APP=/app/test.py myflask:1.0 flask run -h 0.0.0.0 通过外网浏览器访问 http://服务器ip:8080 ok，可以访问到flask搭建的程序了！ 原文链接：http://www.mi360.cn/articles/34 ","date":"0001-01-01","objectID":"/%E8%BD%AC%E8%BD%BD%E5%9F%BA%E4%BA%8Ealpine%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84flask%E9%95%9C%E5%83%8F/:1:1","tags":["alpine","flask","Python","docker"],"title":"【转载】基于alpine镜像构建自己的flask镜像","uri":"/%E8%BD%AC%E8%BD%BD%E5%9F%BA%E4%BA%8Ealpine%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84flask%E9%95%9C%E5%83%8F/"},{"categories":["Docker","安全"],"content":"[AWVS14 Docker](https://blog.zygd.site/go.html?u=https://blog.zygd.site/AWVS14 Docker.html) 注：如认为本破解补丁存在某些后门或转载删版权者，请勿使用！ 由于传播、利用此文所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，文章作者不为此承担任何责任。 XRSec 拥有对此文章的修改和解释权如欲转载或传播此文章，必须保证此文章的完整性，包括版权声明等全部内容。未经作者允许，不得任意修改或者增减此文章内容，不得以任何方式将其用于商业目的 ","date":"0001-01-01","objectID":"/awvs%E6%89%AB%E6%8F%8F%E5%99%A8%E7%9A%84%E9%83%A8%E7%BD%B2/:1:0","tags":["Docker","AWVS","安全"],"title":"AWVS扫描器的部署","uri":"/awvs%E6%89%AB%E6%8F%8F%E5%99%A8%E7%9A%84%E9%83%A8%E7%BD%B2/"},{"categories":["Docker","安全"],"content":"INFO Version 14 build 14.3.210628104 for Windows, Linux and macOS – 28th June 2021 Updates Target Knowledgebase will be reset when Target Settings are changed Updated SSL/TLS Certificate expiry threshold notification from 30 days to 60 days Fixes Fixed: OWASP compliance report template to not be available in some Editions Fixed: Some scripts where not observing Excluded paths configured in Target settings ip:3443 awvs@awvs.com Awvs@awvs.com ","date":"0001-01-01","objectID":"/awvs%E6%89%AB%E6%8F%8F%E5%99%A8%E7%9A%84%E9%83%A8%E7%BD%B2/:1:1","tags":["Docker","AWVS","安全"],"title":"AWVS扫描器的部署","uri":"/awvs%E6%89%AB%E6%8F%8F%E5%99%A8%E7%9A%84%E9%83%A8%E7%BD%B2/"},{"categories":["Docker","安全"],"content":"Preview ","date":"0001-01-01","objectID":"/awvs%E6%89%AB%E6%8F%8F%E5%99%A8%E7%9A%84%E9%83%A8%E7%BD%B2/:1:2","tags":["Docker","AWVS","安全"],"title":"AWVS扫描器的部署","uri":"/awvs%E6%89%AB%E6%8F%8F%E5%99%A8%E7%9A%84%E9%83%A8%E7%BD%B2/"},{"categories":["Docker","安全"],"content":"Install docker run -it -d \\ --name awvs \\ -p 3443:3443 \\ xrsec/awvs:v14 # registry.cn-hangzhou.aliyuncs.com/xrsec/awvs:v14 ","date":"0001-01-01","objectID":"/awvs%E6%89%AB%E6%8F%8F%E5%99%A8%E7%9A%84%E9%83%A8%E7%BD%B2/:1:3","tags":["Docker","AWVS","安全"],"title":"AWVS扫描器的部署","uri":"/awvs%E6%89%AB%E6%8F%8F%E5%99%A8%E7%9A%84%E9%83%A8%E7%BD%B2/"},{"categories":["Docker","安全"],"content":"BuildFile Dockerfile FROM ubuntu:18.04 LABEL maintainer=\"xrsec\" LABEL mail=\"troy@zygd.site\" RUN mkdir /awvs COPY awvs.sh /awvs COPY Dockerfile /awvs COPY xaa /awvs COPY xab /awvs COPY xac /awvs COPY xad /awvs COPY xae /awvs COPY xaf /awvs COPY awvs_listen.zip /awvs # init # RUN cp /etc/apt/sources.list /etc/apt/sources.list.bak \\ # \u0026\u0026 sed -i \"s/archive.ubuntu/mirrors.aliyun/g\" /etc/apt/sources.list \\ # \u0026\u0026 sed -i \"s/security.ubuntu/mirrors.aliyun/g\" /etc/apt/sources.list \\ # \u0026\u0026 apt update -y \\ RUN apt update -y \\ \u0026\u0026 apt upgrade -y \\ \u0026\u0026 apt-get install wget libxdamage1 libgtk-3-0 libasound2 libnss3 libxss1 libx11-xcb-dev sudo libgbm-dev curl ncurses-bin unzip -y # \u0026\u0026 apt-get install wget libxdamage1 libgtk-3-0 libasound2 libnss3 libxss1 libx11-xcb-dev sudo libgbm-dev curl ncurses-bin unzip -y \\ # \u0026\u0026 mv /etc/apt/sources.list.bak /etc/apt/sources.list # init_install RUN cat /awvs/xaa /awvs/xab /awvs/xac /awvs/xad /awvs/xae /awvs/xaf \u003e /awvs/awvs_x86.sh \\ \u0026\u0026 chmod 777 /awvs/awvs_x86.sh \\ \u0026\u0026 sed -i \"s/read -r dummy/#read -r dummy/g\" /awvs/awvs_x86.sh \\ \u0026\u0026 sed -i \"s/pager=\\\"more\\\"/pager=\\\"cat\\\"/g\" /awvs/awvs_x86.sh \\ \u0026\u0026 sed -i \"s/read -r ans/ans=yes/g\" /awvs/awvs_x86.sh \\ \u0026\u0026 sed -i \"s/read -p \\\" Hostname \\[\\$host_name\\]:\\\" hn/hn=awvs/g\" /awvs/awvs_x86.sh \\ \u0026\u0026 sed -i \"s/host_name=\\$(hostname)/host_name=awvs/g\" /awvs/awvs_x86.sh \\ \u0026\u0026 sed -i \"s/read -p \\\" Hostname \\[\\$host_name\\]:\\\" hn/awvs/g\" /awvs/awvs_x86.sh \\ \u0026\u0026 sed -i \"s/read -p ' Email: ' master_user/master_user=awvs@awvs.com/g\" /awvs/awvs_x86.sh \\ \u0026\u0026 sed -i \"s/read -sp ' Password: ' master_password/master_password=Awvs@awvs.com/g\" /awvs/awvs_x86.sh \\ \u0026\u0026 sed -i \"s/read -sp ' Password again: ' master_password2/master_password2=Awvs@awvs.com/g\" /awvs/awvs_x86.sh \\ \u0026\u0026 sed -i \"s/systemctl/\\# systemctl/g\" /awvs/awvs_x86.sh \\ \u0026\u0026 /bin/bash /awvs/awvs_x86.sh # init_listen RUN chmod 777 /awvs/awvs.sh \\ \u0026\u0026 unzip -d /awvs/awvs_listen /awvs/awvs_listen.zip \\ \u0026\u0026 chmod 444 /awvs/awvs_listen/license_info.json \\ \u0026\u0026 cp /awvs/awvs_listen/wvsc /home/acunetix/.acunetix/v_210628104/scanner/ \\ \u0026\u0026 cp /awvs/awvs_listen/license_info.json /home/acunetix/.acunetix/data/license/ \\ \u0026\u0026 cp /awvs/awvs_listen/wa_data.dat /home/acunetix/.acunetix/data/license/ \\ \u0026\u0026 chown acunetix:acunetix /home/acunetix/.acunetix/data/license/wa_data.dat ENTRYPOINT [ \"/awvs/awvs.sh\"] EXPOSE 3443 # ENV TZ='Asia/Shanghai' # ENV LANG 'zh_CN.UTF-8' STOPSIGNAL SIGQUIT CMD [\"/awvs/awvs.sh\"] awvs.sh #!/bin/bash clear echo -e \"\\033[1;31m ______ _ _ _ \\033[0m\" echo -e \"\\033[1;32m | ____| | | | | (_) \\033[0m\" echo -e \"\\033[1;33m | |__ __ _ | |__| | __ _ _ \\033[0m\" echo -e \"\\033[1;34m | __| / _\\` | | __ | / _\\` | | | \\033[0m\" echo -e \"\\033[1;35m | | | (_| | | | | | | (_| | | | \\033[0m\" echo -e \"\\033[1;36m |_| \\__,_| |_| |_| \\__,_| |_| \\033[0m\" echo -e \"\\033[1;34m -------------- \\033[0m\" echo -e \"\\033[1;31m __ __ ____ \\033[0m\" echo -e \"\\033[1;32m \\ \\/ / | _ \\ ___ ___ ___ \\033[0m\" echo -e \"\\033[1;33m \\ / | |_) | / __| / _ \\ / __| \\033[0m\" echo -e \"\\033[1;34m / \\ | _ \u003c \\__ \\ | __/ | (__ \\033[0m\" echo -e \"\\033[1;35m /_/\\_\\ |_| \\_\\ |___/ \\___| \\___| \\n\\033[0m\" echo -e \"\\033[1;31m Thank's fahai \u0026\u0026 TimeLine Sec \\n\\033[0m\" echo -e \"\\033[1;32m [ help ] \\033[0m\" echo -e \"\\033[1;35m [ https://www.fahai.org/index.php/archives/128/ ] \\033[0m\" echo -e \"\\033[1;33m [ https://blog.zygd.site/AWVS14%20Docker.html ] \\n\\033[0m\" su -l acunetix -c /home/acunetix/.acunetix/start.sh awvs_x86.sh https://www.fahai.org/index.php/archives/128/ 转载自–（进入查看博主此文的更新版本） [https://blog.zygd.site/AWVS14 Docker.html](https://blog.zygd.site/go.html?u=https://blog.zygd.site/AWVS14 Docker.html) 版权声明: 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明来自 XR-SEC！ ","date":"0001-01-01","objectID":"/awvs%E6%89%AB%E6%8F%8F%E5%99%A8%E7%9A%84%E9%83%A8%E7%BD%B2/:1:4","tags":["Docker","AWVS","安全"],"title":"AWVS扫描器的部署","uri":"/awvs%E6%89%AB%E6%8F%8F%E5%99%A8%E7%9A%84%E9%83%A8%E7%BD%B2/"},{"categories":["Linux"],"content":"curl: 56 Recv failure: 连接被对方重设 curl56 Recv failure: Connection reset by peer systemctl disable firewalld systemctl stop firewalld ","date":"0001-01-01","objectID":"/centos%E8%BF%9E%E6%8E%A5%E8%A2%AB%E5%AF%B9%E6%96%B9%E9%87%8D%E8%AE%BE%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/:0:0","tags":["centos"],"title":"CentOS“连接被对方重设”的解决方法","uri":"/centos%E8%BF%9E%E6%8E%A5%E8%A2%AB%E5%AF%B9%E6%96%B9%E9%87%8D%E8%AE%BE%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"categories":["Linux"],"content":"centos8已经发布了，下载了一个体验一下，新安装好的centos8默认网卡是没有启动的，安装好后需要先配置网络。在/etc/sysconfig/network-scripts目录下存放着网卡的配置文件，文件名称是ifcfg- 网卡名称。 一 修改配置文件 设置网络时首先打开配置文件，配置文件默认如下所示，如果使用dhcp自动获取ip，只需将ONBOOT=no修改为ONBOOT=yes即可。 ","date":"0001-01-01","objectID":"/centos8%E4%BF%AE%E6%94%B9%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/:0:0","tags":["centos"],"title":"centos8修改网络配置","uri":"/centos8%E4%BF%AE%E6%94%B9%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"},{"categories":["Linux"],"content":"网卡配置文件按默认配置 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=dhcp DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=e4987998-a4ce-4cef-96f5-a3106a97f5bf DEVICE=ens33 ONBOOT=no #如果使用dhcp分配ip的话，只需要将这里no改为yes，然后重启网络服务就行 如果需要配置静态ip，则按照以下修改方法修改 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static #将dhcp修改为stati表示使用静态ip DEFROUTE=yes IPADDR=192.168.128.129 #设置IP地址 NETMASK=255.255.255.0 #设置子网掩码 GATEWAY=192.168.128.1 #设置网关 DNS1=114.114.114.114 #设置dns IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=e4987998-a4ce-4cef-96f5-a3106a97f5bf DEVICE=ens33 ONBOOT=yes #将no改为yes 二 重启网络服务 使用nmcli c reload命令重启网络服务，网络这块算是centos8改动较大的一块了，nmcli命令的参数如下所示： [hk@localhost network-scripts]$ nmcli -h Usage: nmcli [OPTIONS] OBJECT { COMMAND | help } OPTIONS -o[verview] overview mode (hide default values) -t[erse] terse output -p[retty] pretty output -m[ode] tabular|multiline output mode -c[olors] auto|yes|no whether to use colors in output -f[ields] \u003cfield1,field2,...\u003e|all|common specify fields to output -g[et-values] \u003cfield1,field2,...\u003e|all|common shortcut for -m tabular -t -f -e[scape] yes|no escape columns separators in values -a[sk] ask for missing parameters -s[how-secrets] allow displaying passwords -w[ait] \u003cseconds\u003e set timeout waiting for finishing operations -v[ersion] show program version -h[elp] print this help OBJECT g[eneral] NetworkManager's general status and operations n[etworking] overall networking control r[adio] NetworkManager radio switches c[onnection] NetworkManager's connections # 网络管理一般使用 nmcli c d[evice] devices managed by NetworkManager a[gent] NetworkManager secret agent or polkit agent m[onitor] monitor NetworkManager changes [hk@localhost network-scripts]$ 网络管理一般使用 nmcli c，用法如下： [hk@localhost network-scripts]$ nmcli c -h Usage: nmcli connection { COMMAND | help } COMMAND := { show | up | down | add | modify | clone | edit | delete | monitor | reload | load | import | export } show [--active] [--order \u003corder spec\u003e] show [--active] [id | uuid | path | apath] \u003cID\u003e ... up [[id | uuid | path] \u003cID\u003e] [ifname \u003cifname\u003e] [ap \u003cBSSID\u003e] [passwd-file \u003cfile with passwords\u003e] down [id | uuid | path | apath] \u003cID\u003e ... add COMMON_OPTIONS TYPE_SPECIFIC_OPTIONS SLAVE_OPTIONS IP_OPTIONS [-- ([+|-]\u003csetting\u003e.\u003cproperty\u003e \u003cvalue\u003e)+] modify [--temporary] [id | uuid | path] \u003cID\u003e ([+|-]\u003csetting\u003e.\u003cproperty\u003e \u003cvalue\u003e)+ clone [--temporary] [id | uuid | path ] \u003cID\u003e \u003cnew name\u003e edit [id | uuid | path] \u003cID\u003e edit [type \u003cnew_con_type\u003e] [con-name \u003cnew_con_name\u003e] delete [id | uuid | path] \u003cID\u003e monitor [id | uuid | path] \u003cID\u003e ... reload load \u003cfilename\u003e [ \u003cfilename\u003e... ] import [--temporary] type \u003ctype\u003e file \u003cfile to import\u003e export [id | uuid | path] \u003cID\u003e [\u003coutput file\u003e] [hk@localhost network-scripts]$ ","date":"0001-01-01","objectID":"/centos8%E4%BF%AE%E6%94%B9%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/:1:0","tags":["centos"],"title":"centos8修改网络配置","uri":"/centos8%E4%BF%AE%E6%94%B9%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"},{"categories":["Linux"],"content":" dnf install util-linux-user -y yum update \u0026\u0026 yum install -y zsh git sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" chsh -s $(which zsh) sed -i '/^ZSH_THEME=/c\\ZSH_THEME=\"ys\"' ~/.zshrc source ~/.zshrc git clone https://github.com/zsh-users/zsh-syntax-highlighting $ZSH_CUSTOM/plugins/zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions git clone https://github.com/zsh-users/zsh-completions $ZSH_CUSTOM/plugins/zsh-completions [ -z \"`grep \"autoload -U compinit \u0026\u0026 compinit\" ~/.zshrc`\" ] \u0026\u0026 echo \"autoload -U compinit \u0026\u0026 compinit\" \u003e\u003e ~/.zshrc sed -i '/^plugins=/c\\plugins=(git sudo z zsh-syntax-highlighting zsh-autosuggestions zsh-completions)' ~/.zshrc source ~/.zshrc ","date":"0001-01-01","objectID":"/centos%E5%AE%89%E8%A3%85zsh%E5%8F%8A%E5%85%B6%E6%8F%92%E4%BB%B6/:0:0","tags":["centos","zsh"],"title":"centos安装zsh及其插件","uri":"/centos%E5%AE%89%E8%A3%85zsh%E5%8F%8A%E5%85%B6%E6%8F%92%E4%BB%B6/"},{"categories":["C#"],"content":"https://bbs.csdn.net/topics/392903084 private void button1_Click(object sender, EventArgs e) { string json = \"[{\\\"Groupid\\\": \\\"1\\\",\\\"groupnum\\\": \\\"9005\\\",\\\"groupname\\\": \\\"调度中心\\\",\\\"type\\\": \\\"1\\\",\\\"dnsprefix\\\": \\\"\\\",\\\"islocal\\\": \\\"1\\\",\\\"canshowall\\\": \\\"0\\\",\\\"user\\\": [],\\\"group\\\": [{\\\"Groupid\\\": \\\"54\\\",\\\"groupnum\\\": \\\"66000\\\",\\\"groupname\\\": \\\"大唐移动\\\",\\\"type\\\": \\\"0\\\",\\\"dnsprefix\\\": \\\"\\\",\\\"islocal\\\": \\\"1\\\",\\\"canshowall\\\": \\\"1\\\",\\\"user\\\": [],\\\"group\\\": [{\\\"Groupid\\\": \\\"55\\\",\\\"groupnum\\\": \\\"67000\\\",\\\"groupname\\\": \\\"大唐移动1\\\",\\\"type\\\": \\\"1\\\",\\\"dnsprefix\\\": \\\"\\\",\\\"islocal\\\": \\\"1\\\",\\\"canshowall\\\": \\\"1\\\",\\\"user\\\": [],\\\"group\\\": []}] },{\\\"Groupid\\\": \\\"66\\\",\\\"groupnum\\\": \\\"66000\\\",\\\"groupname\\\": \\\"大唐联通\\\",\\\"type\\\": \\\"0\\\",\\\"dnsprefix\\\": \\\"\\\",\\\"islocal\\\": \\\"1\\\",\\\"canshowall\\\": \\\"1\\\",\\\"user\\\": [],\\\"group\\\": [{\\\"Groupid\\\": \\\"67\\\",\\\"groupnum\\\": \\\"67000\\\",\\\"groupname\\\": \\\"大唐联通1\\\",\\\"type\\\": \\\"1\\\",\\\"dnsprefix\\\": \\\"\\\",\\\"islocal\\\": \\\"1\\\",\\\"canshowall\\\": \\\"1\\\",\\\"user\\\": [],\\\"group\\\": []}] }]},{\\\"Groupid\\\": \\\"1\\\",\\\"groupnum\\\": \\\"9005\\\",\\\"groupname\\\": \\\"调度中心\\\",\\\"type\\\": \\\"1\\\",\\\"dnsprefix\\\": \\\"\\\",\\\"islocal\\\": \\\"1\\\",\\\"canshowall\\\": \\\"0\\\",\\\"user\\\": [],\\\"group\\\": [{\\\"Groupid\\\": \\\"54\\\",\\\"groupnum\\\": \\\"66000\\\",\\\"groupname\\\": \\\"大唐移动\\\",\\\"type\\\": \\\"0\\\",\\\"dnsprefix\\\": \\\"\\\",\\\"islocal\\\": \\\"1\\\",\\\"canshowall\\\": \\\"1\\\",\\\"user\\\": [],\\\"group\\\": [{\\\"Groupid\\\": \\\"55\\\",\\\"groupnum\\\": \\\"67000\\\",\\\"groupname\\\": \\\"大唐移动1\\\",\\\"type\\\": \\\"1\\\",\\\"dnsprefix\\\": \\\"\\\",\\\"islocal\\\": \\\"1\\\",\\\"canshowall\\\": \\\"1\\\",\\\"user\\\": [],\\\"group\\\": []}] },{\\\"Groupid\\\": \\\"66\\\",\\\"groupnum\\\": \\\"66000\\\",\\\"groupname\\\": \\\"大唐联通\\\",\\\"type\\\": \\\"0\\\",\\\"dnsprefix\\\": \\\"\\\",\\\"islocal\\\": \\\"1\\\",\\\"canshowall\\\": \\\"1\\\",\\\"user\\\": [],\\\"group\\\": [{\\\"Groupid\\\": \\\"67\\\",\\\"groupnum\\\": \\\"67000\\\",\\\"groupname\\\": \\\"大唐联通1\\\",\\\"type\\\": \\\"1\\\",\\\"dnsprefix\\\": \\\"\\\",\\\"islocal\\\": \\\"1\\\",\\\"canshowall\\\": \\\"1\\\",\\\"user\\\": [],\\\"group\\\": []}] }]}]\"; TreeNode nodes = new TreeNode(\"自定义总节点名称\"); AddChild(nodes, json,\"groupname\",\"group\");//groupname替换成你的consult_mold_name，group替换成你的son就行了 treeView1.Nodes.Add(nodes); } public void AddChild(TreeNode nodes,string json,string fatherName,string sonName) { JArray array = JArray.Parse(json); var list = from obj in array.Children() select new { name=obj[fatherName],son= obj[sonName] }; foreach (var item in list) { TreeNode node = new TreeNode(item.name.ToString()); AddChild(node, item.son.ToString(),fatherName,sonName); nodes.Nodes.Add(node); } } ","date":"0001-01-01","objectID":"/csharp%E4%B8%ADfrom-select%E8%AF%AD%E6%B3%95%E5%AE%9E%E4%BE%8B/:0:0","tags":["C#"],"title":"CSharp from select语法实例","uri":"/csharp%E4%B8%ADfrom-select%E8%AF%AD%E6%B3%95%E5%AE%9E%E4%BE%8B/"},{"categories":["C#"],"content":"JSON数据 { \"accepttime\": 1600966807, \"certificate\": \"\", \"completetext\": \"\", \"completetime\": 1601010419, \"createtime\": 1600966807, \"deleteflag\": 0, \"endtimestr\": \"12:00\", \"gid\": 42, \"netbarCameraList\": [{ \"account\": \"admin\", \"address\": \"172.16.36.17\", \"cameraid\": 21, \"gid\": 42, \"name\": \"36\", \"password\": \"52358\", \"port\": 554 }], \"netbarname\": \"长沙\", \"uniacid\": 6, \"userid\": 66 } 代码： /// \u003csummary\u003e /// 绑定树形控件 /// \u003c/summary\u003e /// \u003cparam name=\"treeView\"\u003e\u003c/param\u003e /// \u003cparam name=\"strJson\"\u003e\u003c/param\u003e public void BindTreeView(TreeView treeView, string strJson) { treeView.Nodes.Clear(); if (IsJsonObject(strJson))//判断是否字典类型 { JObject jo = (JObject)JsonConvert.DeserializeObject(strJson); foreach (var item in jo) { TreeNode tree; if (item.Value.GetType() == typeof(JObject))//判断是否为字典类型 { tree = new TreeNode(item.Key);//以字典的键为节点名 AddTreeChildNode(ref tree, item.Value.ToString()); treeView.Nodes.Add(tree); } else if (item.Value.GetType() == typeof(JArray)) { tree = new TreeNode(item.Key); AddTreeChildNode(ref tree, item.Value.ToString()); treeView.Nodes.Add(tree); } else { tree = new TreeNode(item.Key + \":\" + item.Value.ToString()); treeView.Nodes.Add(tree); } } } if (IsArray(strJson))//判断是否为列表类型 { JArray ja = (JArray)JsonConvert.DeserializeObject(strJson); int i = 0; foreach (JObject item in ja) { TreeNode tree = new TreeNode(); foreach (var itemOb in item) { TreeNode treeOb; if (itemOb.Value.GetType() == typeof(JObject)) { treeOb = new TreeNode(itemOb.Key); AddTreeChildNode(ref treeOb, itemOb.Value.ToString()); tree.Nodes.Add(treeOb); } else if (itemOb.Value.GetType() == typeof(JArray)) { treeOb = new TreeNode(itemOb.Key); AddTreeChildNode(ref treeOb, itemOb.Value.ToString()); tree.Nodes.Add(treeOb); } else { treeOb = new TreeNode(itemOb.Key + \":\" + itemOb.Value.ToString()); tree.Nodes.Add(treeOb); } } treeView.Nodes.Add(tree); } } treeView.ExpandAll(); } /// \u003csummary\u003e /// 添加子节点 /// \u003c/summary\u003e /// \u003cparam name=\"parantNode\"\u003e\u003c/param\u003e /// \u003cparam name=\"value\"\u003e\u003c/param\u003e public void AddTreeChildNode(ref TreeNode parantNode, string value) { if (IsJsonObject(value)) { JObject jo = (JObject)JsonConvert.DeserializeObject(value); foreach (var item in jo) { TreeNode tree; if (item.Value.GetType() == typeof(JObject)) { tree = new TreeNode(item.Key); AddTreeChildNode(ref tree, item.Value.ToString()); parantNode.Nodes.Add(tree); } else if (item.Value.GetType() == typeof(JArray)) { tree = new TreeNode(item.Key); AddTreeChildNode(ref tree, item.Value.ToString()); parantNode.Nodes.Add(tree); } else { tree = new TreeNode(item.Key + \":\" + item.Value.ToString()); parantNode.Nodes.Add(tree); } } } if (IsArray(value)) { JArray ja = (JArray)JsonConvert.DeserializeObject(value); int i = 0; foreach (JObject item in ja) { TreeNode tree = new TreeNode(); parantNode.Nodes.Add(tree); foreach (var itemOb in item) { TreeNode treeOb; if (itemOb.Value.GetType() == typeof(JObject)) { treeOb = new TreeNode(itemOb.Key); AddTreeChildNode(ref treeOb, itemOb.Value.ToString()); tree.Nodes.Add(treeOb); } else if (itemOb.Value.GetType() == typeof(JArray)) { treeOb = new TreeNode(itemOb.Key); AddTreeChildNode(ref treeOb, itemOb.Value.ToString()); tree.Nodes.Add(treeOb); } else { treeOb = new TreeNode(itemOb.Key + \":\" + itemOb.Value.ToString()); tree.Nodes.Add(treeOb); } } } } } /// \u003csummary\u003e /// 判断是否JOjbect类型 /// \u003c/summary\u003e /// \u003cparam name=\"value\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public bool IsJsonObject(string value) { try { JObject ja = JObject.Parse(value); return true; } catch (Exception ex) { return false; } } /// \u003csummary\u003e /// 判断是否JArray类型 /// \u003c/summary\u003e /// \u003cparam name=\"value\"\u003e\u003c/param\u003e /// \u003creturns\u003e\u003c/returns\u003e public bool IsArray(string value) { try { JArray ja = JArray.Parse(value); return true; } catch (Exception ex) { return false; } } 效果： ","date":"0001-01-01","objectID":"/csharp%E4%B8%ADtreeview%E7%BB%91%E5%AE%9Ajson%E6%95%B0%E6%8D%AE/:0:0","tags":["C#"],"title":"CSharp中TreeView绑定JSON数据","uri":"/csharp%E4%B8%ADtreeview%E7%BB%91%E5%AE%9Ajson%E6%95%B0%E6%8D%AE/"},{"categories":["C#"],"content":"已测试成功的 使用到的库using System.Net.Http; static void Main(string[] args) { using var client = new HttpClient(); client.BaseAddress = new Uri(\"http://restapi.amap.com\"); //client.DefaultRequestHeaders.Add(\"User-Agent\", \"C# console program\"); client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\")); var url = \"/v3/geocode/geo?key=5d47448e3c3aceff5db10319829c5450\u0026address=长沙市芙蓉区解放西路长沙市公安局\u0026city=changsha\"; HttpResponseMessage response = await client.GetAsync(url); response.EnsureSuccessStatusCode(); var resp = await response.Content.ReadAsStringAsync(); //将json字符串解析为json对象 JObject jobj = (JObject)JsonConvert.DeserializeObject(resp); //访问json对象中的成员 string name2 = jobj[\"geocodes\"][0][\"location\"].ToString(); Console.WriteLine(name2); Console.ReadKey(); } 异步：https://blog.csdn.net/zzulishulei/article/details/77751436 ","date":"0001-01-01","objectID":"/csharp%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/:0:0","tags":["C#"],"title":"CSharp网络请求","uri":"/csharp%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"},{"categories":["Docker"],"content":"https://github.com/moby/moby/issues/17470 ","date":"0001-01-01","objectID":"/docker-run-%E4%BD%BF%E7%94%A8v%E5%8F%82%E6%95%B0%E6%97%B6%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E4%B8%8D%E5%A4%8D%E5%88%B6%E5%88%B0%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%83%85%E5%86%B5/:0:0","tags":["Docker"],"title":"Docker run 使用v参数时，容器文件不复制到宿主机的情况","uri":"/docker-run-%E4%BD%BF%E7%94%A8v%E5%8F%82%E6%95%B0%E6%97%B6%E5%AE%B9%E5%99%A8%E6%96%87%E4%BB%B6%E4%B8%8D%E5%A4%8D%E5%88%B6%E5%88%B0%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%83%85%E5%86%B5/"},{"categories":["Docker"],"content":"一、运行容器 docker run -itd --name=jupyter -v /userdatas/Sandisk/Jupyter:/home/jovyan -p 10000:8888 --restart=unless-stopped jupyter/minimal-notebook:latest 映射目录到宿主机：/userdatas/Sandisk/Jupyter 此容器的更多运行参数：https://jupyter-docker-stacks.readthedocs.io/en/latest/using/common.html#docker-options ","date":"0001-01-01","objectID":"/docker%E6%90%AD%E5%BB%BAjupyter%E6%9C%8D%E5%8A%A1/:0:1","tags":["Docker","jupyter"],"title":"Docker搭建Jupyter服务","uri":"/docker%E6%90%AD%E5%BB%BAjupyter%E6%9C%8D%E5%8A%A1/"},{"categories":["Docker"],"content":"二、修改宿主机目录权限 chown 1000:1000 /userdatas/Sandisk/Jupyter -R ","date":"0001-01-01","objectID":"/docker%E6%90%AD%E5%BB%BAjupyter%E6%9C%8D%E5%8A%A1/:0:2","tags":["Docker","jupyter"],"title":"Docker搭建Jupyter服务","uri":"/docker%E6%90%AD%E5%BB%BAjupyter%E6%9C%8D%E5%8A%A1/"},{"categories":["Docker"],"content":"三、生成密码的sha1值 在线生成https://tool.oschina.net/encrypt?type=2 ","date":"0001-01-01","objectID":"/docker%E6%90%AD%E5%BB%BAjupyter%E6%9C%8D%E5%8A%A1/:0:3","tags":["Docker","jupyter"],"title":"Docker搭建Jupyter服务","uri":"/docker%E6%90%AD%E5%BB%BAjupyter%E6%9C%8D%E5%8A%A1/"},{"categories":["Docker"],"content":"四、修改配置文件 修改之前先进入容器里执行jupyter notebook --generate-config命令，就会在宿主机/userdatas/Sandisk/Jupyter/.jupyter目录下生成jupyter_notebook_config.py文件 或者 直接touch生成该文件，文件内容如下： c.NotebookApp.password = u'sha1:第三步生成的密码sha1值' c.NotebookApp.password_required = True ","date":"0001-01-01","objectID":"/docker%E6%90%AD%E5%BB%BAjupyter%E6%9C%8D%E5%8A%A1/:0:4","tags":["Docker","jupyter"],"title":"Docker搭建Jupyter服务","uri":"/docker%E6%90%AD%E5%BB%BAjupyter%E6%9C%8D%E5%8A%A1/"},{"categories":["Docker"],"content":"最后，修改jupyter_notebook_config.py文件的权限 chown 1000:1000 jupyter_notebook_config.py ","date":"0001-01-01","objectID":"/docker%E6%90%AD%E5%BB%BAjupyter%E6%9C%8D%E5%8A%A1/:0:5","tags":["Docker","jupyter"],"title":"Docker搭建Jupyter服务","uri":"/docker%E6%90%AD%E5%BB%BAjupyter%E6%9C%8D%E5%8A%A1/"},{"categories":["Docker"],"content":"来源：https://github.com/romancin/rclonebrowser-docker ","date":"0001-01-01","objectID":"/docker%E6%90%AD%E5%BB%BArclone-webgui/:0:0","tags":["docker"],"title":"Docker搭建Rclone-WebGui","uri":"/docker%E6%90%AD%E5%BB%BArclone-webgui/"},{"categories":["Docker"],"content":"rclonebrowser-docker A repository for creating a docker container including RClone Browser with GUI interface, based on kapitainsky fork Thank you for continue developing this awesome software :) img img Donate You can invite me a beer if you want ;) This is a completely funcional Docker image with RClone Browser kapytainskyfork. Based on Alpine Linux, which provides a very small size. Tested and working on Synology and QNAP, but should work on any x86_64 devices. Thanks to @jlesage for a great base image for GUI apps. Instructions: Map any local port to 5800 for web access Map any local port to 5900 for VNC access Map a local volume to /config Storesconfigurationdata Map a local volume to /media Accessmediafiles Sample run command: docker run -d --name=rclonebrowser \\ -v /share/Container/rclonebrowser/config:/config \\ -v /share/Container/rclonebrowser/media:/media \\ -e GROUP_ID=0 -e USER_ID=0 -e TZ=Europe/Madrid \\ -p 5800:5800 \\ -p 5900:5900 \\ romancin/rclonebrowser:latest Browse to http://your-host-ip:5800 to access the RClone Browser GUI. Environment Variables To customize some properties of the container, the following environment variables can be passed via the -e parameter oneforeachvariable. Value of this parameter has the format \u003cVARIABLE_NAME\u003e=\u003cVALUE\u003e. Variable Description Default USER_ID ID of the user the application runs as. See User/Group IDs to better understand when this should be set. 1000 GROUP_ID ID of the group the application runs as. See User/Group IDs to better understand when this should be set. 1000 SUP_GROUP_IDS Comma-separated list of supplementary group IDs of the application. unset UMASK Mask that controls how file permissions are set for newly created files. The value of the mask is in octal notation. By default, this variable is not set and the default umask of 022 is used, meaning that newly created files are readable by everyone, but only writable by the owner. See the following online umask calculator: http://wintelguy.com/umask-calc.pl unset TZ [TimeZone] of the container. Timezone can also be set by mapping /etc/localtime between the host and the container. Etc/UTC KEEP_APP_RUNNING When set to 1, the application will be automatically restarted if it crashes or if user quits it. 0 APP_NICENESS Priority at which the application should run. A niceness value of -20 is the highest priority and 19 is the lowest priority. By default, niceness is not set, meaning that the default niceness of 0 is used. NOTE: A negative niceness priorityincrease requires additional permissions. In this case, the container should be run with the docker option --cap-add=SYS_NICE. unset CLEAN_TMP_DIR When set to 1, all files in the /tmp directory are delete during the container startup. 1 DISPLAY_WIDTH Width inpixels of the application’s window. 1280 DISPLAY_HEIGHT Height inpixels of the application’s window. 768 SECURE_CONNECTION When set to 1, an encrypted connection is used to access the application’s GUI eitherviawebbrowserorVNCclient. See the Security section for more details. 0 VNC_PASSWORD Password needed to connect to the application’s GUI. See the VNC Password section for more details. unset X11VNC_EXTRA_OPTS Extra options to pass to the x11vnc server running in the Docker container. WARNING: For advanced users. Do not use unless you know what you are doing. unset ENABLE_CJK_FONT When set to 1, open source computer font WenQuanYi Zen Hei is installed. This font contains a large range of Chinese/Japanese/Korean characters. 0 Data Volumes The following table describes data volumes used by the container. The mappings are set via the -v parameter. Each mapping is specified with the following format: \u003cHOST_DIR\u003e:\u003cCONTAINER_DIR\u003e[:PERMISSIONS]. Container path Permissions Description /config rw This is where the application stores its configuration, log and any files needing persistency. /media rw This is where downloaded files are stored, or where you put files in your host for uploading. Ports Here is the list of ports","date":"0001-01-01","objectID":"/docker%E6%90%AD%E5%BB%BArclone-webgui/:1:0","tags":["docker"],"title":"Docker搭建Rclone-WebGui","uri":"/docker%E6%90%AD%E5%BB%BArclone-webgui/"},{"categories":["Docker"],"content":"User/Group IDs When using data volumes (-v flags), permissions issues can occur between the host and the container. For example, the user within the container may not exists on the host. This could prevent the host from properly accessing files and folders on the shared volume. To avoid any problem, you can specify the user the application should run as. This is done by passing the user ID and group ID to the container via the USER_ID and GROUP_ID environment variables. To find the right IDs to use, issue the following command on the host, with the user owning the data volume on the host: id \u003cusername\u003e Which gives an output like this one: uid=1000(myuser) gid=1000(myuser) groups=1000(myuser),4(adm),24(cdrom),27(sudo),46(plugdev),113(lpadmin) The value of uid userID and gid groupID are the ones that you should be given the container. ","date":"0001-01-01","objectID":"/docker%E6%90%AD%E5%BB%BArclone-webgui/:1:1","tags":["docker"],"title":"Docker搭建Rclone-WebGui","uri":"/docker%E6%90%AD%E5%BB%BArclone-webgui/"},{"categories":["Docker"],"content":"Security By default, access to the application’s GUI is done over an unencrypted connection HTTPorVNC. Secure connection can be enabled via the SECURE_CONNECTION environment variable. See the Environment Variables section for more details on how to set an environment variable. When enabled, application’s GUI is performed over an HTTPs connection when accessed with a browser. All HTTP accesses are automatically redirected to HTTPs. When using a VNC client, the VNC connection is performed over SSL. Note that few VNC clients support this method. [SSVNC] is one of them. Certificates Here are the certificate files needed by the container. By default, when they are missing, self-signed certificates are generated and used. All files have PEM encoded, x509 certificates. Container Path Purpose Content /config/certs/vnc-server.pem VNC connection encryption. VNC server’s private key and certificate, bundled with any root and intermediate certificates. /config/certs/web-privkey.pem HTTPs connection encryption. Web server’s private key. /config/certs/web-fullchain.pem HTTPs connection encryption. Web server’s certificate, bundled with any root and intermediate certificates. NOTE: To prevent any certificate validity warnings/errors from the browser or VNC client, make sure to supply your own valid certificates. NOTE: Certificate files are monitored and relevant daemons are automatically restarted when changes are detected. VNC Password To restrict access to your application, a password can be specified. This can be done via two methods: By using the VNC_PASSWORD environment variable. By creating a .vncpass_clear file at the root of the /config volume. This file should contains the password in clear-text. During the container startup, content of the file is obfuscated and moved to .vncpass. The level of security provided by the VNC password depends on two things: The type of communication channel encrypted/unencrypted. How secure access to the host is. When using a VNC password, it is highly desirable to enable the secure connection to prevent sending the password in clear over an unencrypted channel. ATTENTION: Password is limited to 8 characters. This limitation comes from the Remote Framebuffer Protocol RFC (see section 7.2.2). Any characters beyhond the limit are ignored. ","date":"0001-01-01","objectID":"/docker%E6%90%AD%E5%BB%BArclone-webgui/:1:2","tags":["docker"],"title":"Docker搭建Rclone-WebGui","uri":"/docker%E6%90%AD%E5%BB%BArclone-webgui/"},{"categories":["Docker"],"content":"Shell Access To get shell access to a the running container, execute the following command: docker exec -ti CONTAINER sh Where CONTAINER is the ID or the name of the container used during its creation (e.g. crashplan-pro). ","date":"0001-01-01","objectID":"/docker%E6%90%AD%E5%BB%BArclone-webgui/:1:3","tags":["docker"],"title":"Docker搭建Rclone-WebGui","uri":"/docker%E6%90%AD%E5%BB%BArclone-webgui/"},{"categories":["Docker"],"content":"Reverse Proxy The following sections contains NGINX configuration that need to be added in order to reverse proxy to this container. A reverse proxy server can route HTTP requests based on the hostname or the URL path. Routing Based on Hostname In this scenario, each hostname is routed to a different application/container. For example, let’s say the reverse proxy server is running on the same machine as this container. The server would proxy all HTTP requests sent to rclonebrowser.domain.tld to the container at 127.0.0.1:5800. Here are the relevant configuration elements that would be added to the NGINX configuration: map $http_upgrade $connection_upgrade { default upgrade; '' close; } upstream rclonebrowser { # If the reverse proxy server is not running on the same machine as the # Docker container, use the IP of the Docker host here. # Make sure to adjust the port according to how port 5800 of the # container has been mapped on the host. server 127.0.0.1:5800; } server { [...] server_name rclonebrowser.domain.tld; location / { proxy_pass http://rclonebrowser; } location /websockify { proxy_pass http://rclonebrowser; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_read_timeout 86400; } } Routing Based on URL Path In this scenario, the hostname is the same, but different URL paths are used to route to different applications/containers. For example, let’s say the reverse proxy server is running on the same machine as this container. The server would proxy all HTTP requests for server.domain.tld/rclonebrowser to the container at 127.0.0.1:5800. Here are the relevant configuration elements that would be added to the NGINX configuration: map $http_upgrade $connection_upgrade { default upgrade; '' close; } upstream rclonebrowser { # If the reverse proxy server is not running on the same machine as the # Docker container, use the IP of the Docker host here. # Make sure to adjust the port according to how port 5800 of the # container has been mapped on the host. server 127.0.0.1:5800; } server { [...] location = /rclonebrowser {return 301 $scheme://$http_host/rclonebrowser/;} location /rclonebrowser/ { proxy_pass http://rclonebrowser/; location /rclonebrowser/websockify { proxy_pass http://rclonebrowser/websockify/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; proxy_read_timeout 86400; } } } ","date":"0001-01-01","objectID":"/docker%E6%90%AD%E5%BB%BArclone-webgui/:1:4","tags":["docker"],"title":"Docker搭建Rclone-WebGui","uri":"/docker%E6%90%AD%E5%BB%BArclone-webgui/"},{"categories":["Docker"],"content":"Support or Contact Having troubles with the container or have questions? Please [create a new issue]. ","date":"0001-01-01","objectID":"/docker%E6%90%AD%E5%BB%BArclone-webgui/:1:5","tags":["docker"],"title":"Docker搭建Rclone-WebGui","uri":"/docker%E6%90%AD%E5%BB%BArclone-webgui/"},{"categories":["Docker"],"content":"Changelog v3.0.2 09/09/2020: Updated to Alpine 3.12 and Rclone current version v3.0.0 22/03/2019: Updated to RcloneBrowser 1.8.0 version v1.0.1 22/09/2019: Updated to latest image from jlesage and added Jenkinsfile for CI ","date":"0001-01-01","objectID":"/docker%E6%90%AD%E5%BB%BArclone-webgui/:1:6","tags":["docker"],"title":"Docker搭建Rclone-WebGui","uri":"/docker%E6%90%AD%E5%BB%BArclone-webgui/"},{"categories":["Docker"],"content":"亲测可用的 docker run --name webdav -d \\ --restart=unless-stopped \\ -p 369:80 \\ -v /mnt/data_part/webdav_server:/media \\ -e USERNAME=你的账号 \\ -e PASSWORD=你的密码 \\ -e TZ=Aisa/Shanghai \\ -e UDI=1000 \\ -e GID=1000 \\ ugeek/webdav:amd64 ","date":"0001-01-01","objectID":"/docker%E6%90%AD%E5%BB%BAwebdav%E6%9C%8D%E5%8A%A1/:0:0","tags":["webdav","docker"],"title":"Docker搭建WebDAV服务","uri":"/docker%E6%90%AD%E5%BB%BAwebdav%E6%9C%8D%E5%8A%A1/"},{"categories":["Docker"],"content":"构建Dockerfile Dockerfile如下 FROM postgis/postgis:13-3.1-alpine WORKDIR /app RUN apk --update --no-cache add python3-dev libffi-dev gcc musl-dev make libevent-dev build-base py3-pip python3 \\ \u0026\u0026pip install wheel \\ \u0026\u0026pip install gevent \\ \u0026\u0026pip install --no-cache-dir flask gunicorn shapely aiohttp psycopg2 \\ \u0026\u0026apk del python3-dev libffi-dev gcc musl-dev make libevent-dev build-base COPY . . EXPOSE 8848 5432 CMD gunicorn app:app -c gunicorn.conf.py 因为构建镜像基于alpine，遇到安装上面代码中提到的python库文件错误时解放方案来源网络 alpine安装gevent成功： apk --update --no-cache add python3-dev libffi-dev gcc musl-dev make libevent-dev build-base 来源https://stackoverflow.com/a/66952652 alpine python 安装psycopg2失败的解决方案： apk add --no-cache python3 postgresql-libs \u0026\u0026 \\ apk add --no-cache --virtual .build-deps gcc python3-dev musl-dev postgresql-dev pip install psycopg2 ---no-cache-dir#不缓存安装 apk --purge del .build-deps #删掉编译库 https://www.codenong.com/46711990/ alpine python安装shapely失败的解决方案： apk --update add build-base libxslt-dev apk add --virtual .build-deps \\ --repository http://dl-cdn.alpinelinux.org/alpine/edge/testing \\ --repository http://dl-cdn.alpinelinux.org/alpine/edge/main \\ gcc libc-dev geos-dev geos \u0026\u0026 \\ runDeps=\"$(scanelf --needed --nobanner --recursive /usr/local \\ | awk '{ gsub(/,/, \"\\nso:\", $2); print \"so:\" $2 }' \\ | xargs -r apk info --installed \\ | sort -u)\" \u0026\u0026 \\ apk add --virtual .rundeps $runDeps geos-config --cflags 来源：https://serverfault.com/questions/947044/installing-shapely-on-alpine-docker alpine python 安装aiohttp失败的解决方案： RUN apk add gcc g++ libffi-dev musl-dev \\ \u0026\u0026 python -m pip install --no-cache-dir brotlipy \\ \u0026\u0026 apk del gcc g++ libffi-dev musl-dev ","date":"0001-01-01","objectID":"/docker%E9%83%A8%E7%BD%B2ip%E5%92%8C%E5%9C%B0%E5%9D%80%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%9F%9F%E5%BD%92%E5%B1%9E%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7/:1:0","tags":["Docker","Python","Flask","alpine"],"title":"Docker部署IP和地址行政区域归属查询工具","uri":"/docker%E9%83%A8%E7%BD%B2ip%E5%92%8C%E5%9C%B0%E5%9D%80%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%9F%9F%E5%BD%92%E5%B1%9E%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7/"},{"categories":["Docker"],"content":"创建镜像 第一步的Dockerfile和应用已经发布到github私有仓库Quer 下载该仓库，上传到服务器，解压并执行以下命令创建镜像 docker build -t ipquery:3.0 . ","date":"0001-01-01","objectID":"/docker%E9%83%A8%E7%BD%B2ip%E5%92%8C%E5%9C%B0%E5%9D%80%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%9F%9F%E5%BD%92%E5%B1%9E%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7/:2:0","tags":["Docker","Python","Flask","alpine"],"title":"Docker部署IP和地址行政区域归属查询工具","uri":"/docker%E9%83%A8%E7%BD%B2ip%E5%92%8C%E5%9C%B0%E5%9D%80%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%9F%9F%E5%BD%92%E5%B1%9E%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7/"},{"categories":["Docker"],"content":"运行容器 docker run -itd --name=ipquery -p 8848:8848 -p 54321:5432 -e POSTGRES_PASSWORD=password ipquery:3.0 ","date":"0001-01-01","objectID":"/docker%E9%83%A8%E7%BD%B2ip%E5%92%8C%E5%9C%B0%E5%9D%80%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%9F%9F%E5%BD%92%E5%B1%9E%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7/:3:0","tags":["Docker","Python","Flask","alpine"],"title":"Docker部署IP和地址行政区域归属查询工具","uri":"/docker%E9%83%A8%E7%BD%B2ip%E5%92%8C%E5%9C%B0%E5%9D%80%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%9F%9F%E5%BD%92%E5%B1%9E%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7/"},{"categories":["Docker"],"content":"导入数据 具体参照http://www.sirliu.top:8000/archives/81/ 数据库客户端Navicat连接postgis，新建数据库csgeo该名称已在代码中写死该名称已在py代码中写死，不可更改，并将数据库设置为地理空间数据库，具体方法见上面链接文章。 ","date":"0001-01-01","objectID":"/docker%E9%83%A8%E7%BD%B2ip%E5%92%8C%E5%9C%B0%E5%9D%80%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%9F%9F%E5%BD%92%E5%B1%9E%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7/:4:0","tags":["Docker","Python","Flask","alpine"],"title":"Docker部署IP和地址行政区域归属查询工具","uri":"/docker%E9%83%A8%E7%BD%B2ip%E5%92%8C%E5%9C%B0%E5%9D%80%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%9F%9F%E5%BD%92%E5%B1%9E%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7/"},{"categories":["Docker"],"content":"结束 ","date":"0001-01-01","objectID":"/docker%E9%83%A8%E7%BD%B2ip%E5%92%8C%E5%9C%B0%E5%9D%80%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%9F%9F%E5%BD%92%E5%B1%9E%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7/:5:0","tags":["Docker","Python","Flask","alpine"],"title":"Docker部署IP和地址行政区域归属查询工具","uri":"/docker%E9%83%A8%E7%BD%B2ip%E5%92%8C%E5%9C%B0%E5%9D%80%E8%A1%8C%E6%94%BF%E5%8C%BA%E5%9F%9F%E5%BD%92%E5%B1%9E%E6%9F%A5%E8%AF%A2%E5%B7%A5%E5%85%B7/"},{"categories":["ESXI"],"content":"参考：https://blog.51cto.com/68240021/1970732 VMWare esxi中打开端口的实现 步骤1. 新增ESXi主机的firewall配置文件 在ESXi主机的/etc/vmware/firewall目录下增加name.xml的防火墙配置文件，内容格式如下： \u003c!-- FirewallRule for yourname--\u003e #yourname将会是在shell中显示的名称 \u003cConfigRoot\u003e \u003cservice\u003e \u003cid\u003eyourname\u003c/id\u003e \u003crule id = '0000'\u003e \u003cdirection\u003einbound\u003c/direction\u003e \u003cprotocol\u003etcp\u003c/protocol\u003e \u003cporttype\u003edst\u003c/porttype\u003e \u003cport\u003e \u003cbegin\u003e1280\u003c/begin\u003e #端口 \u003cend\u003e1280\u003c/end\u003e #端口 \u003c/port\u003e \u003c/rule\u003e \u003cenabled\u003etrue\u003c/enabled\u003e \u003crequired\u003efalse\u003c/required\u003e \u003c/service\u003e \u003c/ConfigRoot\u003e 步骤2. 刷新防火墙规则 esxcli network firewall refresh 检查规则是否生效： esxcli network firewall ruleset list | grep yourname 结果看到提示yourname ,状态true即开启，说明成功： yourname true ","date":"0001-01-01","objectID":"/esxi-%E6%89%93%E5%BC%80%E7%AB%AF%E5%8F%A3/:0:0","tags":["esxi"],"title":"ESXI-打开端口","uri":"/esxi-%E6%89%93%E5%BC%80%E7%AB%AF%E5%8F%A3/"},{"categories":["ESXI"],"content":"固件下载地址： https://firmware.koolshare.cn/LEDE_X64_fw867/ 转盘~ 安装完毕后。 SSH连接输入以下命令，不然无法安装魔法插件： sed -i 's/\\tdetect_package/\\t# detect_package/g' /koolshare/scripts/ks_tar_install.sh 魔法插件下载地址 https://github.com/hq450/fancyss_history_package/tree/master/fancyss_X64 ","date":"0001-01-01","objectID":"/esxi%E5%AE%89%E8%A3%85koolshare%E8%BD%AF%E8%B7%AF%E7%94%B1%E5%B9%B6%E5%AE%89%E8%A3%85%E9%AD%94%E6%B3%95%E6%8F%92%E4%BB%B6/:0:0","tags":["esxi","koolshare"],"title":"ESXI安装KoolShare软路由并安装魔法插件","uri":"/esxi%E5%AE%89%E8%A3%85koolshare%E8%BD%AF%E8%B7%AF%E7%94%B1%E5%B9%B6%E5%AE%89%E8%A3%85%E9%AD%94%E6%B3%95%E6%8F%92%E4%BB%B6/"},{"categories":["GIS"],"content":"来源：https://gist.github.com/drmalex07/5a54fc4f1db06a66679e import json import geojson from shapely.geometry import shape o = { \"coordinates\": [[[23.314208, 37.768469], [24.039306, 37.768469], [24.039306, 38.214372], [23.314208, 38.214372], [23.314208, 37.768469]]], \"type\": \"Polygon\" } s = json.dumps(o) # Convert to geojson.geometry.Polygon g1 = geojson.loads(s) # Feed to shape() to convert to shapely.geometry.polygon.Polygon # This will invoke its __geo_interface__ (https://gist.github.com/sgillies/2217756) g2 = shape(g1) # Now it's very easy to get a WKT/WKB representation g2.wkt g2.wkb import geojson import shapely.wkt s = '''POLYGON ((23.314208 37.768469, 24.039306 37.768469, 24.039306 38.214372, 23.314208 38.214372, 23.314208 37.768469))''' # Convert to a shapely.geometry.polygon.Polygon object g1 = shapely.wkt.loads(s) g2 = geojson.Feature(geometry=g1, properties={}) g2.geometry ","date":"0001-01-01","objectID":"/geojson%E5%AF%B9%E8%B1%A1%E4%B8%8Epolygon_wkt-wkb%E5%AF%B9%E8%B1%A1mysql%E7%AD%89%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BA%92%E8%BD%AC/:0:0","tags":["MYSQL","GIS","geojson","Python"],"title":"geojson对象与polygon_wkt、wkb对象（MySQL等数据库中的对象）互转","uri":"/geojson%E5%AF%B9%E8%B1%A1%E4%B8%8Epolygon_wkt-wkb%E5%AF%B9%E8%B1%A1mysql%E7%AD%89%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%BA%92%E8%BD%AC/"},{"categories":["GIS"],"content":"转载自：https://www.jianshu.com/p/852d7ad081b3 最近做的项目需要详细了解geojson，因此查了一些资料，现在整理一份标准格式的记录，要理解本文需要首先了解json的基本知识，这里不过多展开，可以去参考w3school上的教程，简言之，json是通过键值对表示数据对象的一种格式，可以很好地表达数据，其全称为JavaScript Object Notation（JavaScript Object Notation），正如这个名称，JavaScript和json联系紧密，但是json可以应用的范围很广，不止于前端，它比XML数据更轻量、更容易解析（某种角度上说xml可以更自由地封装更多的数据）。很多编程语言都有对应的json解析库，例如Python的json库，C#的Newtonsoft.Json，Java的org.json。geojson是用json的语法表达和存储地理数据，可以说是json的子集。 例如下面就是一个点数据： { \"type\": \"FeatureCollection\", \"features\": [ {\"type\":\"Feature\", \"properties\":{}, \"geometry\":{ \"type\":\"Point\", \"coordinates\":[105.380859375,31.57853542647338] } } ] } 例子图片 （注：以下geojson的效果截图都来自geojson.io在线生成） geojson将所有的地理要素分为Point、MultiPoint、LineString、MultiLineString、Polygon、MultiPolygon、GeometryCollection。首先是将这些要素封装到单个的geometry里，然后作为一个个的Feature（也就是要素）；要素放到一个要素集合里，从树状结构来理解FeatureCollection就是根节点，表示为： { \"type\": \"FeatureCollection\", \"features\": [] } 所有地理要素放在features的列表里。 ","date":"0001-01-01","objectID":"/geojson%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0/:0:0","tags":["GIS"],"title":"GEOJSON标准格式学习","uri":"/geojson%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0/"},{"categories":["GIS"],"content":"点要素Point 点要素是最简单的，类型type对应Point，然后坐标是一个1维的数组，里面有两个元素（如果是立体的坐标就是三维x,y,z），分别为经度和纬度。properties里面可以封装各种属性，例如名称、标识颜色等等。 {\"type\":\"Feature\", \"properties\":{}, \"geometry\":{ \"type\":\"Point\", \"coordinates\":[105.380859375,31.57853542647338] } } ","date":"0001-01-01","objectID":"/geojson%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0/:0:1","tags":["GIS"],"title":"GEOJSON标准格式学习","uri":"/geojson%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0/"},{"categories":["GIS"],"content":"多点要素MultiPoint {\"type\":\"Feature\", \"properties\":{}, \"geometry\":{ \"type\":\"MultiPoint\", \"coordinates\":[[105.380859375,31.57853542647338], [105.580859375,31.52853542647338] ] } } 其核心坐标： 105.380859375,31.57853542647338 105.580859375,31.52853542647338 ","date":"0001-01-01","objectID":"/geojson%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0/:0:2","tags":["GIS"],"title":"GEOJSON标准格式学习","uri":"/geojson%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0/"},{"categories":["GIS"],"content":"线要素LineString 线要素就是指线段，记录的是线的端点坐标，可视化时会按照记录顺序联结。对于曲线（如贝塞尔曲线）目前还没有很好的表达，但是在地理数据中，曲线一般会用LineString去拟合，现实地理世界中也没有标准的曲线地理要素。 线要素的坐标coordinates里的二维数组和多点要素基本一样，区别就在type上了。 {\"type\":\"Feature\", \"properties\":{}, \"geometry\":{ \"type\":\"LineString\", \"coordinates\":[[105.6005859375,30.65681556429287], [107.95166015624999,31.98944183792288], [109.3798828125,30.031055426540206], [107.7978515625,29.935895213372444]] } } 对应的Kml表达： \u003cPlacemark\u003e \u003cExtendedData\u003e\u003c/ExtendedData\u003e \u003cLineString\u003e \u003ccoordinates\u003e108.65753173828125,34.1873818599505 108.72413635253905,34.25154099726973 108.77151489257812,34.16977214177208 108.88481140136719,34.229970811273084 \u003c/coordinates\u003e \u003c/LineString\u003e \u003c/Placemark\u003e ","date":"0001-01-01","objectID":"/geojson%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0/:0:3","tags":["GIS"],"title":"GEOJSON标准格式学习","uri":"/geojson%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0/"},{"categories":["GIS"],"content":"MultiLineString 也是一个三维数组（和多边形一样）； {\"type\":\"Feature\", \"properties\":{}, \"geometry\":{ \"type\":\"MultiLineString\", \"coordinates\": [ [ [105.6005859375,30.65681556429287], [107.95166015624999,31.98944183792288], [109.3798828125,30.031055426540206], [107.7978515625,29.935895213372444] ], [ [109.3798828125,30.031055426540206], [107.1978515625,31.235895213372444] ] ] } } ","date":"0001-01-01","objectID":"/geojson%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0/:0:4","tags":["GIS"],"title":"GEOJSON标准格式学习","uri":"/geojson%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0/"},{"categories":["GIS"],"content":"多边形Polygon 注：单个多边形是一个3维数组，可以包含多个二维数组，这种情况和MultiPolygon效果很像。 {\"type\":\"Feature\", \"properties\":{}, \"geometry\":{ \"type\":\"Polygon\", \"coordinates\":[ [ [106.10595703125,33.33970700424026], [106.32568359375,32.41706632846282], [108.03955078125,32.2313896627376], [108.25927734375,33.15594830078649], [106.10595703125,33.33970700424026] ] ] } } ","date":"0001-01-01","objectID":"/geojson%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0/:0:5","tags":["GIS"],"title":"GEOJSON标准格式学习","uri":"/geojson%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0/"},{"categories":["GIS"],"content":"多多边形MultiPolygon type 1 两个不会相交的多边形 { \"type\": \"Feature\", \"properties\": {}, \"geometry\": { \"type\": \"MultiPolygon\", \"coordinates\": [ [ [ [109.2041015625,30.088107753367257], [115.02685546875,30.088107753367257], [115.02685546875,32.7872745269555], [109.2041015625,32.7872745269555], [109.2041015625,30.088107753367257] ] ], [ [ [112.9833984375,26.82407078047018], [116.69677734375,26.82407078047018], [116.69677734375,29.036960648558267], [112.9833984375,29.036960648558267], [112.9833984375,26.82407078047018] ] ] ] } } 两个不相交的多边形 type 2 两个镶套的多边形 小的在前面，范围大的在后面，用上4个中括号，但效果不是有洞的 { \"type\": \"Feature\", \"properties\": {}, \"geometry\": { \"type\": \"MultiPolygon\", \"coordinates\": [ [ [ [101.6455078125,27.68352808378776], [114.78515624999999,27.68352808378776], [114.78515624999999,35.209721645221386], [101.6455078125,35.209721645221386], [101.6455078125,27.68352808378776] ] ], [ [ [104.2822265625,30.107117887092357], [108.896484375,30.107117887092357], [108.896484375,33.76088200086917], [104.2822265625,33.76088200086917], [104.2822265625,30.107117887092357] ] ] ] } } 两个镶套的多边形 type 3 有孔洞的多边形 { \"type\": \"Feature\", \"properties\": {}, \"geometry\": { \"type\": \"MultiPolygon\", \"coordinates\": [ [ [ [101.6455078125,27.68352808378776], [114.78515624999999,27.68352808378776], [114.78515624999999,35.209721645221386], [101.6455078125,35.209721645221386], [101.6455078125,27.68352808378776] ], [ [104.2822265625,30.107117887092357], [108.896484375,30.107117887092357], [108.896484375,33.76088200086917], [104.2822265625,33.76088200086917], [104.2822265625,30.107117887092357] ] ] ] } } 有孔洞的多边形 可以仔细去品味type2和type3的区别。它们对应的kml表达区别是比较大的。 ","date":"0001-01-01","objectID":"/geojson%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0/:0:6","tags":["GIS"],"title":"GEOJSON标准格式学习","uri":"/geojson%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0/"},{"categories":["GIS"],"content":"GeometryCollection GeometryCollection是多种基本地理要素的集合，就是里面可以包含点、线、面要素。 { \"type\": \"GeometryCollection\", \"geometries\": [ { \"type\": \"Point\", \"coordinates\": [108.62, 31.02819] }, { \"type\": \"LineString\", \"coordinates\": [[108.896484375,30.1071178870], [108.2184375,30.91717870], [109.5184375,31.2175780]] }] } GeometryCollection不需要放在FeatureCollection里： { \"type\": \"FeatureCollection\", \"features\": [] } geojson里面还有其他标签表达其他的属性，如外包矩形等，其中特别重要的是坐标系统，一般里面的坐标默认为WGS84，当然也可以是其他坐标系统的坐标，但是要标识。这部分内容之后再补充了。 更具体的内容可以参考rfc7946。 欢迎关注本人公众号，有更多有趣内容和资料： ","date":"0001-01-01","objectID":"/geojson%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0/:0:7","tags":["GIS"],"title":"GEOJSON标准格式学习","uri":"/geojson%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0/"},{"categories":null,"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. ","date":"0001-01-01","objectID":"/hello-world/:0:0","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":null,"content":"Quick Start ","date":"0001-01-01","objectID":"/hello-world/:1:0","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":null,"content":"Create a new post import sqlite3 connR = sqlite3.connect(':memory:') connR.enable_load_extension(True) #now we can load the extension # depending on your OS and sqlite/spatialite version you might need to add # '.so' (Linux) or '.dll' (Windows) to the extension name #mod_spatialite (recommended) connR.execute('SELECT load_extension(\"mod_spatialite\")') connR.execute('SELECT InitSpatialMetaData(1);') # libspatialite connR.execute('SELECT load_extension(\"libspatialite\")') connR.execute('SELECT InitSpatialMetaData();') curR = connR.cursor() curR.execute('''CREATE TABLE my_line(id INTEGER PRIMARY KEY)''') curR.execute('SELECT AddGeometryColumn(\"my_line\",\"geom\" , 4326, \"LINESTRING\", 2)') connR.commit() polygon_wkt = 'POLYGON ((11 50,11 51,12 51,12 50,11 50))' XA = 11 YA = 52 XB = 12 YB = 49 line_wkt = 'LINESTRING({0} {1}, {2} {3})'.format(XA, YA, XB, YB) curR.execute(\"\"\"INSERT INTO my_line VALUES (?,GeomFromText(?, 4326))\"\"\", (1, line_wkt)) connR.commit() cursor = connR.execute(''' SELECT astext(st_intersection(geom, GeomFromText(?, 4326))) from my_line WHERE st_intersects(geom, GeomFromText(?, 4326))''', (polygon_wkt, polygon_wkt)) for item in cursor: print(item) More info: Writing ","date":"0001-01-01","objectID":"/hello-world/:1:1","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":null,"content":"Run server $ hexo server More info: Server ","date":"0001-01-01","objectID":"/hello-world/:1:2","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":null,"content":"Generate static files $ hexo generate More info: Generating ","date":"0001-01-01","objectID":"/hello-world/:1:3","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":null,"content":"Deploy to remote sites $ hexo deploy More info: Deployment ","date":"0001-01-01","objectID":"/hello-world/:1:4","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":["Theme Shoka Documentation"],"content":":::info 跳票N久终于更新的简单的使用说明 hexo-theme-shoka ：本博客自用的主题 hexo-renderer-multi-markdown-it：配套的markdown渲染器 已经支持hexo 5。。。本文档和bug不定期更新中。 如果有什么功能需求，欢迎留言。 ::: :::warning 当前版本更新至 0.2.5，更新记录点此 ::: :::primary 🚀快速开始 - 💌依赖插件 - 📌基本配置 - 🌈界面显示 - 🦄特殊功能 ::: 设计缘由 前几年在Bear和Evernote上整理了大量笔记，非常喜欢Bear默认的markdown渲染样式。 后来因为换了安卓手机，用不了Bear，四处搜寻替代品，没有满意的。 然后阴差阳错知道了Hexo，又得知Github也可以免费建私有仓库了，故再次转移阵地到了自建博客，并部署在Github Pages。 因为这个博客是用来记笔记的，故起名书架。 对应的主题即Theme.Shoka，可以说是为了笔记阅读而生的主题。 样式严重参考Bear，部分代码严重参考NexT。 Hexo的默认及常用渲染器均使用highlight.js进行代码高亮，而我喜欢Prism.js，故重写了一个渲染器配合主题食用。 渲染器取名multi，因为集成了很多很多很多markdown-it插件，以及压缩静态文件的功能。 （最新版的默认渲染器也支持Prism.js了，可喜可贺，但不想用，哈哈哈哈哈哈哈 墙内Github Pages访问速度时而感人，所以用了jsDelivr加速，主要是因为它可以按需合并依赖文件。 快速安装 # cd your-blog git clone https://github.com/amehime/hexo-theme-shoka.git ./themes/shoka 打开主题目录，内有example文件夹，提供了配置文件的demo供参考。 安装依赖插件 在应用主题之前，必须至少安装 hexo-renderer-multi-markdown-it 渲染插件 和 hexo-autoprefixer。 插件安装与配置教程戳此 应用主题 ","date":"0001-01-01","objectID":"/theme-shoka-doc/:0:0","tags":["Hexo","教程"],"title":"Hexo主题Shoka \u0026 multi-markdown-it渲染器使用说明","uri":"/theme-shoka-doc/"},{"categories":["Theme Shoka Documentation"],"content":"修改站点配置 修改站点配置文件\u003croot\u003e/_config.yml，把主题改为 shoka theme: shoka ","date":"0001-01-01","objectID":"/theme-shoka-doc/:1:0","tags":["Hexo","教程"],"title":"Hexo主题Shoka \u0026 multi-markdown-it渲染器使用说明","uri":"/theme-shoka-doc/"},{"categories":["Theme Shoka Documentation"],"content":"修改主题配置 主题配置的所有参数在\u003croot\u003e/themes/shoka/_config.yml文件中。 为了方便主题升级，请在根目录新建一个yml文件，命名为_config.shoka.yml。 也就是说，所有主题的自定义配置均保存于\u003croot\u003e/_config.shoka.yml文件。 主题的基础配置可以参考这里 界面显示相关的配置参考这里 更新记录 标签含义： ❗ 需要手动操作的更新信息 ⚠️ 需要注意的更新信息 🔧 已修复的问题 ⌛ TODO ","date":"0001-01-01","objectID":"/theme-shoka-doc/:2:0","tags":["Hexo","教程"],"title":"Hexo主题Shoka \u0026 multi-markdown-it渲染器使用说明","uri":"/theme-shoka-doc/"},{"categories":["Theme Shoka Documentation"],"content":"0.2.4 👉 0.2.5 💡 避免直接修改主题文件，添加各种自定义： 样式：包括配色、icon、其他自定义样式 图片：包括主题图片、随机图库 🔧 修复一些BUG ","date":"0001-01-01","objectID":"/theme-shoka-doc/:3:0","tags":["Hexo","教程"],"title":"Hexo主题Shoka \u0026 multi-markdown-it渲染器使用说明","uri":"/theme-shoka-doc/"},{"categories":["Theme Shoka Documentation"],"content":"0.2.3 👉 0.2.4 ⚠️ 评论功能更新 MiniValine魔改版更新至beta10，修改过主题默认_config.yml的同学，记得更新末尾的vendors到最新哦 ❗ 评论相关的配置有更新，配置戳此 主要增加的Tag配置，现在可以各种自定义啦 ⚠️ 配置新增 夜间模式darkmode，配置戳此 自动定位auto_scroll，配置戳此 图床API设置image_server，配置戳此 ⚠️ 背景音乐功能增强，配置戳此 可以添加多个播放列表 加了一些控制按钮 ⚠️ 增加media标签，在文章中插入音频和视频播放列表，方法戳此 ⌛ 视频播放器有待增强（显示分段标签，字幕） 🔧 随机图库支持非渣浪图床的任意图片 🔧 还有许多小BUG ","date":"0001-01-01","objectID":"/theme-shoka-doc/:4:0","tags":["Hexo","教程"],"title":"Hexo主题Shoka \u0026 multi-markdown-it渲染器使用说明","uri":"/theme-shoka-doc/"},{"categories":["Theme Shoka Documentation"],"content":"0.2.2 👉 0.2.3 ❗ 增加主题文件外自定义语言包的功能，配置戳此 🔧 提高低版本浏览器兼容性 ","date":"0001-01-01","objectID":"/theme-shoka-doc/:5:0","tags":["Hexo","教程"],"title":"Hexo主题Shoka \u0026 multi-markdown-it渲染器使用说明","uri":"/theme-shoka-doc/"},{"categories":["Theme Shoka Documentation"],"content":"0.2.1 👉 0.2.2 ⚠️ 弃用mediumzoom，改成fancybox，配置戳此 💡 增加语言包：繁体中文和日语 💡 quiz功能优化，根据语言显示题型标签 🔧 修复评论功能中反复初始化leancloud-storage 🔧 修复audio: false时不能隐藏播放按钮、停止播放 ","date":"0001-01-01","objectID":"/theme-shoka-doc/:6:0","tags":["Hexo","教程"],"title":"Hexo主题Shoka \u0026 multi-markdown-it渲染器使用说明","uri":"/theme-shoka-doc/"},{"categories":["Theme Shoka Documentation"],"content":"0.2 👉 0.2.1 ⚠️ 配置文件添加 loader 参数，配置戳此 💡 二级list区别显示 🔧 修复浏览位置定位BUG 🔧 修复firework动画延迟 🔧 优化评论功能 ","date":"0001-01-01","objectID":"/theme-shoka-doc/:7:0","tags":["Hexo","教程"],"title":"Hexo主题Shoka \u0026 multi-markdown-it渲染器使用说明","uri":"/theme-shoka-doc/"},{"categories":["Theme Shoka Documentation"],"content":"0.1.9 👉 0.2 ⚠️ 评论功能大改 弃用不开源的Valine，改用MiniValine，并且进行了魔改，项目戳此 主要是大量压缩了代码，弃用一些花里胡哨的功能，又加了一些别的花里胡哨的功能。 为防止泄露用户邮箱、IP等隐私信息，弃用QQ号获取昵称及头像。 ❗ 同时需要手动进行一些迁移，具体步骤戳此 ❗ 评论相关的配置亦有更新，配置戳此 ⚠️ 增加单击页面烟花效果，配置戳此 💡 弃用Velocity，改用anime.js，方便未来添加更多!!花里胡哨的!!功能!!严重拖慢页面滑行速度!! 🔧 新增多枚icon，包括豆瓣i-douban等 🔧 一些显示问题 ","date":"0001-01-01","objectID":"/theme-shoka-doc/:8:0","tags":["Hexo","教程"],"title":"Hexo主题Shoka \u0026 multi-markdown-it渲染器使用说明","uri":"/theme-shoka-doc/"},{"categories":["IP"],"content":"http://ip.bczs.net/city https://stackoverflow.com/questions/24214441/ip-range-to-cidr-conversion-in-python/42371026 # pip install netaddr import netaddr startips=[\"36.111.200.0\",\"36.157.192.0\",\"36.158.32.0\",\"36.158.46.0\",\"36.158.146.0\",\"36.158.176.0\",\"36.158.208.0\",\"36.158.216.0\",\"36.193.27.0\",\"39.134.252.0\",\"42.48.0.0\",\"42.48.16.0\",\"42.48.25.0\",\"42.48.100.0\",\"42.48.120.0\",\"42.48.142.0\",\"42.49.78.0\",\"42.49.135.0\",\"43.224.160.0\",\"43.237.24.0\",\"43.238.144.0\",\"43.242.148.0\",\"43.242.156.0\",\"43.250.200.0\",\"45.113.252.0\",\"45.116.36.0\",\"45.250.12.0\",\"49.123.64.0\",\"49.220.0.0\",\"58.20.0.0\",\"58.20.193.0\",\"58.20.199.0\",\"58.20.204.0\",\"59.43.69.0\",\"59.71.64.0\",\"59.71.100.0\",\"59.71.114.0\",\"59.71.126.0\",\"59.81.86.0\",\"61.137.0.0\",\"61.137.9.0\",\"61.137.11.0\",\"61.137.32.0\",\"61.137.39.0\",\"61.137.56.0\",\"61.137.69.0\",\"61.137.74.0\",\"61.137.79.0\",\"61.137.86.0\",\"61.137.99.0\",\"61.137.115.0\",\"61.137.120.0\",\"61.137.125.0\",\"61.150.128.0\",\"61.150.178.0\",\"61.150.229.0\",\"61.150.239.0\",\"61.186.80.0\",\"61.186.99.0\",\"61.187.0.0\",\"61.187.84.0\",\"61.187.104.0\",\"61.187.225.0\",\"61.187.255.0\",\"61.232.142.0\",\"61.232.146.0\",\"61.234.250.0\",\"61.236.64.0\",\"61.236.78.0\",\"61.237.128.0\",\"61.237.130.0\",\"61.237.136.0\",\"61.237.139.0\",\"61.237.140.0\",\"61.240.200.0\",\"61.240.204.0\",\"61.240.212.0\",\"61.240.233.0\",\"61.241.224.0\",\"101.126.128.0\",\"101.130.0.0\",\"103.22.68.0\",\"103.33.24.0\",\"103.34.144.0\",\"103.38.32.0\",\"103.38.40.0\",\"103.43.192.0\",\"103.53.204.0\",\"103.56.72.0\",\"103.73.168.0\",\"103.78.124.0\",\"103.86.32.0\",\"103.91.108.0\",\"103.92.132.0\",\"103.93.152.0\",\"103.96.216.0\",\"103.103.72.0\",\"103.109.248.0\",\"103.203.164.0\",\"103.204.236.0\",\"103.218.20.0\",\"103.246.8.0\",\"103.250.249.0\",\"106.16.0.0\",\"106.16.82.0\",\"106.16.88.0\",\"106.17.186.0\",\"106.18.128.0\",\"106.18.196.0\",\"106.18.199.0\",\"106.18.203.0\",\"106.18.232.0\",\"106.19.12.0\",\"106.19.66.0\",\"106.19.224.0\",\"110.52.10.0\",\"110.52.192.0\",\"110.53.108.0\",\"110.53.131.0\",\"110.53.133.0\",\"110.53.141.0\",\"110.53.150.0\",\"110.53.160.0\",\"110.53.176.0\",\"110.53.232.0\",\"110.53.234.0\",\"110.53.236.0\",\"110.203.0.0\",\"110.207.32.0\",\"111.8.0.0\",\"111.8.3.0\",\"111.8.17.0\",\"111.8.28.0\",\"111.8.32.0\",\"111.22.0.0\",\"111.23.0.0\",\"111.23.27.0\",\"111.23.38.0\",\"111.23.41.0\",\"111.23.44.0\",\"111.23.50.0\",\"111.23.137.0\",\"111.23.144.0\",\"111.23.159.0\",\"111.23.164.0\",\"111.23.170.0\",\"111.23.173.0\",\"111.23.181.0\",\"111.23.190.0\",\"111.23.232.0\",\"111.23.238.0\",\"111.23.243.0\",\"111.23.253.0\",\"112.33.250.0\",\"113.218.128.0\",\"113.219.192.0\",\"113.240.128.0\",\"113.246.0.0\",\"115.157.192.0\",\"115.157.240.0\",\"115.168.49.0\",\"115.168.81.0\",\"116.129.244.0\",\"116.161.0.0\",\"116.199.128.0\",\"116.199.133.0\",\"117.136.24.0\",\"117.136.88.0\",\"118.206.192.0\",\"118.249.0.0\",\"119.39.0.0\",\"119.39.146.0\",\"119.39.150.0\",\"119.39.204.0\",\"119.39.227.0\",\"119.39.248.0\",\"119.44.0.0\",\"119.44.128.0\",\"119.44.192.0\",\"119.45.48.0\",\"120.226.19.0\",\"120.226.48.0\",\"120.226.51.0\",\"120.226.64.0\",\"120.226.67.0\",\"120.226.80.0\",\"120.226.83.0\",\"120.226.99.0\",\"120.226.115.0\",\"120.226.128.0\",\"120.226.131.0\",\"120.226.147.0\",\"120.226.160.0\",\"120.226.163.0\",\"120.226.179.0\",\"120.226.195.0\",\"120.226.248.0\",\"120.227.1.0\",\"120.227.6.0\",\"120.227.10.0\",\"120.227.28.0\",\"120.227.56.0\",\"120.228.0.0\",\"120.228.128.0\",\"122.48.16.0\",\"122.72.28.0\",\"122.72.88.0\",\"122.72.123.0\",\"122.207.0.0\",\"122.207.16.0\",\"123.68.0.0\",\"123.84.252.0\",\"123.94.19.0\",\"124.232.0.0\",\"124.232.192.0\",\"124.233.20.0\",\"124.233.68.0\",\"124.233.180.0\",\"124.233.196.0\",\"124.233.208.0\",\"124.233.214.0\",\"124.233.224.0\",\"124.233.238.0\",\"125.221.160.0\",\"125.221.218.0\",\"125.221.242.0\",\"125.221.250.0\",\"159.226.147.0\",\"159.226.152.0\",\"175.0.0.0\",\"175.6.0.0\",\"175.8.0.0\",\"175.13.0.0\",\"183.169.0.0\",\"183.214.0.0\",\"183.214.10.0\",\"183.214.42.0\",\"183.214.55.0\",\"183.214.58.0\",\"183.214.63.0\",\"183.214.77.0\",\"183.214.83.0\",\"183.214.99.0\",\"183.214.107.0\",\"183.214.120.0\",\"183.214.127.0\",\"183.214.138.0\",\"183.214.139.0\",\"183.214.152.0\",\"183.214.154.0\",\"183.214.159.0\",\"183.214.161.0\",\"183.214.170.0\",\"183.214.210.0\",\"183.214.215.0\",\"183.214.235.0\",\"183.214.243.0\",\"183.214.254.0\",\"183.215.29.0\",\"183.215.64.0\",\"183.215.95","date":"0001-01-01","objectID":"/ip%E8%8C%83%E5%9B%B4%E8%BD%ACcidr/:0:0","tags":["CIDR","ip"],"title":"IP范围转CIDR","uri":"/ip%E8%8C%83%E5%9B%B4%E8%BD%ACcidr/"},{"categories":["GIS"],"content":" PostgreSQL 空间st_contains，st_within空间包含搜索优化 - 降IO和降CPUboundbox ST_Contains函数-Oracle 、 PostgreSQL 以及 SQLITE，此文有很多函数解析和应用实例 使用Sqlite和Spatialite Sqlite使用Spatial扩展的方法 linux中如何安装Spatial windows中如何安装Spatial，并在python中使用 ","date":"0001-01-01","objectID":"/mysql%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E5%A4%87%E5%BF%98%E5%BD%95/:0:0","tags":["MYSQL","GIS"],"title":"MySQL地理空间查询——备忘录","uri":"/mysql%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E5%A4%87%E5%BF%98%E5%BD%95/"},{"categories":["GIS"],"content":"Postgresql 转载自：https://blog.csdn.net/weixin_47553445/article/details/115268077 ","date":"0001-01-01","objectID":"/mysql%E6%88%96%E8%80%85postgresql%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%BA%8Emultipolygon-%E5%A4%9A%E5%A4%9A%E8%BE%B9%E5%BD%A2/:1:0","tags":["MYSQL","POSTGIS","GIS"],"title":"Mysql或者Postgresql判断一个点是否存在于MULTIPOLYGON(多多边形)","uri":"/mysql%E6%88%96%E8%80%85postgresql%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%BA%8Emultipolygon-%E5%A4%9A%E5%A4%9A%E8%BE%B9%E5%BD%A2/"},{"categories":["GIS"],"content":"语法 SELECT ST_Contains( ST_GeomFromText('这里放需要查找的MULTIPOLYGON'),st_point(103.2366313,28.81767612)) ","date":"0001-01-01","objectID":"/mysql%E6%88%96%E8%80%85postgresql%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%BA%8Emultipolygon-%E5%A4%9A%E5%A4%9A%E8%BE%B9%E5%BD%A2/:1:1","tags":["MYSQL","POSTGIS","GIS"],"title":"Mysql或者Postgresql判断一个点是否存在于MULTIPOLYGON(多多边形)","uri":"/mysql%E6%88%96%E8%80%85postgresql%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%BA%8Emultipolygon-%E5%A4%9A%E5%A4%9A%E8%BE%B9%E5%BD%A2/"},{"categories":["GIS"],"content":"demo SELECT ST_Contains( ST_GeomFromText( 'MULTIPOLYGON(((103.236631342762 28.8176761290501,103.223402196754 28.8067721559103,103.209070714842 28.8142367294416,103.180091207643 28.798947455161,103.14654213721 28.824723076309,103.130331635197 28.828001337192,103.134297395409 28.8452254641839,103.167231778324 28.8643948670295,103.176539598724 28.8840813692598,103.169919000262 28.9045950607135,103.172633909627 28.932211552721,103.146715816082 28.9448446028962,103.13471930785 28.9692321042783,103.150374074704 28.9703423083509,103.161580849577 28.9891424738461,103.15734975159 29.0005456111911,103.177684162294 29.032308821395,103.176350962327 29.0694099108388,103.160365421227 29.0944466696781,103.180453467154 29.1056188206521,103.2017136031 29.1071235950779,103.201687387863 29.0940476602714,103.191523992039 29.0799538880615,103.199963856947 29.0731856649865,103.219618568142 29.0694447325884,103.227025387212 29.0507195660552,103.259157118007 29.0312680863532,103.281320228146 28.996955444738,103.274604182837 28.9814130607642,103.25969996678 28.9740033773541,103.245668694754 28.9457143516361,103.251277767255 28.9258500057732,103.245698980324 28.915184451901,103.272321285299 28.8964177393872,103.246358179786 28.870089342749,103.228214409667 28.8654235673438,103.236631342762 28.8176761290501))) ' ),st_point(103.2366313,28.81767612)) ","date":"0001-01-01","objectID":"/mysql%E6%88%96%E8%80%85postgresql%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%BA%8Emultipolygon-%E5%A4%9A%E5%A4%9A%E8%BE%B9%E5%BD%A2/:1:2","tags":["MYSQL","POSTGIS","GIS"],"title":"Mysql或者Postgresql判断一个点是否存在于MULTIPOLYGON(多多边形)","uri":"/mysql%E6%88%96%E8%80%85postgresql%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%BA%8Emultipolygon-%E5%A4%9A%E5%A4%9A%E8%BE%B9%E5%BD%A2/"},{"categories":["GIS"],"content":"执行结果 ","date":"0001-01-01","objectID":"/mysql%E6%88%96%E8%80%85postgresql%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%BA%8Emultipolygon-%E5%A4%9A%E5%A4%9A%E8%BE%B9%E5%BD%A2/:1:3","tags":["MYSQL","POSTGIS","GIS"],"title":"Mysql或者Postgresql判断一个点是否存在于MULTIPOLYGON(多多边形)","uri":"/mysql%E6%88%96%E8%80%85postgresql%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%BA%8Emultipolygon-%E5%A4%9A%E5%A4%9A%E8%BE%B9%E5%BD%A2/"},{"categories":["GIS"],"content":"注意事项： st_point函数中,经度纬度不能是字符串类型 ST_GeomFromText函数中的MULTIPOLYGON为geom空间函数通过 sT_AsText函数转换得来，不需要二次处理。 愿大家永不脱发！！！ ","date":"0001-01-01","objectID":"/mysql%E6%88%96%E8%80%85postgresql%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%BA%8Emultipolygon-%E5%A4%9A%E5%A4%9A%E8%BE%B9%E5%BD%A2/:1:4","tags":["MYSQL","POSTGIS","GIS"],"title":"Mysql或者Postgresql判断一个点是否存在于MULTIPOLYGON(多多边形)","uri":"/mysql%E6%88%96%E8%80%85postgresql%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%BA%8Emultipolygon-%E5%A4%9A%E5%A4%9A%E8%BE%B9%E5%BD%A2/"},{"categories":["GIS"],"content":"Mysql 转载自：https://www.cnblogs.com/TTonly/p/12737780.html MySQL5.6中查询多边形包含点情况（ST_Contains、ST_Within） SET @x = 121; SET @y = 30; -- SET @point = CONCAT('POINT(',@x,' ',@y,')'); set @point= Point(@x,@y); set @geometry=ST_GeomFromText('POLYGON((121 30, 121 30, ..., 121 30, 121 30))'); SELECT ST_Contains(@geometry,@point);//面包含点 SELECT ST_Within(@point, @geometry);//点在面 https://blog.csdn.net/zshtiger2414/article/details/77975958 https://dev.mysql.com/doc/refman/5.6/en/spatial-relation-functions-object-shapes.html#function_st-overlaps ","date":"0001-01-01","objectID":"/mysql%E6%88%96%E8%80%85postgresql%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%BA%8Emultipolygon-%E5%A4%9A%E5%A4%9A%E8%BE%B9%E5%BD%A2/:2:0","tags":["MYSQL","POSTGIS","GIS"],"title":"Mysql或者Postgresql判断一个点是否存在于MULTIPOLYGON(多多边形)","uri":"/mysql%E6%88%96%E8%80%85postgresql%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%BA%8Emultipolygon-%E5%A4%9A%E5%A4%9A%E8%BE%B9%E5%BD%A2/"},{"categories":["GIS"],"content":" -- 1.创建测试表 CREATE TABLE zone ( id int(10) unsigned NOT NULL AUTO_INCREMENT, polygongeo geometry NOT NULL, PRIMARY KEY (id) ) ENGINE=MYISAM DEFAULT CHARSET=utf8; -- 2.插入多边形数据 insert into zone(polygongeo) values(ST_GeomFromText('POLYGON((1 1,1 5,5 5,5 1,1 1))')); -- 3.判断点是否在多边形区域 -- 3.1 测试 POINT(3, 4)，在多边形内 select ST_AsText(polygongeo) from zone where MBRWithin(ST_GeomFromText('POINT(3 4)'),polygongeo); -- 3.2 测试 POINT(6, 1) 在多边形外 select ST_AsText(polygongeo) from zone where MBRWithin(ST_GeomFromText('POINT(6 1)'),polygongeo); 不入库，直接测试 SELECT ST_Contains(ST_GeomFromText('MULTIPOLYGON(((103.236631342762 28.8176761290501,103.223402196754 28.8067721559103,103.209070714842 28.8142367294416,103.180091207643 28.798947455161,103.14654213721 28.824723076309,103.130331635197 28.828001337192,103.134297395409 28.8452254641839,103.167231778324 28.8643948670295,103.176539598724 28.8840813692598,103.169919000262 28.9045950607135,103.172633909627 28.932211552721,103.146715816082 28.9448446028962,103.13471930785 28.9692321042783,103.150374074704 28.9703423083509,103.161580849577 28.9891424738461,103.15734975159 29.0005456111911,103.177684162294 29.032308821395,103.176350962327 29.0694099108388,103.160365421227 29.0944466696781,103.180453467154 29.1056188206521,103.2017136031 29.1071235950779,103.201687387863 29.0940476602714,103.191523992039 29.0799538880615,103.199963856947 29.0731856649865,103.219618568142 29.0694447325884,103.227025387212 29.0507195660552,103.259157118007 29.0312680863532,103.281320228146 28.996955444738,103.274604182837 28.9814130607642,103.25969996678 28.9740033773541,103.245668694754 28.9457143516361,103.251277767255 28.9258500057732,103.245698980324 28.915184451901,103.272321285299 28.8964177393872,103.246358179786 28.870089342749,103.228214409667 28.8654235673438,103.236631342762 28.8176761290501)))'),ST_GeomFromText('POINT(103.2366313 28.81767612)')) ","date":"0001-01-01","objectID":"/mysql%E6%B5%8B%E8%AF%95%E5%88%A4%E6%96%AD%E5%A4%9A%E8%BE%B9%E5%BD%A2polygon%E5%8F%8A%E9%95%82%E7%A9%BA%E5%A4%9A%E8%BE%B9%E5%BD%A2multipolygon%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%82%B9/:0:0","tags":["MySQL","GIS"],"title":"MySQL测试判断多边形（Polygon）及镂空多边形（MultiPolygon）是否包含点","uri":"/mysql%E6%B5%8B%E8%AF%95%E5%88%A4%E6%96%AD%E5%A4%9A%E8%BE%B9%E5%BD%A2polygon%E5%8F%8A%E9%95%82%E7%A9%BA%E5%A4%9A%E8%BE%B9%E5%BD%A2multipolygon%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%82%B9/"},{"categories":["GIS"],"content":"判断点是否在镂空多边形内，直接测试 SELECT ST_Contains(ST_GeomFromText('MULTIPOLYGON(((98.9208984375 30.41078179084589,97.327880859375 28.825425374477224,98.052978515625 28.120438687101064,97.7783203125 26.303264239389534,99.151611328125 25.997549919572112,100.535888671875 26.303264239389534,101.865234375 27.235094607795503,103.095703125 26.391869671769022,103.89770507812499 27.712710260887476,103.60107421874999 28.700224692776988,101.88720703125 30.14512718337613,100.51391601562499 30.92107637538488,101.129150390625 28.9120147012556,100.0634765625 28.033197847676377,99.90966796875 29.6594160549124,98.9208984375 30.41078179084589),(101.7059326171875 28.023500048883022,102.72766113281249 28.023500048883022,102.72766113281249 28.700224692776988,101.7059326171875 28.700224692776988,101.7059326171875 28.023500048883022)))'),ST_GeomFromText('POINT(101.854248046875 29.084976575985912)')) --点1：101.854248046875 29.084976575985912 输出： 1 --点2：100.5029296875 28.969700808694157 输出： 0 --点3：103.91555786132812 27.70784710660343 输出： 0 --点4：102.26074218749999 28.372068829631633 输出： 0 上面测试中的镂空多边形geojson数据如下 {\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"properties\":{},\"geometry\":{\"type\":\"Polygon\",\"coordinates\":[[[98.9208984375,30.41078179084589],[97.327880859375,28.825425374477224],[98.052978515625,28.120438687101064],[97.7783203125,26.303264239389534],[99.151611328125,25.997549919572112],[100.535888671875,26.303264239389534],[101.865234375,27.235094607795503],[103.095703125,26.391869671769022],[103.89770507812499,27.712710260887476],[103.60107421874999,28.700224692776988],[101.88720703125,30.14512718337613],[100.51391601562499,30.92107637538488],[101.129150390625,28.9120147012556],[100.0634765625,28.033197847676377],[99.90966796875,29.6594160549124],[98.9208984375,30.41078179084589]],[[101.7059326171875,28.023500048883022],[102.72766113281249,28.023500048883022],[102.72766113281249,28.700224692776988],[101.7059326171875,28.700224692776988],[101.7059326171875,28.023500048883022]]]}}]} ","date":"0001-01-01","objectID":"/mysql%E6%B5%8B%E8%AF%95%E5%88%A4%E6%96%AD%E5%A4%9A%E8%BE%B9%E5%BD%A2polygon%E5%8F%8A%E9%95%82%E7%A9%BA%E5%A4%9A%E8%BE%B9%E5%BD%A2multipolygon%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%82%B9/:1:0","tags":["MySQL","GIS"],"title":"MySQL测试判断多边形（Polygon）及镂空多边形（MultiPolygon）是否包含点","uri":"/mysql%E6%B5%8B%E8%AF%95%E5%88%A4%E6%96%AD%E5%A4%9A%E8%BE%B9%E5%BD%A2polygon%E5%8F%8A%E9%95%82%E7%A9%BA%E5%A4%9A%E8%BE%B9%E5%BD%A2multipolygon%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%82%B9/"},{"categories":["Docker"],"content":" server { listen 80 default_server; listen [::]:80 default_server; server_name _; root /usr/share/nginx/html; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } #下面是自定义配置 端口转发 server { listen 80; server_name www.abc.com;# 这里配置我们的域名，确定域名已解析到本机 location / { proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:9000; #转发到本机9000端口 } } ","date":"0001-01-01","objectID":"/nginx-%E5%A4%9A%E5%AE%B9%E5%99%A8/:0:0","tags":["nginx","docker"],"title":"nginx 多容器","uri":"/nginx-%E5%A4%9A%E5%AE%B9%E5%99%A8/"},{"categories":["Nginx"],"content":"最近越来越频繁地遇到需要配置反向代理的场景，在自己搭建博客的时候，也不可避免要用到 Nginx，所以这段时间集中学习了一下 Nginx，同时做了一些笔记，希望也可以帮助到大家～ 😜 这篇文章会在 CentOS 环境下安装和使用 Nginx，如果对 CentOS 基本操作还不太清楚的，可以先看看 \u003c半小时搞会 CentOS 入门必备基础知识\u003e 一文先做了解。 相信作为开发者，大家都知道 Nginx 的重要，废话不多说，一起来学习吧。 CentOS 版本： 7.6 Nginx 版本： 1.16.1 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:0:0","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"1. Nginx 介绍 传统的 Web 服务器，每个客户端连接作为一个单独的进程或线程处理，需在切换任务时将 CPU 切换到新的任务并创建一个新的运行时上下文，消耗额外的内存和 CPU 时间，当并发请求增加时，服务器响应变慢，从而对性能产生负面影响。 Nginx 是开源、高性能、高可靠的 Web 和反向代理服务器，而且支持热部署，几乎可以做到 7 * 24 小时不间断运行，即使运行几个月也不需要重新启动，还能在不间断服务的情况下对软件版本进行热更新。性能是 Nginx 最重要的考量，其占用内存少、并发能力强、能支持高达 5w 个并发连接数，最重要的是，Nginx 是免费的并可以商业化，配置使用也比较简单。 Nginx 的最重要的几个使用场景： 静态资源服务，通过本地文件系统提供服务； 反向代理服务，延伸出包括缓存、负载均衡等； API 服务，OpenResty ； 对于前端来说 Node.js 不陌生了，Nginx 和 Node.js 的很多理念类似，HTTP 服务器、事件驱动、异步非阻塞等，且 Nginx 的大部分功能使用 Node.js 也可以实现，但 Nginx 和 Node.js 并不冲突，都有自己擅长的领域。Nginx 擅长于底层服务器端资源的处理（静态资源处理转发、反向代理，负载均衡等），Node.js 更擅长上层具体业务逻辑的处理，两者可以完美组合，共同助力前端开发。 下面我们着重学习一下 Nginx 的使用。 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:1:0","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"2. 相关概念 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:2:0","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"2.1 简单请求和非简单请求 首先我们来了解一下简单请求和非简单请求，如果同时满足下面两个条件，就属于简单请求： 请求方法是 HEAD、GET、POST 三种之一； HTTP 头信息不超过右边着几个字段：Accept、Accept-Language、Content-Language、Last-Event-ID Content-Type 只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain； 凡是不同时满足这两个条件的，都属于非简单请求。 浏览器处理简单请求和非简单请求的方式不一样： 简单请求 对于简单请求，浏览器会在头信息中增加 Origin 字段后直接发出，Origin 字段用来说明，本次请求来自的哪个源（协议+域名+端口）。 如果服务器发现 Origin 指定的源不在许可范围内，服务器会返回一个正常的 HTTP 回应，浏览器取到回应之后发现回应的头信息中没有包含 Access-Control-Allow-Origin 字段，就抛出一个错误给 XHR 的 error 事件； 如果服务器发现 Origin 指定的域名在许可范围内，服务器返回的响应会多出几个 Access-Control- 开头的头信息字段。 非简单请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 PUT 或 DELETE，或 Content-Type 值为 application/json。浏览器会在正式通信之前，发送一次 HTTP 预检 OPTIONS 请求，先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 请求方法和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XHR 请求，否则报错。 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:2:1","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"2.2 跨域 在浏览器上当前访问的网站向另一个网站发送请求获取数据的过程就是跨域请求。 跨域是浏览器的同源策略决定的，是一个重要的浏览器安全策略，用于限制一个 origin 的文档或者它加载的脚本与另一个源的资源进行交互，它能够帮助阻隔恶意文档，减少可能被攻击的媒介，可以使用 CORS 配置解除这个限制。 关于跨域网上已经有很多解释，这里就不啰嗦，也可以直接看 MDN 的 \u003c浏览器的同源策略\u003e 文档进一步了解，这里就列举几个同源和不同元的例子，相信程序员都能看得懂。 # 同源的例子 http://example.com/app1/index.html # 只是路径不同 http://example.com/app2/index.html http://Example.com:80 # 只是大小写差异 http://example.com # 不同源的例子 http://example.com/app1 # 协议不同 https://example.com/app2 http://example.com # host 不同 http://www.example.com http://myapp.example.com http://example.com # 端口不同 http://example.com:8080 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:2:2","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"2.3 正向代理和反向代理 反向代理（Reverse Proxy）对应的是正向代理（Forward Proxy），他们的区别： 正向代理： 一般的访问流程是客户端直接向目标服务器发送请求并获取内容，使用正向代理后，客户端改为向代理服务器发送请求，并指定目标服务器（原始服务器），然后由代理服务器和原始服务器通信，转交请求并获得的内容，再返回给客户端。正向代理隐藏了真实的客户端，为客户端收发请求，使真实客户端对服务器不可见； 举个具体的例子 🌰，你的浏览器无法直接访问谷哥，这时候可以通过一个代理服务器来帮助你访问谷哥，那么这个服务器就叫正向代理。 反向代理： 与一般访问流程相比，使用反向代理后，直接收到请求的服务器是代理服务器，然后将请求转发给内部网络上真正进行处理的服务器，得到的结果返回给客户端。反向代理隐藏了真实的服务器，为服务器收发请求，使真实服务器对客户端不可见。一般在处理跨域请求的时候比较常用。现在基本上所有的大型网站都设置了反向代理。 举个具体的例子 🌰，去饭店吃饭，可以点川菜、粤菜、江浙菜，饭店也分别有三个菜系的厨师 👨‍🍳，但是你作为顾客不用管哪个厨师给你做的菜，只用点菜即可，小二将你菜单中的菜分配给不同的厨师来具体处理，那么这个小二就是反向代理服务器。 简单的说，一般给客户端做代理的都是正向代理，给服务器做代理的就是反向代理。 正向代理和反向代理主要的原理区别可以参见下图： ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:2:3","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"2.4 负载均衡 一般情况下，客户端发送多个请求到服务器，服务器处理请求，其中一部分可能要操作一些资源比如数据库、静态资源等，服务器处理完毕后，再将结果返回给客户端。 这种模式对于早期的系统来说，功能要求不复杂，且并发请求相对较少的情况下还能胜任，成本也低。随着信息数量不断增长，访问量和数据量飞速增长，以及系统业务复杂度持续增加，这种做法已无法满足要求，并发量特别大时，服务器容易崩。 很明显这是由于服务器性能的瓶颈造成的问题，除了堆机器之外，最重要的做法就是负载均衡。 请求爆发式增长的情况下，单个机器性能再强劲也无法满足要求了，这个时候集群的概念产生了，单个服务器解决不了的问题，可以使用多个服务器，然后将请求分发到各个服务器上，将负载分发到不同的服务器，这就是负载均衡，核心是「分摊压力」。Nginx 实现负载均衡，一般来说指的是将请求转发给服务器集群。 举个具体的例子 🌰，晚高峰乘坐地铁的时候，入站口经常会有地铁工作人员大喇叭“请走 B 口，B 口人少车空….”，这个工作人员的作用就是负载均衡。 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:2:4","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"2.5 动静分离 为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。 一般来说，都需要将动态资源和静态资源分开，由于 Nginx 的高并发和静态资源缓存等特性，经常将静态资源部署在 Nginx 上。如果请求的是静态资源，直接到静态资源目录获取资源，如果是动态资源的请求，则利用反向代理的原理，把请求转发给对应后台应用去处理，从而实现动静分离。 使用前后端分离后，可以很大程度提升静态资源的访问速度，即使动态服务不可用，静态资源的访问也不会受到影响。 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:2:5","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"3. Nginx 快速安装 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:3:0","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"3.1 安装 我们可以先看看 yum list | grep nginx 来看看 然后 yum install nginx 来安装 Nginx，然后我们在命令行中 nginx -v 就可以看到具体的 Nginx 版本信息，也就安装完毕了。 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:3:1","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"3.2 相关文件夹 然后我们可以使用 rpm -ql nginx 来查看 Nginx 被安装到了什么地方，有哪些相关目录，其中位于 /etc 目录下的主要是配置文件，还有一些文件见下图： 主要关注的文件夹有两个： /etc/nginx/conf.d/ 文件夹，是我们进行子配置的配置项存放处，/etc/nginx/nginx.conf 主配置文件会默认把这个文件夹中所有子配置项都引入； /usr/share/nginx/html/ 文件夹，通常静态文件都放在这个文件夹，也可以根据你自己的习惯放其他地方； ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:3:2","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"3.3 跑起来康康 安装之后开启 Nginx，如果系统开启了防火墙，那么需要设置一下在防火墙中加入需要开放的端口，下面列举几个常用的防火墙操作（没开启的话不用管这个）： systemctl start firewalld # 开启防火墙 systemctl stop firewalld # 关闭防火墙 systemctl status firewalld # 查看防火墙开启状态，显示running则是正在运行 firewall-cmd --reload # 重启防火墙，永久打开端口需要reload一下 # 添加开启端口，--permanent表示永久打开，不加是临时打开重启之后失效 firewall-cmd --permanent --zone=public --add-port=8888/tcp # 查看防火墙，添加的端口也可以看到 firewall-cmd --list-all 然后设置 Nginx 的开机启动： systemctl enable nginx 启动 Nginx （其他命令后面有详细讲解）： systemctl start nginx 然后访问你的 IP，这时候就可以看到 Nginx 的欢迎页面了～ Welcome to nginx！ 👏 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:3:3","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"3.4 安装 nvm \u0026 node \u0026 git # 下载 nvm，或者看官网的步骤 https://github.com/nvm-sh/nvm#install--update-script curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash source ~/.bashrc # 安装完毕后，更新配置文件即可使用 nvm 命令 nvm ls-remote # 查看远程 node 版本 nvm install v12.16.3 # 选一个你要安装的版本安装，我这里选择 12.16.3 nvm list # 安装完毕查看安装的 node 版本 node -v # 查看是否安装好了 yum install git # git 安装 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:3:4","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"4. Nginx 操作常用命令 Nginx 的命令在控制台中输入 nginx -h 就可以看到完整的命令，这里列举几个常用的命令： nginx -s reload # 向主进程发送信号，重新加载配置文件，热重启 nginx -s reopen # 重启 Nginx nginx -s stop # 快速关闭 nginx -s quit # 等待工作进程处理完成后关闭 nginx -T # 查看当前 Nginx 最终的配置 nginx -t -c \u003c配置路径\u003e # 检查配置是否有问题，如果已经在配置目录，则不需要-c systemctl 是 Linux 系统应用管理工具 systemd 的主命令，用于管理系统，我们也可以用它来对 Nginx 进行管理，相关命令如下： systemctl start nginx # 启动 Nginx systemctl stop nginx # 停止 Nginx systemctl restart nginx # 重启 Nginx systemctl reload nginx # 重新加载 Nginx，用于修改配置后 systemctl enable nginx # 设置开机启动 Nginx systemctl disable nginx # 关闭开机启动 Nginx systemctl status nginx # 查看 Nginx 运行状态 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:4:0","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"5. Nginx 配置语法 就跟前面文件作用讲解的图所示，Nginx 的主配置文件是 /etc/nginx/nginx.conf，你可以使用 cat -n nginx.conf 来查看配置。 nginx.conf 结构图可以这样概括： main # 全局配置，对全局生效 ├── events # 配置影响 Nginx 服务器或与用户的网络连接 ├── http # 配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置 │ ├── upstream # 配置后端服务器具体地址，负载均衡配置不可或缺的部分 │ ├── server # 配置虚拟主机的相关参数，一个 http 块中可以有多个 server 块 │ ├── server │ │ ├── location # server 块可以包含多个 location 块，location 指令用于匹配 uri │ │ ├── location │ │ └── ... │ └── ... └── ... 一个 Nginx 配置文件的结构就像 nginx.conf 显示的那样，配置文件的语法规则： 配置文件由指令与指令块构成； 每条指令以 ; 分号结尾，指令与参数间以空格符号分隔； 指令块以 {} 大括号将多条指令组织在一起； include 语句允许组合多个配置文件以提升可维护性； 使用 # 符号添加注释，提高可读性； 使用 $ 符号使用变量； 部分指令的参数支持正则表达式； ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:5:0","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"5.1 典型配置 Nginx 的典型配置： user nginx; # 运行用户，默认即是nginx，可以不进行设置 worker_processes 1; # Nginx 进程数，一般设置为和 CPU 核数一样 error_log /var/log/nginx/error.log warn; # Nginx 的错误日志存放目录 pid /var/run/nginx.pid; # Nginx 服务启动时的 pid 存放位置 events { use epoll; # 使用epoll的I/O模型(如果你不知道Nginx该使用哪种轮询方法，会自动选择一个最适合你操作系统的) worker_connections 1024; # 每个进程允许最大并发数 } http { # 配置使用最频繁的部分，代理、缓存、日志定义等绝大多数功能和第三方模块的配置都在这里设置 # 设置日志模式 log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; # Nginx访问日志存放位置 sendfile on; # 开启高效传输模式 tcp_nopush on; # 减少网络报文段的数量 tcp_nodelay on; keepalive_timeout 65; # 保持连接的时间，也叫超时时间，单位秒 types_hash_max_size 2048; include /etc/nginx/mime.types; # 文件扩展名与类型映射表 default_type application/octet-stream; # 默认文件类型 include /etc/nginx/conf.d/*.conf; # 加载子配置项 server { listen 80; # 配置监听的端口 server_name localhost; # 配置的域名 location / { root /usr/share/nginx/html; # 网站根目录 index index.html index.htm; # 默认首页文件 deny 172.168.22.11; # 禁止访问的ip地址，可以为all allow 172.168.33.44； # 允许访问的ip地址，可以为all } error_page 500 502 503 504 /50x.html; # 默认50x对应的访问页面 error_page 400 404 error.html; # 同上 } } server 块可以包含多个 location 块，location 指令用于匹配 uri，语法： location [ = | ~ | ~* | ^~] uri { ... } 指令后面： = 精确匹配路径，用于不含正则表达式的 uri 前，如果匹配成功，不再进行后续的查找； ^~ 用于不含正则表达式的 uri； 前，表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找； ~ 表示用该符号后面的正则去匹配路径，区分大小写； ~* 表示用该符号后面的正则去匹配路径，不区分大小写。跟 ~ 优先级都比较低，如有多个location的正则能匹配的话，则使用正则表达式最长的那个； 如果 uri 包含正则表达式，则必须要有 ~ 或 ~* 标志。 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:5:1","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"5.2 全局变量 Nginx 有一些常用的全局变量，你可以在配置的任何位置使用它们，如下表： 全局变量名 功能 $host 请求信息中的 Host，如果请求中没有 Host 行，则等于设置的服务器名，不包含端口 $request_method 客户端请求类型，如 GET、POST $remote_addr 客户端的 IP 地址 $args 请求中的参数 $arg_PARAMETER GET 请求中变量名 PARAMETER 参数的值，例如：$http_user_agent(Uaer-Agent 值), $http_referer… $content_length 请求头中的 Content-length 字段 $http_user_agent 客户端agent信息 $http_cookie 客户端cookie信息 $remote_addr 客户端的IP地址 $remote_port 客户端的端口 $http_user_agent 客户端agent信息 $server_protocol 请求使用的协议，如 HTTP/1.0、HTTP/1.1 $server_addr 服务器地址 $server_name 服务器名称 $server_port 服务器的端口号 $scheme HTTP 方法（如http，https） 还有更多的内置预定义变量，可以直接搜索关键字「nginx内置预定义变量」可以看到一堆博客写这个，这些变量都可以在配置文件中直接使用。 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:5:2","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"6. 设置二级域名虚拟主机 在某某云 ☁️ 上购买了域名之后，就可以配置虚拟主机了，一般配置的路径在 域名管理 -\u003e 解析 -\u003e 添加记录 中添加二级域名，配置后某某云会把二级域名也解析到我们配置的服务器 IP 上，然后我们在 Nginx 上配置一下虚拟主机的访问监听，就可以拿到从这个二级域名过来的请求了。 现在我自己的服务器上配置了一个 fe 的二级域名，也就是说在外网访问 fe.sherlocked93.club 的时候，也可以访问到我们的服务器了。 由于默认配置文件 /etc/nginx/nginx.conf 的 http 模块中有一句 include /etc/nginx/conf.d/*.conf 也就是说 conf.d 文件夹下的所有 *.conf 文件都会作为子配置项被引入配置文件中。为了维护方便，我在 /etc/nginx/conf.d 文件夹中新建一个 fe.sherlocked93.club.conf ： # /etc/nginx/conf.d/fe.sherlocked93.club.conf server { listen 80; server_name fe.sherlocked93.club; location / { root /usr/share/nginx/html/fe; index index.html; } } 然后在 /usr/share/nginx/html 文件夹下新建 fe 文件夹，新建文件 index.html，内容随便写点，改完 nginx -s reload 重新加载，浏览器中输入 fe.sherlocked93.club，发现从二级域名就可以访问到我们刚刚新建的 fe 文件夹： ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:6:0","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"7. 配置反向代理 反向代理是工作中最常用的服务器功能，经常被用来解决跨域问题，下面简单介绍一下如何实现反向代理。 首先进入 Nginx 的主配置文件： vim /etc/nginx/nginx.conf 为了看起来方便，把行号显示出来 :set nu （个人习惯），然后我们去 http 模块的 server 块中的 location /，增加一行将默认网址重定向到最大学习网站 Bilibili 的 proxy_pass 配置 🤓 ： 改完保存退出，nginx -s reload 重新加载，进入默认网址，那么现在就直接跳转到 B 站了，实现了一个简单的代理。 实际使用中，可以将请求转发到本机另一个服务器上，也可以根据访问的路径跳转到不同端口的服务中。 比如我们监听 9001 端口，然后把访问不同路径的请求进行反向代理： 把访问 http://127.0.0.1:9001/edu 的请求转发到 http://127.0.0.1:8080 把访问 http://127.0.0.1:9001/vod 的请求转发到 http://127.0.0.1:8081 这种要怎么配置呢，首先同样打开主配置文件，然后在 http 模块下增加一个 server 块： server { listen 9001; server_name *.sherlocked93.club; location ~ /edu/ { proxy_pass http://127.0.0.1:8080; } location ~ /vod/ { proxy_pass http://127.0.0.1:8081; } } 反向代理还有一些其他的指令，可以了解一下： proxy_set_header：在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。 proxy_connect_timeout：配置Nginx与后端代理服务器尝试建立连接的超时时间。 proxy_read_timeout：配置Nginx向后端服务器组发出read请求后，等待相应的超时时间。 proxy_send_timeout：配置Nginx向后端服务器组发出write请求后，等待相应的超时时间。 proxy_redirect：用于修改后端服务器返回的响应头中的Location和Refresh。 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:7:0","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"8. 跨域 CORS 配置 关于简单请求、非简单请求、跨域的概念，前面已经介绍过了，还不了解的可以看看前面的讲解。现在前后端分离的项目一统天下，经常本地起了前端服务，需要访问不同的后端地址，不可避免遇到跨域问题。 要解决跨域问题，我们来制造一个跨域问题。首先和前面设置二级域名的方式一样，先设置好 fe.sherlocked93.club 和 be.sherlocked93.club 二级域名，都指向本云服务器地址，虽然对应 IP 是一样的，但是在 fe.sherlocked93.club 域名发出的请求访问 be.sherlocked93.club 域名的请求还是跨域了，因为访问的 host 不一致（如果不知道啥原因参见前面跨域的内容）。 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:8:0","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"8.1 使用反向代理解决跨域 在前端服务地址为 fe.sherlocked93.club 的页面请求 be.sherlocked93.club 的后端服务导致的跨域，可以这样配置： server { listen 9001; server_name fe.sherlocked93.club; location / { proxy_pass be.sherlocked93.club; } } 这样就将对前一个域名 fe.sherlocked93.club 的请求全都代理到了 be.sherlocked93.club，前端的请求都被我们用服务器代理到了后端地址下，绕过了跨域。 这里对静态文件的请求和后端服务的请求都以 fe.sherlocked93.club 开始，不易区分，所以为了实现对后端服务请求的统一转发，通常我们会约定对后端服务的请求加上 /apis/ 前缀或者其他的 path 来和对静态资源的请求加以区分，此时我们可以这样配置： # 请求跨域，约定代理后端服务请求path以/apis/开头 location ^~/apis/ { # 这里重写了请求，将正则匹配中的第一个分组的path拼接到真正的请求后面，并用break停止后续匹配 rewrite ^/apis/(.*)$ /$1 break; proxy_pass be.sherlocked93.club; # 两个域名之间cookie的传递与回写 proxy_cookie_domain be.sherlocked93.club fe.sherlocked93.club; } 这样，静态资源我们使用 fe.sherlocked93.club/xx.html，动态资源我们使用 fe.sherlocked93.club/apis/getAwo，浏览器页面看起来仍然访问的前端服务器，绕过了浏览器的同源策略，毕竟我们看起来并没有跨域。 也可以统一一点，直接把前后端服务器地址直接都转发到另一个 server.sherlocked93.club，只通过在后面添加的 path 来区分请求的是静态资源还是后端服务，看需求了。 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:8:1","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"8.2 配置 header 解决跨域 当浏览器在访问跨源的服务器时，也可以在跨域的服务器上直接设置 Nginx，从而前端就可以无感地开发，不用把实际上访问后端的地址改成前端服务的地址，这样可适性更高。 比如前端站点是 fe.sherlocked93.club，这个地址下的前端页面请求 be.sherlocked93.club 下的资源，比如前者的 fe.sherlocked93.club/index.html 内容是这样的： \u003chtml\u003e \u003cbody\u003e \u003ch1\u003ewelcome fe.sherlocked93.club!!\u003ch1\u003e \u003cscript type='text/javascript'\u003e var xmlhttp = new XMLHttpRequest() xmlhttp.open(\"GET\", \"http://be.sherlocked93.club/index.html\", true); xmlhttp.send(); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 打开浏览器访问 fe.sherlocked93.club/index.html 的结果如下： 很明显这里是跨域请求，在浏览器中直接访问 http://be.sherlocked93.club/index.html 是可以访问到的，但是在 fe.sherlocked93.club 的 html 页面访问就会出现跨域。 在 /etc/nginx/conf.d/ 文件夹中新建一个配置文件，对应二级域名 be.sherlocked93.club ： # /etc/nginx/conf.d/be.sherlocked93.club.conf server { listen 80; server_name be.sherlocked93.club; add_header 'Access-Control-Allow-Origin' $http_origin; # 全局变量获得当前请求origin，带cookie的请求不支持* add_header 'Access-Control-Allow-Credentials' 'true'; # 为 true 可带上 cookie add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; # 允许请求方法 add_header 'Access-Control-Allow-Headers' $http_access_control_request_headers; # 允许请求的 header，可以为 * add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range'; if ($request_method = 'OPTIONS') { add_header 'Access-Control-Max-Age' 1728000; # OPTIONS 请求的有效期，在有效期内不用发出另一条预检请求 add_header 'Content-Type' 'text/plain; charset=utf-8'; add_header 'Content-Length' 0; return 204; # 200 也可以 } location / { root /usr/share/nginx/html/be; index index.html; } } 然后 nginx -s reload 重新加载配置。这时再访问 fe.sherlocked93.club/index.html 结果如下，请求中出现了我们刚刚配置的 Header： 解决了跨域问题。 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:8:2","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"9. 开启 gzip 压缩 gzip 是一种常用的网页压缩技术，传输的网页经过 gzip 压缩之后大小通常可以变为原来的一半甚至更小（官网原话），更小的网页体积也就意味着带宽的节约和传输速度的提升，特别是对于访问量巨大大型网站来说，每一个静态资源体积的减小，都会带来可观的流量与带宽的节省。 百度可以找到很多检测站点来查看目标网页有没有开启 gzip 压缩，在下随便找了一个 \u003c网页GZIP压缩检测\u003e 输入掘金 juejin.im 来偷窥下掘金有没有开启 gzip。 这里可以看到掘金是开启了 gzip 的，压缩效果还挺不错，达到了 52% 之多，本来 34kb 的网页体积，压缩完只需要 16kb，可以想象网页传输速度提升了不少。 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:9:0","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"9.1 Nginx 配置 gzip 使用 gzip 不仅需要 Nginx 配置，浏览器端也需要配合，需要在请求消息头中包含 Accept-Encoding: gzip（IE5 之后所有的浏览器都支持了，是现代浏览器的默认设置）。一般在请求 html 和 css 等静态资源的时候，支持的浏览器在 request 请求静态资源的时候，会加上 Accept-Encoding: gzip 这个 header，表示自己支持 gzip 的压缩方式，Nginx 在拿到这个请求的时候，如果有相应配置，就会返回经过 gzip 压缩过的文件给浏览器，并在 response 相应的时候加上 content-encoding: gzip 来告诉浏览器自己采用的压缩方式（因为浏览器在传给服务器的时候一般还告诉服务器自己支持好几种压缩方式），浏览器拿到压缩的文件后，根据自己的解压方式进行解析。 先来看看 Nginx 怎么进行 gzip 配置，和之前的配置一样，为了方便管理，还是在 /etc/nginx/conf.d/ 文件夹中新建配置文件 gzip.conf ： # /etc/nginx/conf.d/gzip.conf gzip on; # 默认off，是否开启gzip gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript; # 上面两个开启基本就能跑起了，下面的愿意折腾就了解一下 gzip_static on; gzip_proxied any; gzip_vary on; gzip_comp_level 6; gzip_buffers 16 8k; # gzip_min_length 1k; gzip_http_version 1.1; 稍微解释一下： gzip_types：要采用 gzip 压缩的 MIME 文件类型，其中 text/html 被系统强制启用； gzip_static：默认 off，该模块启用后，Nginx 首先检查是否存在请求静态文件的 gz 结尾的文件，如果有则直接返回该 .gz 文件内容； gzip_proxied：默认 off，nginx做为反向代理时启用，用于设置启用或禁用从代理服务器上收到相应内容 gzip 压缩； gzip_vary：用于在响应消息头中添加 Vary：Accept-Encoding，使代理服务器根据请求头中的 Accept-Encoding 识别是否启用 gzip 压缩； gzip_comp_level：gzip 压缩比，压缩级别是 1-9，1 压缩级别最低，9 最高，级别越高压缩率越大，压缩时间越长，建议 4-6； gzip_buffers：获取多少内存用于缓存压缩结果，16 8k 表示以 8k*16 为单位获得； gzip_min_length：允许压缩的页面最小字节数，页面字节数从header头中的 Content-Length 中进行获取。默认值是 0，不管页面多大都压缩。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大； gzip_http_version：默认 1.1，启用 gzip 所需的 HTTP 最低版本； 这个配置可以插入到 http 模块整个服务器的配置里，也可以插入到需要使用的虚拟主机的 server 或者下面的 location 模块中，当然像上面我们这样写的话就是被 include 到 http 模块中了。 其他更全的配置信息可以查看 \u003c官网文档ngx_http_gzip_module\u003e，配置前是这样的： 配置之后 response 的 header 里面多了一个 Content-Encoding: gzip，返回信息被压缩了： 注意了，一般 gzip 的配置建议加上 gzip_min_length 1k，不加的话： 由于文件太小，gzip 压缩之后得到了 -48% 的体积优化，压缩之后体积还比压缩之前体积大了，所以最好设置低于 1kb 的文件就不要 gzip 压缩了 🤪 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:9:1","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"9.2 Webpack 的 gzip 配置 当前端项目使用 Webpack 进行打包的时候，也可以开启 gzip 压缩： // vue-cli3 的 vue.config.js 文件 const CompressionWebpackPlugin = require('compression-webpack-plugin') module.exports = { // gzip 配置 configureWebpack: config =\u003e { if (process.env.NODE_ENV === 'production') { // 生产环境 return { plugins: [new CompressionWebpackPlugin({ test: /\\.js$|\\.html$|\\.css/, // 匹配文件名 threshold: 10240, // 文件压缩阈值，对超过10k的进行压缩 deleteOriginalAssets: false // 是否删除源文件 })] } } }, ... } 由此打包出来的文件如下图： 这里可以看到某些打包之后的文件下面有一个对应的 .gz 经过 gzip 压缩之后的文件，这是因为这个文件超过了 10kb，有的文件没有超过 10kb 就没有进行 gzip 打包，如果你期望压缩文件的体积阈值小一点，可以在 compression-webpack-plugin 这个插件的配置里进行对应配置。 那么为啥这里 Nginx 已经有了 gzip 压缩，Webpack 这里又整了个 gzip 呢，因为如果全都是使用 Nginx 来压缩文件，会耗费服务器的计算资源，如果服务器的 gzip_comp_level 配置的比较高，就更增加服务器的开销，相应增加客户端的请求时间，得不偿失。 如果压缩的动作在前端打包的时候就做了，把打包之后的高压缩等级文件作为静态资源放在服务器上，Nginx 会优先查找这些压缩之后的文件返回给客户端，相当于把压缩文件的动作从 Nginx 提前给 Webpack 打包的时候完成，节约了服务器资源，所以一般推介在生产环境应用 Webpack 配置 gzip 压缩。 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:9:2","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"10. 配置负载均衡 负载均衡在之前已经介绍了相关概念了，主要思想就是把负载均匀合理地分发到多个服务器上，实现压力分流的目的。 主要配置如下： http { upstream myserver { # ip_hash; # ip_hash 方式 # fair; # fair 方式 server 127.0.0.1:8081; # 负载均衡目的服务地址 server 127.0.0.1:8080; server 127.0.0.1:8082 weight=10; # weight 方式，不写默认为 1 } server { location / { proxy_pass http://myserver; proxy_connect_timeout 10; } } } Nginx 提供了好几种分配方式，默认为轮询，就是轮流来。有以下几种分配方式： 轮询，默认方式，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务挂了，能自动剔除； weight，权重分配，指定轮询几率，权重越高，在被访问的概率越大，用于后端服务器性能不均的情况； ip_hash，每个请求按访问 IP 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决动态网页 session 共享问题。负载均衡每次请求都会重新定位到服务器集群中的某一个，那么已经登录某一个服务器的用户再重新定位到另一个服务器，其登录信息将会丢失，这样显然是不妥的； fair（第三方），按后端服务器的响应时间分配，响应时间短的优先分配，依赖第三方插件 nginx-upstream-fair，需要先安装； ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:10:0","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"11. 配置动静分离 动静分离在之前也介绍过了，就是把动态和静态的请求分开。方式主要有两种，一种 是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案。另外一种方法就是动态跟静态文件混合在一起发布， 通过 Nginx 配置来分开。 通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个URL，发送一个请求，比对服务器该文件最后更新时间没有变化。则不会从服务器抓取，返回状态码 304，如果有修改，则直接从服务器重新下载，返回状态码 200。 server { location /www/ { root /data/; index index.html index.htm; } location /image/ { root /data/; autoindex on; } } ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:11:0","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"12. 配置高可用集群（双机热备） 当主 Nginx 服务器宕机之后，切换到备份 Nginx 服务器 首先安装 keepalived， yum install keepalived -y 然后编辑 /etc/keepalived/keepalived.conf 配置文件，并在配置文件中增加 vrrp_script 定义一个外围检测机制，并在 vrrp_instance 中通过定义 track_script 来追踪脚本执行过程，实现节点转移： global_defs{ notification_email { acassen@firewall.loc } notification_email_from Alexandre@firewall.loc smtp_server 127.0.0.1 smtp_connect_timeout 30 // 上面都是邮件配置，没卵用 router_id LVS_DEVEL // 当前服务器名字，用hostname命令来查看 } vrrp_script chk_maintainace { // 检测机制的脚本名称为chk_maintainace script \"[[ -e/etc/keepalived/down ]] \u0026\u0026 exit 1 || exit 0\" // 可以是脚本路径或脚本命令 // script \"/etc/keepalived/nginx_check.sh\" // 比如这样的脚本路径 interval 2 // 每隔2秒检测一次 weight -20 // 当脚本执行成立，那么把当前服务器优先级改为-20 } vrrp_instanceVI_1 { // 每一个vrrp_instance就是定义一个虚拟路由器 state MASTER // 主机为MASTER，备用机为BACKUP interface eth0 // 网卡名字，可以从ifconfig中查找 virtual_router_id 51 // 虚拟路由的id号，一般小于255，主备机id需要一样 priority 100 // 优先级，master的优先级比backup的大 advert_int 1 // 默认心跳间隔 authentication { // 认证机制 auth_type PASS auth_pass 1111 // 密码 } virtual_ipaddress { // 虚拟地址vip 172.16.2.8 } } 其中检测脚本 nginx_check.sh，这里提供一个： #!/bin/bash A=`ps -C nginx --no-header | wc -l` if [ $A -eq 0 ];then /usr/sbin/nginx # 尝试重新启动nginx sleep 2 # 睡眠2秒 if [ `ps -C nginx --no-header | wc -l` -eq 0 ];then killall keepalived # 启动失败，将keepalived服务杀死。将vip漂移到其它备份节点 fi fi 复制一份到备份服务器，备份 Nginx 的配置要将 state 后改为 BACKUP，priority 改为比主机小。 设置完毕后各自 service keepalived start 启动，经过访问成功之后，可以把 Master 机的 keepalived 停掉，此时 Master 机就不再是主机了 service keepalived stop，看访问虚拟 IP 时是否能够自动切换到备机 ip addr。 再次启动 Master 的 keepalived，此时 vip 又变到了主机上。 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:12:0","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"13. 适配 PC 或移动设备 根据用户设备不同返回不同样式的站点，以前经常使用的是纯前端的自适应布局，但无论是复杂性和易用性上面还是不如分开编写的好，比如我们常见的淘宝、京东……这些大型网站就都没有采用自适应，而是用分开制作的方式，根据用户请求的 user-agent 来判断是返回 PC 还是 H5 站点。 首先在 /usr/share/nginx/html 文件夹下 mkdir 分别新建两个文件夹 PC 和 mobile，vim 编辑两个 index.html 随便写点内容。 cd /usr/share/nginx/html mkdir pc mobile cd pc vim index.html # 随便写点比如 hello pc! cd ../mobile vim index.html # 随便写点比如 hello mobile! 然后和设置二级域名虚拟主机时候一样，去 /etc/nginx/conf.d 文件夹下新建一个配置文件 fe.sherlocked93.club.conf ： # /etc/nginx/conf.d/fe.sherlocked93.club.conf server { listen 80; server_name fe.sherlocked93.club; location / { root /usr/share/nginx/html/pc; if ($http_user_agent ~* '(Android|webOS|iPhone|iPod|BlackBerry)') { root /usr/share/nginx/html/mobile; } index index.html; } } 配置基本没什么不一样的，主要多了一个 if 语句，然后使用 $http_user_agent 全局变量来判断用户请求的 user-agent，指向不同的 root 路径，返回对应站点。 在浏览器访问这个站点，然后 F12 中模拟使用手机访问： 可以看到在模拟使用移动端访问的时候，Nginx 返回的站点变成了移动端对应的 html 了。 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:13:0","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"14. 配置 HTTPS 具体配置过程网上挺多的了，也可以使用你购买的某某云，一般都会有免费申请的服务器证书，安装直接看所在云的操作指南即可。 我购买的腾讯云提供的亚洲诚信机构颁发的免费证书只能一个域名使用，二级域名什么的需要另外申请，但是申请审批比较快，一般几分钟就能成功，然后下载证书的压缩文件，里面有个 nginx 文件夹，把 xxx.crt 和 xxx.key 文件拷贝到服务器目录，再配置下： server { listen 443 ssl http2 default_server; # SSL 访问端口号为 443 server_name sherlocked93.club; # 填写绑定证书的域名 ssl_certificate /etc/nginx/https/1_sherlocked93.club_bundle.crt; # 证书文件地址 ssl_certificate_key /etc/nginx/https/2_sherlocked93.club.key; # 私钥文件地址 ssl_session_timeout 10m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #请按照以下协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / { root /usr/share/nginx/html; index index.html index.htm; } } 写完 nginx -t -q 校验一下，没问题就 nginx -s reload，现在去访问 https://sherlocked93.club/ 就能访问 HTTPS 版的网站了。 一般还可以加上几个增强安全性的命令： add_header X-Frame-Options DENY; # 减少点击劫持 add_header X-Content-Type-Options nosniff; # 禁止服务器自动解析资源类型 add_header X-Xss-Protection 1; # 防XSS攻击 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:14:0","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"15. 一些常用技巧 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:15:0","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"15.1 静态服务 server { listen 80; server_name static.sherlocked93.club; charset utf-8; # 防止中文文件名乱码 location /download { alias /usr/share/nginx/html/static; # 静态资源目录 autoindex on; # 开启静态资源列目录 autoindex_exact_size off; # on(默认)显示文件的确切大小，单位是byte；off显示文件大概大小，单位KB、MB、GB autoindex_localtime off; # off(默认)时显示的文件时间为GMT时间；on显示的文件时间为服务器时间 } } ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:15:1","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"15.2 图片防盗链 server { listen 80; server_name *.sherlocked93.club; # 图片防盗链 location ~* \\.(gif|jpg|jpeg|png|bmp|swf)$ { valid_referers none blocked server_names ~\\.google\\. ~\\.baidu\\. *.qq.com; # 只允许本机 IP 外链引用，感谢 @木法传 的提醒，将百度和谷歌也加入白名单 if ($invalid_referer){ return 403; } } } ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:15:2","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"15.3 请求过滤 # 非指定请求全返回 403 if ( $request_method !~ ^(GET|POST|HEAD)$ ) { return 403; } location / { # IP访问限制（只允许IP是 192.168.0.2 机器访问） allow 192.168.0.2; deny all; root html; index index.html index.htm; } ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:15:3","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"15.4 配置图片、字体等静态文件缓存 由于图片、字体、音频、视频等静态文件在打包的时候通常会增加了 hash，所以缓存可以设置的长一点，先设置强制缓存，再设置协商缓存；如果存在没有 hash 值的静态文件，建议不设置强制缓存，仅通过协商缓存判断是否需要使用缓存。 # 图片缓存时间设置 location ~ .*\\.(css|js|jpg|png|gif|swf|woff|woff2|eot|svg|ttf|otf|mp3|m4a|aac|txt)$ { expires 10d; } # 如果不希望缓存 expires -1; ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:15:4","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"15.5 单页面项目 history 路由配置 server { listen 80; server_name fe.sherlocked93.club; location / { root /usr/share/nginx/html/dist; # vue 打包后的文件夹 index index.html index.htm; try_files $uri $uri/ /index.html @rewrites; expires -1; # 首页一般没有强制缓存 add_header Cache-Control no-cache; } # 接口转发，如果需要的话 #location ~ ^/api { # proxy_pass http://be.sherlocked93.club; #} location @rewrites { rewrite ^(.+)$ /index.html break; } } ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:15:5","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"15.6 HTTP 请求转发到 HTTPS 配置完 HTTPS 后，浏览器还是可以访问 HTTP 的地址 http://sherlocked93.club/ 的，可以做一个 301 跳转，把对应域名的 HTTP 请求重定向到 HTTPS 上 server { listen 80; server_name www.sherlocked93.club; # 单域名重定向 if ($host = 'www.sherlocked93.club'){ return 301 https://www.sherlocked93.club$request_uri; } # 全局非 https 协议时重定向 if ($scheme != 'https') { return 301 https://$server_name$request_uri; } # 或者全部重定向 return 301 https://$server_name$request_uri; # 以上配置选择自己需要的即可，不用全部加 } ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:15:6","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"15.7 泛域名路径分离 这是一个非常实用的技能，经常有时候我们可能需要配置一些二级或者三级域名，希望通过 Nginx 自动指向对应目录，比如： test1.doc.sherlocked93.club 自动指向 /usr/share/nginx/html/doc/test1 服务器地址； test2.doc.sherlocked93.club 自动指向 /usr/share/nginx/html/doc/test2 服务器地址； server { listen 80; server_name ~^([\\w-]+)\\.doc\\.sherlocked93\\.club$; root /usr/share/nginx/html/doc/$1; } ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:15:7","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"15.8 泛域名转发 和之前的功能类似，有时候我们希望把二级或者三级域名链接重写到我们希望的路径，让后端就可以根据路由解析不同的规则： test1.serv.sherlocked93.club/api?name=a 自动转发到 127.0.0.1:8080/test1/api?name=a ； test2.serv.sherlocked93.club/api?name=a 自动转发到 127.0.0.1:8080/test2/api?name=a ； server { listen 80; server_name ~^([\\w-]+)\\.serv\\.sherlocked93\\.club$; location / { proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_pass http://127.0.0.1:8080/$1$request_uri; } } ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:15:8","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["Nginx"],"content":"16. 最佳实践 为了使 Nginx 配置更易于维护，建议为每个服务创建一个单独的配置文件，存储在 /etc/nginx/conf.d 目录，根据需求可以创建任意多个独立的配置文件。 独立的配置文件，建议遵循以下命名约定 \u003c服务\u003e.conf，比如域名是 sherlocked93.club，那么你的配置文件的应该是这样的 /etc/nginx/conf.d/sherlocked93.club.conf，如果部署多个服务，也可以在文件名中加上 Nginx 转发的端口号，比如 sherlocked93.club.8080.conf，如果是二级域名，建议也都加上 fe.sherlocked93.club.conf。 常用的、复用频率比较高的配置可以放到 /etc/nginx/snippets 文件夹，在 Nginx 的配置文件中需要用到的位置 include 进去，以功能来命名，并在每个 snippet 配置文件的开头注释标明主要功能和引入位置，方便管理。比如之前的 gzip、cors 等常用配置，我都设置了 snippet。 Nginx 日志相关目录，内以 域名.type.log 命名（比如 be.sherlocked93.club.access.log 和 be.sherlocked93.club.error.log ）位于 /var/log/nginx/ 目录中，为每个独立的服务配置不同的访问权限和错误日志文件，这样查找错误时，会更加方便快捷。 感谢 @木法传 的提醒，Nginx 设置防盗链的时候，可以将百度和 google 设置为白名单，利于 SEO 网上的帖子大多深浅不一，甚至有些前后矛盾，在下的文章都是学习过程中的总结，如果发现错误，欢迎留言指出~ 参考文档： Nginx中文文档 Nginx安装，目录结构与配置文件详解 Keepalived安装与配置 Keepalived+Nginx实现高可用 Nginx与前端开发 跨域资源共享 CORS 详解 - 阮一峰的网络日志 前端开发者必备的nginx知识 我也说说Nginx解决前端跨域问题，正确的Nginx跨域配置 vue-router history模式nginx配置并配置静态资源缓存 | HolidayPenguin nginx重定向，全局https，SSL配置，反代配置参考 Nginx 入门教程 PS：本人博客地址 Github - SHERlocked93/blog，也欢迎大家关注我的公众号【前端下午茶】，一起加油吧~ 另外可以加入「前端下午茶交流群」微信群，长按识别下面二维码即可加我好友，备注加群，我拉你入群～ 作者：SHERlocked93 链接：https://juejin.cn/post/6844904144235413512 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"0001-01-01","objectID":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/:16:0","tags":["nginx"],"title":"Nginx从入门到实践---万字详解","uri":"/nginx%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5---%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3/"},{"categories":["GIS"],"content":"https://www.cnblogs.com/lqqgis/p/12641794.html ","date":"0001-01-01","objectID":"/python--sqlite--st_geometry/:0:0","tags":["GIS","Python","sqlite","spatial"],"title":"Python + SQLite + ST_Geometry","uri":"/python--sqlite--st_geometry/"},{"categories":["GIS"],"content":" import sqlite3 connR = sqlite3.connect(':memory:') connR.enable_load_extension(True) #now we can load the extension # depending on your OS and sqlite/spatialite version you might need to add # '.so' (Linux) or '.dll' (Windows) to the extension name #mod_spatialite (recommended) connR.execute('SELECT load_extension(\"mod_spatialite\")') connR.execute('SELECT InitSpatialMetaData(1);') # libspatialite connR.execute('SELECT load_extension(\"libspatialite\")') connR.execute('SELECT InitSpatialMetaData();') curR = connR.cursor() curR.execute('''CREATE TABLE my_line(id INTEGER PRIMARY KEY)''') curR.execute('SELECT AddGeometryColumn(\"my_line\",\"geom\" , 4326, \"LINESTRING\", 2)') connR.commit() polygon_wkt = 'POLYGON ((11 50,11 51,12 51,12 50,11 50))' XA = 11 YA = 52 XB = 12 YB = 49 line_wkt = 'LINESTRING({0} {1}, {2} {3})'.format(XA, YA, XB, YB) curR.execute(\"\"\"INSERT INTO my_line VALUES (?,GeomFromText(?, 4326))\"\"\", (1, line_wkt)) connR.commit() cursor = connR.execute(''' SELECT astext(st_intersection(geom, GeomFromText(?, 4326))) from my_line WHERE st_intersects(geom, GeomFromText(?, 4326))''', (polygon_wkt, polygon_wkt)) for item in cursor: print(item) python sqlite使用spatial扩展 ","date":"0001-01-01","objectID":"/python%E4%B8%ADsqlite%E4%BD%BF%E7%94%A8spatial%E6%89%A9%E5%B1%95/:0:0","tags":["GIS","geojson","Python","sqlite","spatial"],"title":"Python中sqlite使用spatial扩展","uri":"/python%E4%B8%ADsqlite%E4%BD%BF%E7%94%A8spatial%E6%89%A9%E5%B1%95/"},{"categories":["GIS"],"content":"来源:https://blog.csdn.net/qq_23869697/article/details/84798614 from multiprocessing.dummy import Pool as ThreadPool def process(item): log = _get_logger(item) log.info(\"item: %s\" % item) time.sleep(5) items = ['apple', 'bananan', 'cake', 'dumpling'] pool = ThreadPool() results = pool.map(process, items) pool.close() pool.join() ","date":"0001-01-01","objectID":"/python%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF%E4%BB%BB%E5%8A%A1/:0:0","tags":["Python"],"title":"Python并发/并行执行循环任务","uri":"/python%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E5%BE%AA%E7%8E%AF%E4%BB%BB%E5%8A%A1/"},{"categories":["GIS"],"content":"https://stackoverflow.com/a/68503006 def get_centroid(points): x = points[:,0] y = points[:,1] # Solving for polygon signed area A = 0 for i, value in enumerate(x): if i + 1 == len(x): A += (x[i]*y[0] - x[0]*y[i]) else: A += (x[i]*y[i+1] - x[i+1]*y[i]) A = A/2 #solving x of centroid Cx = 0 for i, value in enumerate(x): if i + 1 == len(x): Cx += (x[i]+x[0]) * ( (x[i]*y[0]) - (x[0]*y[i]) ) else: Cx += (x[i]+x[i+1]) * ( (x[i]*y[i+1]) - (x[i+1]*y[i]) ) Cx = Cx/(6*A) #solving y of centroid Cy = 0 for i , value in enumerate(y): if i+1 == len(x): Cy += (y[i]+y[0]) * ( (x[i]*y[0]) - (x[0]*y[i]) ) else: Cy += (y[i]+y[i+1]) * ( (x[i]*y[i+1]) - (x[i+1]*y[i]) ) Cy = Cy/(6*A) return Cx, Cy import numpy as np points = np.array([[0, 0], [0, 1.1], [1, 0], [1, 1]]) ","date":"0001-01-01","objectID":"/python%E8%AE%A1%E7%AE%97%E5%9D%90%E6%A0%87%E9%9B%86%E7%9A%84%E4%B8%AD%E5%BF%83%E7%82%B9%E5%9D%90%E6%A0%87/:0:0","tags":["Python","GIS"],"title":"Python计算坐标集的中心点坐标","uri":"/python%E8%AE%A1%E7%AE%97%E5%9D%90%E6%A0%87%E9%9B%86%E7%9A%84%E4%B8%AD%E5%BF%83%E7%82%B9%E5%9D%90%E6%A0%87/"},{"categories":["Python"],"content":"来源：https://learnku.com/articles/54989 在 Python 众多的 HTTP 客户端中，最有名的莫过于 requests、aiohttp 和 httpx。在不借助其他第三方库的情况下，requests 只能发送同步请求；aiohttp 只能发送异步请求；httpx 既能发送同步请求，又能发送异步请求。 所谓的同步请求，是指在单进程单线程的代码中，发起一次请求后，在收到返回结果之前，不能发起下一次请求。所谓异步请求，是指在单进程单线程的代码中，发起一次请求后，在等待网站返回结果的时间里，可以继续发送更多请求。 今天我们来一个浅度测评，仅仅以多次发送 GET 请求这个角度来对比这三个库的性能。 当然测试结果与网速有关，不过在同一段时间的同一个网络测试出来，还是能看得出来问题的。 ","date":"0001-01-01","objectID":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/:0:0","tags":["Python","异步","aiohttp"],"title":"requests、aiohttp、httpx对比","uri":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/"},{"categories":["Python"],"content":"requests ","date":"0001-01-01","objectID":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/:1:0","tags":["Python","异步","aiohttp"],"title":"requests、aiohttp、httpx对比","uri":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/"},{"categories":["Python"],"content":"发送请求 import requests url = 'https://www.baidu.com/' headers = headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'} def main(): res = requests.get(url,headers=headers) print(res.status_code) if __name__ == '__main__': main() 使用 requests.post 每次都会创建新的连接，速度较慢。而如果首先初始化一个 Session，那么 requests 会保持连接，从而大大提高请求速度。所以在这次测评中，我们分别对两种情况进行测试 ","date":"0001-01-01","objectID":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/:1:1","tags":["Python","异步","aiohttp"],"title":"requests、aiohttp、httpx对比","uri":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/"},{"categories":["Python"],"content":"有Session import time,requests url = 'https://www.baidu.com/' headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'} def make_request(): resp = requests.get(url, headers=headers) print(resp.status_code) def main(): start = time.time() for _ in range(100): make_request() end = time.time() print(f'发送100次请求，耗时：{end - start}') if __name__ == '__main__': main() 发送 100 次请求，耗时：10.295854091644287 ","date":"0001-01-01","objectID":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/:1:2","tags":["Python","异步","aiohttp"],"title":"requests、aiohttp、httpx对比","uri":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/"},{"categories":["Python"],"content":"无Session import time,requests session = requests.session() url = 'https://www.baidu.com/' headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'} def make_request(): resp = session.get(url, headers=headers) print(resp.status_code) def main(): start = time.time() for _ in range(100): make_request() end = time.time() print(f'发送100次请求，耗时：{end - start}') if __name__ == '__main__': main() 发送 100 次请求，耗时：4.679062128067017，很明显快了接近 6s ","date":"0001-01-01","objectID":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/:1:3","tags":["Python","异步","aiohttp"],"title":"requests、aiohttp、httpx对比","uri":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/"},{"categories":["Python"],"content":"httpx ","date":"0001-01-01","objectID":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/:2:0","tags":["Python","异步","aiohttp"],"title":"requests、aiohttp、httpx对比","uri":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/"},{"categories":["Python"],"content":"发送同步请求 import httpx url = 'https://www.baidu.com/' headers = headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'} def main(): res = httpx.get(url,headers=headers) print(res.status_code) if __name__ == '__main__': main() httpx 的同步模式与 requests 代码重合度 99%，只需要把 requests 改成 httpx 即可正常运行。 ","date":"0001-01-01","objectID":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/:2:1","tags":["Python","异步","aiohttp"],"title":"requests、aiohttp、httpx对比","uri":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/"},{"categories":["Python"],"content":"发送异步请求 import httpx,asyncio url = 'https://www.baidu.com/' headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'} async def main(): async with httpx.AsyncClient() as client: resp = await client.get(url, headers=headers) print(resp.status_code) if __name__ == '__main__': asyncio.run(main()) ","date":"0001-01-01","objectID":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/:2:2","tags":["Python","异步","aiohttp"],"title":"requests、aiohttp、httpx对比","uri":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/"},{"categories":["Python"],"content":"同步模式 import time import httpx url = 'https://www.baidu.com/' headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'} def make_request(): resp = httpx.get(url, headers=headers) print(resp.status_code) def main(): start = time.time() for _ in range(100): make_request() end = time.time() print(f'发送100次请求，耗时：{end - start}') if __name__ == '__main__': main() 发送 100 次请求，耗时：16.60569405555725 ","date":"0001-01-01","objectID":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/:2:3","tags":["Python","异步","aiohttp"],"title":"requests、aiohttp、httpx对比","uri":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/"},{"categories":["Python"],"content":"异步模式：只创建一次httpx.AsyncClient import httpx import asyncio import time url = 'https://www.baidu.com/' headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'} async def make_request(client): resp = await client.get(url, headers=headers) print(resp.status_code) async def main(): async with httpx.AsyncClient() as client: start = time.time() tasks = [asyncio.create_task(make_request(client)) for _ in range(100)] await asyncio.gather(*tasks) end = time.time() print(f'发送100次请求，耗时：{end - start}') if __name__ == '__main__': asyncio.run(main()) 发送 100 次请求，耗时：4.359861135482788 ","date":"0001-01-01","objectID":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/:2:4","tags":["Python","异步","aiohttp"],"title":"requests、aiohttp、httpx对比","uri":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/"},{"categories":["Python"],"content":"异步模式：每次都创建 httpx.AsyncClient import httpx import asyncio import time url = 'https://www.baidu.com/' headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'} async def make_request(): async with httpx.AsyncClient() as client: resp = await client.get(url, headers=headers) print(resp.status_code) async def main(): start = time.time() tasks = [asyncio.create_task(make_request()) for _ in range(100)] await asyncio.gather(*tasks) end = time.time() print(f'发送100次请求，耗时：{end - start}') if __name__ == '__main__': asyncio.run(main()) 发送 100 次请求，耗时：6.378381013870239 ","date":"0001-01-01","objectID":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/:2:5","tags":["Python","异步","aiohttp"],"title":"requests、aiohttp、httpx对比","uri":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/"},{"categories":["Python"],"content":"aiohttp ","date":"0001-01-01","objectID":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/:3:0","tags":["Python","异步","aiohttp"],"title":"requests、aiohttp、httpx对比","uri":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/"},{"categories":["Python"],"content":"发送请求 import asyncio,aiohttp url = 'https://www.baidu.com/' headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'} async def main(): async with aiohttp.ClientSession() as client: async with client.get(url, headers=headers) as resp: print(resp.text) print(resp.status) if __name__ == '__main__': asyncio.run(main()) aiohttp 的代码与 httpx 异步模式的代码重合度 90%，只不过把 AsyncClient 换成了 ClientSession ","date":"0001-01-01","objectID":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/:3:1","tags":["Python","异步","aiohttp"],"title":"requests、aiohttp、httpx对比","uri":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/"},{"categories":["Python"],"content":"只创建一次 aiohttp.ClientSession import time,asyncio,aiohttp url = 'https://www.baidu.com/' headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'} async def make_request(client): async with client.get(url, headers=headers) as resp: print(resp.status) async def main(): async with aiohttp.ClientSession() as client: start = time.time() tasks = [asyncio.create_task(make_request(client)) for _ in range(100)] await asyncio.gather(*tasks) end = time.time() print(f'发送100次请求，耗时：{end - start}') if __name__ == '__main__': asyncio.run(main()) 发送 100 次请求，耗时：2.235464334487915 ","date":"0001-01-01","objectID":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/:3:2","tags":["Python","异步","aiohttp"],"title":"requests、aiohttp、httpx对比","uri":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/"},{"categories":["Python"],"content":"每次都创建 aiohttp.ClientSession import time,asyncio,aiohttp url = 'https://www.baidu.com/' headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36'} async def make_request(): async with aiohttp.ClientSession() as client: async with client.get(url, headers=headers) as resp: print(resp.status) def main(): start = time.time() tasks = [asyncio.ensure_future(make_request()) for _ in range(100)] loop = asyncio.get_event_loop() loop.run_until_complete(asyncio.wait(tasks)) end = time.time() print(f'发送100次请求，耗时：{end - start}') if __name__ == '__main__': main() 发送 100 次请求，耗时：2.6662471294403076 ","date":"0001-01-01","objectID":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/:3:3","tags":["Python","异步","aiohttp"],"title":"requests、aiohttp、httpx对比","uri":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/"},{"categories":["Python"],"content":"请求 100 次速度排名 aiohttp（只创建一次client）\u003e aiohttp（每次都创建client）\u003e httpx异步只创建一次只创建一次client \u003e requests.session \u003e httpx异步 每次都创建每次都创建client \u003e requests \u003e httpx异步 ","date":"0001-01-01","objectID":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/:4:0","tags":["Python","异步","aiohttp"],"title":"requests、aiohttp、httpx对比","uri":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/"},{"categories":["Python"],"content":"总结 如果你只发几条请求。那么使用 requests 或者 httpx 的同步模式，代码最简单。 requests 是否创建一个 session 保持连接，速度差别比较大，在没有反爬的情况下，只追求速度，建议用 requests.session 如果你要发送很多请求，但是有些地方要发送同步请求，有些地方要发送异步请求，那么使用 httpx 最省事。 如果你要发送很多请求，并且越快越好，那么使用 aiohttp 最快。 ","date":"0001-01-01","objectID":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/:5:0","tags":["Python","异步","aiohttp"],"title":"requests、aiohttp、httpx对比","uri":"/requestsaiohttphttpx%E5%AF%B9%E6%AF%94/"},{"categories":["Theme Shoka Documentation"],"content":":::primary 🚀快速开始 - 💌依赖插件 - 📌基本配置 - 🌈界面显示 - 🦄特殊功能 ::: :::warning 请务必将hexo-renderer-multi-markdown-it升级到最新版，目前为 0.1.5 ::: Theme Shoka依赖以下Hexo插件 插件名称 npm地址 功能 依赖程度 hexo-renderer-multi-markdown-it 链接 md文件渲染器，压缩css/js/html 必需 hexo-autoprefixer 链接 给生成的css文件们添加浏览器前缀 必需 hexo-algoliasearch 链接 站内搜索功能 搜索按钮失灵 hexo-symbols-count-time 链接 文章或站点字数及阅读时间统计 统计没有 hexo-feed 链接 生成Feed文件 Feed文件没有 没有正确安装以上插件的话，本主题会报错or无法正确显示or部分功能失效。 hexo-renderer-multi-markdown-it请注意升级到最新版 安装完以上插件后，修改站点配置文件，加入相关配置。 multi-markdown-it安装与配置 ","date":"0001-01-01","objectID":"/dependents/:0:0","tags":["Hexo","教程"],"title":"Step.1 依赖插件","uri":"/dependents/"},{"categories":["Theme Shoka Documentation"],"content":"安装 安装前，记得务必卸载掉默认的hexo-renderer-marked，以及别的markdown文件渲染器。 npm un hexo-renderer-marked --save # 或者 yarn remove hexo-renderer-marked 安装 npm i hexo-renderer-multi-markdown-it --save # 或者 yarn add hexo-renderer-multi-markdown-it 如果安装缓慢，或者失败 如报错 ERROR: Failed to download Chromium r515411! Set \"PUPPETEER_SKIP_CHROMIUM_DOWNLOAD\" env variable to skip download. 因为有一步需要下载puppeteer里的Chromium内核，基于天朝内部网络现状，这一步能不能成功要靠科学和运气，所以为了避免安装失败，需要加上--ignore-scripts跳过Chromium内核的下载。 npm i hexo-renderer-multi-markdown-it --save --ignore-scripts # 或者 yarn add hexo-renderer-multi-markdown-it --ignore-scripts puppeteer主要是用来渲染mermaid流程图，只要文章中不使用mermaid就没有任何问题，如果要使用mermaid建议还是想办法完全安装。 ","date":"0001-01-01","objectID":"/dependents/:1:0","tags":["Hexo","教程"],"title":"Step.1 依赖插件","uri":"/dependents/"},{"categories":["Theme Shoka Documentation"],"content":"配置 加入markdown配置，用来渲染md文件 markdown: render: # 渲染器设置 html: false # 过滤 HTML 标签 xhtmlOut: true # 使用 '/' 来闭合单标签 （比如 \u003cbr /\u003e）。 breaks: true # 转换段落里的 '\\n' 到 \u003cbr\u003e。 linkify: true # 将类似 URL 的文本自动转换为链接。 typographer: quotes: '“”‘’' plugins: # markdown-it插件设置 - plugin: name: markdown-it-toc-and-anchor enable: true options: # 文章目录以及锚点应用的class名称，shoka主题必须设置成这样 tocClassName: 'toc' anchorClassName: 'anchor' - plugin: name: markdown-it-multimd-table enable: true options: multiline: true rowspan: true headerless: true - plugin: name: ./markdown-it-furigana enable: true options: fallbackParens: \"()\" - plugin: name: ./markdown-it-spoiler enable: true options: title: \"你知道得太多了\" 加入minify配置，压缩css/js/html minify: html: enable: true exclude: # 排除hexo-feed用到的模板文件 - '**/json.ejs' - '**/atom.ejs' - '**/rss.ejs' css: enable: true exclude: - '**/*.min.css' js: enable: true mangle: toplevel: true output: compress: exclude: - '**/*.min.js' 停用默认代码高亮功能，否则代码块的mac样式不能正常显示。 找到highlight和prismjs，把enable改成false。 highlight: enable: false prismjs: enable: false autoprefixer配置建议 autoprefixer: exclude: - '*.min.css' 缺少这个插件，首页卡片翻转效果在部分浏览器中无法正确显示。 algolia配置建议 algolia: appId: #Your appId apiKey: #Your apiKey adminApiKey: #Your adminApiKey chunkSize: 5000 indexName: #\"shoka\" fields: - title #必须配置 - path #必须配置 - categories #推荐配置 - content:strip:truncate,0,2000 - gallery - photos - tags feed配置建议 keywords: #站点关键词，用“,”分隔 feed: limit: 20 order_by: \"-date\" tag_dir: false category_dir: false rss: enable: true template: \"themes/shoka/layout/_alternate/rss.ejs\" output: \"rss.xml\" atom: enable: true template: \"themes/shoka/layout/_alternate/atom.ejs\" output: \"atom.xml\" jsonFeed: enable: true template: \"themes/shoka/layout/_alternate/json.ejs\" output: \"feed.json\" ","date":"0001-01-01","objectID":"/dependents/:2:0","tags":["Hexo","教程"],"title":"Step.1 依赖插件","uri":"/dependents/"},{"categories":["Theme Shoka Documentation"],"content":":::primary 🚀快速开始 - 💌依赖插件 - 📌基本配置 - 🌈界面显示 - 🦄特殊功能 ::: 站点别称 alternate: Yume Shoka 这里设置的名称代替Logo，显示在页面顶部，以及页尾©️处 静态文件目录 statics: / #//cdn.jsdelivr.net/gh/amehime/shoka@latest/ 默认值是/，指使用本地静态文件 可以修改成//cdn.jsdelivr.net/gh/您的github用户名/您的项目名@latest/这种形式，以使用jsDelivr进行加速。 PS：jsDelivr并不是实时更新，重新生成文件后需要耐心等待 css: css js: js images: images 静态文件所处目录的实际目录名，这些一般不改。 夜间模式 darkmode: # true 默认情况下，是否开启夜间模式取决于（优先级从高到低）： 访客点击页面头部切换按钮的自行选择 访客切换了浏览设备的主题色调 您的darkmode配置项 自动定位 auto_scroll: # false 默认情况下，再次打开页面时，会自动滚动到上次浏览的位置。 这个选项设为false时将停用此功能。 加载动画 # 是否显示页面加载动画loading-cat loader: start: true # 当初次打开页面时，显示加载动画 switch: true # tab切换到其他页面时，显示加载动画 tab切换后只是显示loading动画，实际并未重新加载页面 页面特效 单击页面的烟花效果配置如下 fireworks: enable: true # 是否启用 color: # 烟花颜色 - \"rgba(255,182,185,.9)\" - \"rgba(250,227,217,.9)\" - \"rgba(187,222,214,.9)\" - \"rgba(138,198,209,.9)\" 加载谷歌字体 font: enable: true # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: x.x`. Use `em` as unit. Default: 1 (16px) # Global font settings used for all elements inside \u003cbody\u003e. global: external: true family: Mulish size: # Font settings for alternate title. logo: external: true family: Fredericka the Great size: 3.5 # Font settings for site title. title: external: true family: Noto Serif JP size: 2.5 # Font settings for headlines (\u003ch1\u003e to \u003ch6\u003e). headings: external: true family: Noto Serif SC size: # Font settings for posts. posts: external: true family: # Font settings for \u003ccode\u003e and code blocks. codes: external: true family: Inconsolata 此功能基本参考NexT。 加粗标题的字体总是使用Noto Serif，为了正确友好的显示日文中的汉字，会先后加载headings和title的字体设置。 iconfont图标 主题没有直接使用Font Awesome，是因为用不到那么多icon感觉非常浪费，因此在Iconfont上重新建立了一个项目。 font-family设为ic，所有字体样式前缀为i-，具体参见\u003croot\u003e/themes/shoka/source/css/_iconfont.styl。 # project of https://www.iconfont.cn/ # //at.alicdn.com/t/font_1832207_c8i9n1ulxlt.css =\u003e 1832207_c8i9n1ulxlt iconfont: \"1832207_c8i9n1ulxlt\" 如果需要添加或修改，请留言告诉我您的Iconfont用户名，我将把您添加到目前的项目中。 添加权限为只读，此后您可以任意全选，批量保存到购物车中，添加至您自己的项目里，并将主题配置文件中的iconfont值改为您的项目。 注意，您的项目应设置FontClass/Symbol 前缀为i-。 在\u003croot\u003e/source/_data/目录新建文件iconfont.styl，把新增或修改的图标样式复制到这个文件中。 自定义iconfont.styl文件将覆盖主题默认样式，为了避免出错，请保证原有样式名均存在，在原有样式基础上进行增删改。 菜单与社交按钮 menu: home: / || home about: /about/ || user posts: default: / || feather archives: /archives/ || list-alt categories: /categories/ || th tags: /tags/ || tags # friends: /friends/ || heart # links: /links/ || magic social: github: https://github.com/yourname || github || \"#191717\" #google: https://plus.google.com/yourname || google twitter: https://twitter.com/yourname || twitter || \"#00aff0\" zhihu: https://www.zhihu.com/people/yourname || zhihu || \"#1e88e5\" music: https://music.163.com/#/user/home?id=yourid || cloud-music || \"#e60026\" weibo: https://weibo.com/yourname || weibo || \"#ea716e\" about: https://about.me/yourname || address-card || \"#3b5998\" #email: mailto:yourname@mail.com || envelope || \"#55acd5\" #facebook: https://www.facebook.com/yourname || facebook #stackoverflow: https://stackoverflow.com/yourname || stack-overflow #youtube: https://youtube.com/yourname || youtube #instagram: https://instagram.com/yourname || instagram #skype: skype:yourname?call|chat || skype #douban: https://www.douban.com/people/yourname/ || douban 如上，使用||作为分隔符，依次为 链接 || 图标 || 颜色。 注意，只需要写图标名称，如github，则会自动转换为ic i-github。 十六进制颜色码需要\"\"包绕。 menu 支持一级子目录，子目录设置中的第一项必须为default，用来定义父级按钮的样式。 菜单显示文字可以在语言包中定义，具体请戳这里 边栏配置 边栏可以选择在左侧，或右侧 修改头像文件的地址，相对于静态文件目录images中配置的路径。 sidebar: # Sidebar Position. position: left #position: right # Replace the default avatar image and set the url here. avatar: avatar.jpg 可以将自己的图片放在\u003croot\u003e/source/_data/images/目录，甚至以同名覆盖主题内默认的头像图片，具体请戳这里 底部widgets 目前页面底部可以显示两个小部件，即随机文章和最近评论。 widgets: random_posts: true # 显示随机文章 recent_comments: true # 显示最近评论 字数及阅读时间统计 安装好hexo-symbols-count-time插件后，不需要修改站点配置文件，直接使用插件默认配置就行。 需要修改主题配置文件，找到两处cout，修改为true： # 页尾全站统计 footer: since: 2010 count: true # 文章界面统计 post: count: true 文章评论 如何获取LeanCloud的appId和appKey。 valine: appId: #Your_appId appK","date":"0001-01-01","objectID":"/config/:0:0","tags":["Hexo","教程"],"title":"Step.2 基本配置","uri":"/config/"},{"categories":["Theme Shoka Documentation"],"content":":::primary 🚀快速开始 - 💌依赖插件 - 📌基本配置 - 🌈界面显示 - 🦄特殊功能 ::: 首页置顶文章 在文章的Front Matter设置sticky: true，则该文章将显示在首页最上方的置顶文章列。 多篇文章按照发布时间倒序排列，不分页。 --- title: 置顶文章 sticky: true --- 首页精选分类 想要在首页显示分类翻转块，需要按照以下示例的方式，给需要显示的分类加上封面图。 首先，修改站点配置： 找到category_map:，配置每个分类对应的英文映射，比如： category_map: 计算机科学: computer-science Java: java C++: cpp 二进制杂谈: note 计算机程序设计（C++）-西安交通大学: course-1 零基础学Java语言-浙江大学-翁恺: course-1 面向对象程序设计-Java语言-浙江大学-翁恺: course-2 注意：hexo会自动处理路径中的特殊字符，~`!@#$%^\u0026*()-_+=[]{}|\\;:\"’\u003c\u003e,.?以及空格，这些全部会被替换成- 所以避免在设置中使用上述字符，否则可导致无法抓取到目录下的cover.jpg 在\u003croot\u003e/source/_posts文件夹相应的目录里，存放封面图 例子：如 第1周 计算 这篇文章。 所处的分类是 categories: - [计算机科学, Java, 零基础学Java语言-浙江大学-翁恺] 现在需要在首页显示零基础学Java语言-浙江大学-翁恺这个分类，翻转卡片后，显示这个分类下的文章们。 而该分类经过英文映射，它的路径将是/computer-science/java/course-1/。 那么，请在\u003croot\u003e/source/_posts/computer-science/java/course-1/的目录下放置cover.jpg文件。 只要分类路径对应的目录下存在cover.jpg文件，这个分类就会在首页显示。 在进行hexo g时，本分类的封面图会自动被复制到public目录里相应的位置。 事实上，为了方便文章管理，这个分类下所有文章的md文件，我都会放在\u003croot\u003e/source/_posts/computer-science/java/course-1/这个目录下。 且站点配置文件里，永久链接设置如下 permalink: :title/ hexo g后，文章的html文件们将全部生成到\u003croot\u003e/public/computer-science/java/course-1/目录。 具体可以查看本博客的github仓库。 文章详情界面中的系列文章，显示的是与当前文章同一分类的其他文章，并按照文章名正序排序。 o(*￣▽￣*)ゞ 其实，不设置category_map也可以，只要在分类路径对应的文件夹下存在cover.jpg文件就行。 现在，这项功能与category_dir的配置也无关，hexo g生成后，图片会自动被转移到category_dir的相关子目录下。 文章封面图 如果文章的Front Matter设置了cover: image path，则封面会显示这张图片。 title: Images cover: assets/wallpaper-2572384.jpg # 或者写成 cover: http://placehold.it/350x150.jpg --- 这里cover的值可以是位于source目录里的图片文件，此处是\u003croot\u003e/source/assets/wallpaper-2572384.jpg文件，也可以是一个某网址。 如果文章是一个gallery post，即Front Matter设置了photos，则会封面会显示设置的第一张图片。 title: Gallery Post photos: - assets/wallpaper-2572384.jpg - assets/wallpaper-2311325.jpg - assets/wallpaper-878514.jpg - http://placehold.it/350x150.jpg --- 此时默认会显示第一个图片，即位于\u003croot\u003e/source/assets/目录里的wallpaper-2572384.jpg。 如果站点配置中设置了post_asset_folder: true，那么上述本地图片路径应为\u003croot\u003e/source/_posts/文章同名的文件夹/assets/wallpaper-2572384.jpg，当然此时assets目录可以省掉。 如果以上设置均不存在，将显示一张随机图片，随机图库配置戳此。 图片展示与相册 在文章的Front Matter设置fancybox: false，可以关闭文章页的图片展示功能。 使用Justified-Gallery对Gallery Post内图案进行排列。 下面介绍一些小技巧： 让图案下方显示title的markdown代码 ![这里是alt](https://tva3.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg \"这里是title\") 这里是title 除了在Front Matter里配置photos可以显示相册图案列表外，还可以这样写 ## 图案列表No.1 ![](https://tva3.sinaimg.cn/large/6833939bly1giclfdu6exj20zk0m87hw.jpg \"这里是title\") ![](https://tva3.sinaimg.cn/large/6833939bly1giclflwv2aj20zk0m84qp.jpg) ![](https://tva3.sinaimg.cn/large/6833939bly1giclg5ms2rj20zk0m8u0x.jpg) ![](https://tva3.sinaimg.cn/large/6833939bly1giclhnx9glj20zk0m8npd.jpg) {.gallery} ## 图案列表No.2 ![](https://tva3.sinaimg.cn/large/6833939bly1gicitht3xtj20zk0m8k5v.jpg) ![](https://tva3.sinaimg.cn/large/6833939bly1giclil3m4ej20zk0m8tn8.jpg) ![](https://tva3.sinaimg.cn/large/6833939bly1gicljgocqbj20zk0m8e81.jpg) ![](https://tva3.sinaimg.cn/large/6833939bly1gipetfk5zwj20zk0m8e81.jpg) {.gallery data-height=\"220\"} data-height用来设置每行的高度，默认为120 ","date":"0001-01-01","objectID":"/display/:0:0","tags":["Hexo","教程"],"title":"Step.3 界面显示","uri":"/display/"},{"categories":["Theme Shoka Documentation"],"content":"图案列表No.1 这里是title {.gallery} ","date":"0001-01-01","objectID":"/display/:1:0","tags":["Hexo","教程"],"title":"Step.3 界面显示","uri":"/display/"},{"categories":["Theme Shoka Documentation"],"content":"图案列表No.2 {.gallery data-height=“220”} 自定义页面配色 主题配色全部在\u003croot\u003e/themes/shoka/source/css/_colors.styl文件中，可以自行查看。 在\u003croot\u003e/source/_data/目录新建文件colors.styl，在此文件中添改样式。 自定义colors.styl文件将覆盖主题默认样式，为了避免出错，请保证原有样式名均存在，在原有样式基础上进行增删改。 主题支持在\u003croot\u003e/source/_data/目录建立三个自定义styl文件： 自定义文件名 对应默认样式文件 样式功能 colors.styl _colors.styl 页面配色 iconfont.styl _iconfont.styl 图标样式 custom.styl - 任意自定义样式 自定义主题图片 如果想要修改主题的\u003croot\u003e/themes/shoka/source/images/目录内的某张图片，请在\u003croot\u003e/source/_data/目录新建目录images，并在这个文件夹中添加++同名++文件，部署时将自动覆盖主题内的默认图片。 可以用此方法自定义头像、打赏二维码等图片，并且避免覆盖更新主题时遗失自定义文件。 自定义语言包 本功能参考NexT，主要可以用来定义菜单等处显示的文字，且可以方便主题无脑覆盖升级。 在\u003croot\u003e/source/_data/目录新建文件languages.yml。 按照以下格式添加配置项： # language zh-CN: # items post: copyright: # the translation you perfer author: 本文博主 en: menu: travellings: Travellings 可以参考主题目录下的example/source/_data文件夹。 站点配置及文件的Front Matter中，language项只支持zh-CN、zh-HK、zh-TW、ja、en。 类似写成zh_CN这样是不可以的。 ","date":"0001-01-01","objectID":"/display/:2:0","tags":["Hexo","教程"],"title":"Step.3 界面显示","uri":"/display/"},{"categories":["Theme Shoka Documentation"],"content":":::primary 🚀快速开始 - 💌依赖插件 - 📌基本配置 - 🌈界面显示 - 🦄特殊功能 ::: :::info 以下介绍可以使用的markdown或者标签代码。 功能大部分基于hexo-renderer-multi-markdown-it渲染器，尤其是代码块的显示，与默认渲染器不兼容。 ::: links 链接块 本功能参考NexT，基于Hexo Tag功能，用来建立友链或其他网址链接功能。 文章中的使用格式： 使用links标签块，包围yml语法书写的内容，字段包括 –|–|– site|站点名称|必填 owner|管理员名字|可选，默认为site的值 url|站点链接|必填 desc|站点描述|可选，默认为url的值 image|站点图片|可选，默认为images/404.png color|方块颜色|可选，默认为#666 \u0026#123;% links %\u0026#125; - site: #站点名称 owner: #管理员名字 url: #站点网址 desc: #简短描述 image: #一张图片 color: #颜色代码 \u0026#123;% endlinks %\u0026#125; 举个栗子： \u0026#123;% links %\u0026#125; - site: 優萌初華 owner: 霜月琉璃 url: https://shoka.lostyu.me desc: 琉璃的医学 \u0026 编程笔记 image: https://cdn.jsdelivr.net/gh/amehime/shoka@latest/images/avatar.jpg color: \"#e9546b\" - site: 優萌初華 owner: 霜月琉璃 url: https://shoka.lostyu.me image: images/avatar.jpg - site: 優萌初華 url: https://shoka.lostyu.me desc: 琉璃的医学 \u0026 编程笔记 color: \"#9d5b8b\" \u0026#123;% endlinks %\u0026#125; {% links %} site: 優萌初華 owner: 霜月琉璃 url: https://shoka.lostyu.me desc: 琉璃的医学 \u0026 编程笔记 image: https://cdn.jsdelivr.net/gh/amehime/shoka@latest/images/avatar.jpg color: “#e9546b” site: 優萌初華 owner: 霜月琉璃 url: https://shoka.lostyu.me image: images/avatar.jpg site: 優萌初華 url: https://shoka.lostyu.me desc: 琉璃的医学 \u0026 编程笔记 color: “#9d5b8b” {% endlinks %} 以上标签块里的内容，还可以保存到一个yml文件中，然后使用linksfile标签。 其中，path位于\u003croot\u003e/source目录下。 \u0026#123;% linksfile [path] %\u0026#125; 举个栗子： \u0026#123;% linksfile friends/_data.yml %\u0026#125; code代码块 使用markdown-it-prism进行代码高亮，支持显示行号、行高亮mark、命令行提示符command、代码块标题。 基本格式：[language] [title] [url] [link text] [mark] [command] 选项 描述 默认值 language - 支持的语言戳此 null \\ - 如果不需要代码高亮，但希望显示代码块样式，则设为raw \\ - 留空或设为info，将不显示代码高亮和代码块样式 title 代码块的标题文字 null url 代码块标题右侧显示的链接 null link text 上述链接显示的标题 link mark 行高亮显示，格式为mark:行号,行号开始-行号结束,其他行号。 null \\ 例如mark:1,4-7,10，将高亮显示第1、4、5、6、7、10行 command 命令行提示符，格式为`command:(“提示内容”:行号,行号 例如`command:(\"[root@localhost] $\":1,9-10 ```java 行高亮 https://shoka.lostyu.me 参考链接 mark:1,6-7 import java.util.Scanner; ... Scanner in = new Scanner(System.in); // 输入Scan之后，按下键盘 Alt + “/” 键，Eclipse下自动补全。 System.out.println(in.nextLine()); System.out.println(\"Hello\" + \" world.\"); ``` ```bash 命令行提示符 command:(\"[root@localhost] $\":1,9-10||\"[admin@remotehost] #\":4-6) pwd /usr/home/chris/bin ls -la total 2 drwxr-xr-x 2 chris chris 11 Jan 10 16:48 . drwxr--r-x 45 chris chris 92 Feb 14 11:10 .. -rwxr-xr-x 1 chris chris 444 Aug 25 2013 backup -rwxr-xr-x 1 chris chris 642 Jan 17 14:42 deploy git add -A git commit -m \"update\" git push ``` import java.util.Scanner; ... Scanner in = new Scanner(System.in); // 输入Scan之后，按下键盘 Alt + “/” 键，Eclipse下自动补全。 System.out.println(in.nextLine()); System.out.println(\"Hello\" + \" world.\"); pwd /usr/home/chris/bin ls -la total 2 drwxr-xr-x 2 chris chris 11 Jan 10 16:48 . drwxr--r-x 45 chris chris 92 Feb 14 11:10 .. -rwxr-xr-x 1 chris chris 444 Aug 25 2013 backup -rwxr-xr-x 1 chris chris 642 Jan 17 14:42 deploy git add -A git commit -m \"update\" git push quiz 练习题与答案 这个功能是用来显示练习题的。 需要在Front Matter中添加quiz: true，以正确显示题型标签。 --- title: 练习题与答案 quiz: true --- 1. 编译时多态主要指运算符重载与函数重载，而运行时多态主要指虚函数。 {.quiz .true} 2. 有基类`SHAPE`，派生类`CIRCLE`，声明如下变量： {.quiz .multi} ```cpp SHAPE shape1,*p1; CIRCLE circle1,*q1; ``` 下列哪些项是“派生类对象替换基类对象”。 - `p1=\u0026circle1;` {.correct} - `q1=\u0026shape1;` - `shape1=circle1;` {.correct} - `circle1=shape1;` {.options} \u003e - ✔️ 令基类对象的指针指向派生类对象 \u003e - ❌ 派生类指针指向基类的引用 \u003e - ✔️ 派生类对象给基类对象赋值 \u003e - ❌ 基类对象给派生类对象赋值 \u003e {.options} 3. 下列叙述正确的是 []{.gap} 。 {.quiz} - 虚函数只能定义成无参函数 - 虚函数不能有返回值 - 能定义虚构造函数 - A、B、C都不对 {.correct} {.options} 10. 如果定义`int e=8; double f=6.4, g=8.9;`，则表达式 `f+int(e/3*int(f+g)/2)%4` 的值为 [9.4]{.gap}。 {.quiz .fill} \u003e 注意运算顺序和数据类型 \u003e [8.4]{.mistake} 点击选项可以显示答案，以及答案解析。 下列叙述正确的是 []{.gap} 。 {.quiz} 虚函数只能定义成无参函数 虚函数不能有返回值 能定义虚构造函数 A、B、C都不对 {.correct} {.options} 有基类SHAPE，派生类CIRCLE，声明如下变量： {.quiz .multi} SHAPE shape1,*p1; CIRCLE circle1,*q1; 下列哪些项是“派生类对象替换基类对象”。 p1=\u0026circle1; {.correct} q1=\u0026shape1; shape1=circle1; {.correct} circle1=shape1; {.options} ✔️ 令基类对象的指针指向派生类对象 ❌ 派生类指针指向基类的引用 ✔️ 派生类对象给基类对象赋值 ❌ 基类对象给派生类对象赋值 {.options} 编译时多态主要指运算符重载与函数重载，而运行时多态主要指虚函数。 {.quiz .true} 如果定义i","date":"0001-01-01","objectID":"/special/:0:0","tags":["Hexo","教程"],"title":"Step.4 主题特殊功能","uri":"/special/"},{"categories":["Theme Shoka Documentation"],"content":"使用说明 本功能基于markdown-it-bracketed-spans和markdown-it-attrs 标签 含义 {.quiz} 选择题 {.quiz .multi} 多选题 {.quiz .true} 正确的判断题 {.quiz .false} 错误的判断题 {.quiz .fill} 填空题 []{.gap} 空白下划线 [答案内容]{.gap} 答案内容带下划线 {.options} ABCDE选项 {.correct} 选择题的正确选项 \u003e 答案解析 [8.4]{.mistake} 错题备注 emoji 绘文字 本功能基于markdown-it-emoji，所有标签参考戳此 😘 💍 🎶 😘 💍 🎶 effects 文字特效 本功能基于markdown-it-ins、 markdown-it-bracketed-spans和markdown-it-attrs 本主题风格颜色通用样式：default、primary、success、info、warning、danger ++下划线++ ++波浪线++{.wavy} ++着重点++{.dot} ++紫色下划线++{.primary} ++绿色波浪线++{.wavy .success} ++黄色着重点++{.dot .warning} ~~删除线~~ ~~红色删除线~~{.danger} ==荧光高亮== [赤橙黄绿青蓝紫]{.rainbow} [红色]{.red} [粉色]{.pink} [橙色]{.orange} [红色]{.yellow} [绿色]{.green} [靛青]{.aqua} [蓝色]{.blue} [紫色]{.purple} [灰色]{.grey} 快捷键 [Ctrl]{.kbd} + [C]{.kbd .red} H~2~0 29^th^ :::warning 这段代码因为自动被pangu.js处理了一下，加了几个空格，导致直接复制代码不能正常显示。 正确的代码是++下划线++ ~~删除线~~ ==荧光高亮==，不能有空格哦。 ::: ++下划线++ ++波浪线++{.wavy} ++着重点++{.dot} ++紫色下划线++{.primary} ++绿色波浪线++{.wavy .success} ++黄色着重点++{.dot .warning} 删除线 红色删除线{.danger} ==荧光高亮== [赤橙黄绿青蓝紫]{.rainbow} [红色]{.red} [粉色]{.pink} [橙色]{.orange} [黄色]{.yellow} [绿色]{.green} [靛青]{.aqua} [蓝色]{.blue} [紫色]{.purple} [灰色]{.grey} 快捷键 [Ctrl]{.kbd} + [C]{.kbd .red} H~2~0 29^th^ spoiler隐藏文字 本功能基于markdown-it-spoiler和markdown-it-attrs !!黑幕黑幕黑幕黑幕黑幕黑幕!! ： 鼠标滑过显示内容 !!模糊模糊模糊模糊模糊模糊!!{.bulr} ： 选中文字显示内容 !!黑幕黑幕黑幕黑幕黑幕黑幕!! ： 鼠标滑过显示内容 !!模糊模糊模糊模糊模糊模糊!!{.bulr} ： 选中文字显示内容 label 标签块 本功能基于markdown-it-bracketed-spans和markdown-it-attrs 有以下颜色可选 [default]{.label} [primary]{.label .primary} [info]{.label .info} [✔️success]{.label .success} [warning]{.label .warning} [💔danger]{.label .danger} [default]{.label} [primary]{.label .primary} [info]{.label .info} [✔️success]{.label .success} [warning]{.label .warning} [💔danger]{.label .danger} note 提醒块 本功能基于markdown-it-container 标签为： –|– 开始行|:::[风格颜色] 结束行|::: :::default 默认默认 ::: :::primary 基本基本 ::: :::info 提示提示 ::: :::success 成功成功 ::: :::warning 警告警告 ::: :::danger 危险危险 ::: :::danger no-icon 危险危险 ::: :::default 默认默认 ::: :::primary 基本基本 ::: :::info 提示提示 ::: :::success 成功成功 ::: :::warning 警告警告 ::: :::danger 危险危险 ::: :::danger no-icon 没有图标 ::: tab标签卡 本功能基于markdown-it-container 标签为： –|– 开始行|;;;[同一ID] [标签名称] 结束行|;;; ;;;id1 卡片1 这里是卡片1的内容 **加粗** [success]{.label .success} \u0026#123;% links %\u0026#125; - site: 優萌初華 owner: 霜月琉璃 url: https://shoka.lostyu.me desc: 琉璃的医学 \u0026 编程笔记 image: https://cdn.jsdelivr.net/gh/amehime/shoka@latest/images/avatar.jpg color: \"#e9546b\" \u0026#123;% endlinks %\u0026#125; ;;; ;;;id1 卡片2 这里是卡片2的内容 :::danger 危险危险 ::: - 第一行 - 第二行 ;;; ;;;id2 ②号标签卡片1 这里是卡片1的内容 ;;; ;;;id2 ②号标签卡片2 这里是卡片2的内容 ;;; ;;;id1 卡片1 这里是卡片1的内容 加粗 [success]{.label .success} {% links %} site: 優萌初華 owner: 霜月琉璃 url: https://shoka.lostyu.me desc: 琉璃的医学 \u0026 编程笔记 image: https://cdn.jsdelivr.net/gh/amehime/shoka@latest/images/avatar.jpg color: “#e9546b” {% endlinks %} ;;; ;;;id1 卡片2 这里是卡片2的内容 :::danger 危险危险 ::: 第一行 第二行 ;;; ;;;id2 ②号标签卡片1 这里是卡片1的内容 ;;; ;;;id2 ②号标签卡片2 这里是卡片2的内容 ;;; collapse 折叠块 本功能基于markdown-it-container 标签为： –|– 开始行|+++[风格颜色] [标题文字] 结束行|+++ +++ 默认默认 这里是一段文字 ++下划线++ +++ +++primary 紫色 :::info 参考信息 ::: - 第一行 - 第二行 +++ +++info 蓝色 ;;;id3 卡片1 这里是卡片1的内容 ;;; ;;;id3 卡片2 这里是卡片2的内容 ;;; +++ +++success 绿色 \u0026#123;% links %\u0026#125; - site: 優萌初華 url: https://shoka.lostyu.me color: \"#e9546b\" \u0026#123;% endlinks %\u0026#125; +++ +++warning 黄色 !!警告警告警告警告警告!!{.bulr} [label]{.label .success} +++ +++danger 红色 [danger]{.label .danger} +++ +++ 默认默认 这里是一段文字 ++下划线++ +++ +++primary 紫色 :::info 参考信息 ::: 第一行 第二行 +++ +++info 蓝色 ;;;id3 卡片1 这里是卡片1的内容 ++波浪线++{.wavy} ;;; ;;;id3 卡片2 这里是卡片2的内容 ;;; +++ +++success 绿色 {% links %} site: 優萌初華 url: https://shoka.lostyu.me color: “#e9546b” {% endlinks %} +++ +++warning 黄色 !!警告警告警告警告警告!!{.bulr} [label]{.label .success} +++ +++danger 红色 [danger]{.label .danger} +++ taskList 待办事项 本功能基于markdown-it-task-checkbox。 可以利用markdown-it-attrs添加风格颜色，只可以给ul标签添加，需要新建两行。 - [ ] 这是一个小叉叉 - [x] 这是一个红色勾勾 {.danger} - [ ] 未完成 - [x] 完成 {.primary} - [ ] 未完成 - [x] 默认颜色 这是一个小叉叉 这是一个红色勾勾 {.danger} 未完成 完成 {.primary} 未完成 默认颜色 furigana文字注音 原本用于日语汉字假名注音，但别的注音也可以。 为了兼容性，采用markdown","date":"0001-01-01","objectID":"/special/:1:0","tags":["Hexo","教程"],"title":"Step.4 主题特殊功能","uri":"/special/"},{"categories":["GIS"],"content":"方法一（参考Python一行代码处理地理围栏） from shapely.geometry import Point from shapely.geometry.polygon import Polygon polygon_data= [[114.3458104133606,30.476167529462785],[114.34512376785278,30.475575748963195],[114.34576749801636,30.474540124433936],[114.3467652797699,30.475363076967565],[114.34693694114685,30.476102803645833],[114.3458104133606,30.476167529462785]] point1 = Point([114.34605717658997,30.475584995561178]) point2 = Point([114.346604347229,30.476518897432545]) polygon = Polygon(polygon_data) print(polygon.contains(point1)) print(polygon.contains(point2)) #输出 # True # False ","date":"0001-01-01","objectID":"/%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85check-is-the-point-in-polygon/:1:0","tags":["Python","GIS"],"title":"判断点是否在多边形内（check is the point in polygon）","uri":"/%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85check-is-the-point-in-polygon/"},{"categories":["GIS"],"content":"方法二 光线追踪 def is_inside_sm(polygon, point): length = len(polygon)-1 dy2 = point[1] - polygon[0][1] intersections = 0 ii = 0 jj = 1 while ii\u003clength: dy = dy2 dy2 = point[1] - polygon[jj][1] # consider only lines which are not completely above/bellow/right from the point if dy*dy2 \u003c= 0.0 and (point[0] \u003e= polygon[ii][0] or point[0] \u003e= polygon[jj][0]): # non-horizontal line if dy\u003c0 or dy2\u003c0: F = dy*(polygon[jj][0] - polygon[ii][0])/(dy-dy2) + polygon[ii][0] if point[0] \u003e F: # if line is left from the point - the ray moving towards left, will intersect it intersections += 1 elif point[0] == F: # point on line return 2 # point on upper peak (dy2=dx2=0) or horizontal line (dy=dy2=0 and dx*dx2\u003c=0) elif dy2==0 and (point[0]==polygon[jj][0] or (dy==0 and (point[0]-polygon[ii][0])*(point[0]-polygon[jj][0])\u003c=0)): return 2 ii = jj jj += 1 #print 'intersections =', intersections return intersections \u0026 1 polygon_data= [[114.3458104133606,30.476167529462785],[114.34512376785278,30.475575748963195],[114.34576749801636,30.474540124433936],[114.3467652797699,30.475363076967565],[114.34693694114685,30.476102803645833],[114.3458104133606,30.476167529462785]] points = [[114.34605717658997,30.475584995561178],[114.346604347229,30.476518897432545]] for point in points: x = is_inside_sm(polygon_data,point) print(x) ","date":"0001-01-01","objectID":"/%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85check-is-the-point-in-polygon/:2:0","tags":["Python","GIS"],"title":"判断点是否在多边形内（check is the point in polygon）","uri":"/%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85check-is-the-point-in-polygon/"},{"categories":["GIS"],"content":"方法三 参考一：Python一行代码处理地理围栏 参考二：Python中检查点是否在多边形内，哪种方法是最快的 参考二中提到的最快算法来源 Github源码 ","date":"0001-01-01","objectID":"/%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85check-is-the-point-in-polygon/:3:0","tags":["Python","GIS"],"title":"判断点是否在多边形内（check is the point in polygon）","uri":"/%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85check-is-the-point-in-polygon/"},{"categories":["Python"],"content":" import time from aiohttp import ClientSession,TCPConnector from pprint import pprint as print import asyncio url = 'https://api.panhvhg.xyz/api/v3/channels/968/connect' url='https://api.panhvhg.xyz/api/v3/channels/0/connect' headers = { 'Host': 'api.panhvhg.xyz', 'api-version': 'v3.0', 'request_raw_response_body_tag_header': '8', 'accept': 'application/json', 'content-type': 'application/json', 'accept-language': 'zh-CN', 'device-identifier': '6961EB763D32FDD1116C00092E0B9365', 'device-type': 'ANDROID', 'product-identifier': 'panda', 'authorization': 'Bearer eyJleHAiOjE3MTM4OTc1NjcsInVzZXJJZCI6MzUyNzQ3NjksImRldmljZUlkIjozNTIzNDgxMCwiaWF0IjoxNjI3NDk3NTY3fQ.AMxXjoPi1HdPTlQ9h3eUq8VFpS40kLDvKTVCt787HQA', 'user-agent': 'okhttp/4.9.0 android/10(ufkckcuuuccucfc) panda/5.5.0(91)', # 'x-timestamp': '1627507529', 'content-length': '0', 'accept-encoding': 'gzip', } async def make_request(client): async with client.post(url, headers=headers) as resp: s=await resp.json() return s async def main(): cons = TCPConnector(limit=11) # 限制QOS，具体以网速不同而不同，需要测试，同时，需要先导入aiohttp.TCPConnector模块 async with ClientSession(connector=cons) as client: starttime = time.time() tasks = [asyncio.create_task(make_request(client)) for _ in range(1000)] s = await asyncio.gather(*tasks) endtime = time.time() print(f\"QOS:{len(tasks)/(starttime-endtime)}\") return s if __name__ == '__main__': start = time.time() s=asyncio.run(main()) # jupyter环境使用await main() print(len(s)) end = time.time() print(f'发送10次请求，耗时：{end - start}') ","date":"0001-01-01","objectID":"/%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91aiohttp/:0:0","tags":["Python","异步","aiohttp"],"title":"异步并发aiohttp","uri":"/%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91aiohttp/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":":::note info 以下为个人学习笔记和习题整理 课程：零基础学Java语言-浙江大学-翁恺 @ 中国大学MOOC https://www.icourse163.org/course/ZJU-1001541001 ::: 课堂笔记 ","date":"0001-01-01","objectID":"/week-1/:0:0","tags":null,"title":"第1周 计算","uri":"/week-1/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"读输入、字符串输出 import java.util.Scanner; ... Scanner in = new Scanner(System.in); // 输入Scan之后，按下键盘 Alt + “/” 键，Eclipse下自动补全。 System.out.println(in.nextLine()); // 让in这个对象做读入下一行的动作，结果交给System.out这个对象去打印一行。 // 字符串的 + 用来连接两个字符串形成更长的字符串。 System.out.println(\"Hello\" + \" world.\"); System.out.println(\"Hello\" + 2); System.out.println(\"Hello\" + 2 + 3); System.out.println(2 + 3 + \"Hello\"); tips： System.out.println 会换行，System.out.print 则不会换行 出现警告：Resource leak: 'in' is never closed，可以在函数的最后加入 in.close();//释放 ","date":"0001-01-01","objectID":"/week-1/:1:0","tags":null,"title":"第1周 计算","uri":"/week-1/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"变量 形式：\u003c类型名称\u003e \u003c变量名称\u003e = \u003c初始值\u003e int price, amount; // 同时定义两个变量 int price = 0; // 定义变量并赋值 int price, amount = 100, age; 类型名称：Java是一种强类型语言，所有变量在使用前必须定义或声明，所有变量必须具有确定的数据类型。数据类型表示在变量中可以存放什么样的数据，程序运行过程中也不能改变变量的类型。 变量名称：又称标识符，只能由字母、数字、下划线构成，数字不能出现在第一个位置。此外，Java的保留字也不能用作标识符。 Java的保留字列表 abstract do implements protected throws boolean double import public transient break else instanceof return true byte extends int short try case false interface static while catch final long strictfp void char finally native super volatile class float new switch const* for null synchronized continue goto* package this default if private throw 以下哪些标识符是符合规则的？ currency lastName fireplace _last_name xingmin class goto 4ever time-machine Int $12 我是变量 ","date":"0001-01-01","objectID":"/week-1/:2:0","tags":null,"title":"第1周 计算","uri":"/week-1/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"常量 final final int AMOUNT = 100; // final是一个修饰符，表示这个变量的值一旦初始化，就不能再修改了。 ","date":"0001-01-01","objectID":"/week-1/:3:0","tags":null,"title":"第1周 计算","uri":"/week-1/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"变量类型 ","date":"0001-01-01","objectID":"/week-1/:4:0","tags":null,"title":"第1周 计算","uri":"/week-1/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"整数 int int price = in.nextInt(); 如果用户输入的不是整数，则会报错 java.util.InputMismatchException。 程序要求读入多个数字时，可以在一行输入，中间用空格分开，也可以多行输入。 每次召唤in.nextInt()，它就等待用户输入一个整数。 两个整数的运算结果只能是整数。 在Java中，10和10.0是完全不同的数。 ","date":"0001-01-01","objectID":"/week-1/:4:1","tags":null,"title":"第1周 计算","uri":"/week-1/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"浮点数 double 浮点数运算有误差：由于二进制的自身限制，浮点计算需要将十进制先转换为二进制，然后对二进制数进行计算，因此导致误差。 System.out.println(1.2-1.1); // 结果为 0.09999999999999987 整数类型不能表达有小数部分的数；整数运算速度快，占内存小；日常中整数运算多。 ","date":"0001-01-01","objectID":"/week-1/:4:2","tags":null,"title":"第1周 计算","uri":"/week-1/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"赋值运算 ","date":"0001-01-01","objectID":"/week-1/:5:0","tags":null,"title":"第1周 计算","uri":"/week-1/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"强制类型转换 浮点数和整数放在一起运算时，Java会将整数转换成浮点数，然后进行浮点数运算。 强制性转换的优先级高于四则运算。 double a = 1.0; double b = 2.0; int i = (int)a/b; //会报错 int i = (int)(a/b); //不会报错 ","date":"0001-01-01","objectID":"/week-1/:5:1","tags":null,"title":"第1周 计算","uri":"/week-1/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"运算符优先级 单目运算符+ - 优先级最高 结合关系一般自左向右，单目+ -和赋值=自右向左。 result = a = b = 3 + c; result = 2; result = (result = result * 2) * 6 * (result = 3 + result); ","date":"0001-01-01","objectID":"/week-1/:5:2","tags":null,"title":"第1周 计算","uri":"/week-1/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"复合赋值 5个算术运算符，+ - * / %，可以和赋值运算符 = 结合起来，形成复合赋值运算。注意，两个运算符中间不要有空格。 total += (sum+100)/2; total = total + (sum+100)/2; total * = sum+12; total = total*(sum+12); total /= 12+6; total = total / (12+6); 递增递减运算符 ++ --，给变量+1或-1 前缀后缀： a = 14; t1 = a++; // t1先被赋值为 a 即14， a自加到 15 t2 = ++a; // a先自加到 15，t2被赋值为 a 即 15 编程题 ","date":"0001-01-01","objectID":"/week-1/:5:3","tags":null,"title":"第1周 计算","uri":"/week-1/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"题目1. 温度转换（5分） 题目内容 写一个将华氏温度转换成摄氏温度的程序，转换的公式是： °F = (9/5)*°C + 32 其中C表示摄氏温度，F表示华氏温度。 程序的输入是一个整数，表示华氏温度。输出对应的摄氏温度，也是一个整数。 提示，为了把计算结果的浮点数转换成整数，需要使用下面的表达式： (int)x; 其中x是要转换的那个浮点数。 注意：除了题目要求的输出，不能输出任何其他内容，比如输入时的提示，输出时的说明等等都不能。这道题目要求转换后的数字，程序就只能输出这个数字，除此之外任何内容都不能输出。 输入格式 一个整数。 输出格式 一个整数。 输入样例 100 输出样例 37 ","date":"0001-01-01","objectID":"/week-1/:6:0","tags":null,"title":"第1周 计算","uri":"/week-1/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"解题代码 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); // 获得输入的整数 int fahrenheit = in.nextInt(); // 计算摄氏度 double centigrade = (fahrenheit - 32) / (9 / 5.0); // 将浮点数转换为整数输出 System.out.println((int)centigrade); } } ","date":"0001-01-01","objectID":"/week-1/:6:1","tags":null,"title":"第1周 计算","uri":"/week-1/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":":::note info 以下为个人学习笔记和习题整理 课程：零基础学Java语言-浙江大学-翁恺 @ 中国大学MOOC https://www.icourse163.org/course/ZJU-1001541001 ::: 课堂笔记 ","date":"0001-01-01","objectID":"/week-2/:0:0","tags":null,"title":"第2周 判断","uri":"/week-2/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"关系运算 六个关系运算符： 运算符 意义 == 相等 != 不相等 |大于 =|大于或等于 \u003c | 小于 \u003c=|小于或等于 关系运算结果为 true 或 false 优先级 所有关系运算符的优先级比算术运算低，但比赋值运算高 判断是否相等的 == 和 != 优先级比其他的低 连续的关系运算是从左到右进行的 判断两个浮点数是否相等的方法 Math.abs(f1-f2)\u003c0.0000001 下列表达式中错误的有？ 5 \u003e 3 == 6 \u003e 4 6 \u003e 5 \u003e 4 a == b == true a == b == 6 a == b \u003e false (a == b) \u003e false true 和 false 不能比较大小 ","date":"0001-01-01","objectID":"/week-2/:1:0","tags":null,"title":"第2周 判断","uri":"/week-2/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"判断语句 if else if(x \u003c 0) { ... } else if(x == 0) { ... } else { ... } ","date":"0001-01-01","objectID":"/week-2/:2:0","tags":null,"title":"第2周 判断","uri":"/week-2/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"多路分支 switch case switch (type) { case 1: case 2: ... break; default: System.out.println(...); break; } 计算switch后面的控制表达式以后，程序会跳到相应的case，但是如果这个case内部没有break，那么在执行完语句后，就会顺序执行到下面的case，直到遇到break或者switch结束。 小测验 写出以下代码段的执行结果： {.quiz .essay} int num=34, max=30; if ( num \u003e= max*2 ) System.out.println(\"zhang\"); System.out.println(\"huang\"); System.out.println(\"zhu\"); huang zhu 写出以下代码段的执行结果： {.quiz .essay} int limit = 100; int num1 = 15; int num2 = 40; if ( limit \u003c= limit) { if ( num1 == num2 ) System.out.println(\"lemon\"); System.out.println(\"lime\"); } System.out.println(\"grape\"); lime grape 编程题 ","date":"0001-01-01","objectID":"/week-2/:3:0","tags":null,"title":"第2周 判断","uri":"/week-2/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"题目1. 时间换算（5分） 题目内容 UTC是世界协调时，BJT是北京时间，UTC时间相当于BJT减去8。现在，你的程序要读入一个整数，表示BJT的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果分小于10分，需要保留十位上的0。如1124表示11点24分，而905表示9点5分，36表示0点36分，7表示0点7分。 有效的输入范围是0到2359，即你的程序不可能从测试服务器读到0到2359以外的输入数据。 你的程序要输出这个时间对应的UTC时间，输出的格式和输入的相同，即输出一个整数，表示UTC的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果分小于10分，需要保留十位上的0。 提醒：要小心跨日的换算。 输入格式 一个整数，表示BJT的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而且分小于10分，需要保留十位上的0。 输出格式 一个整数，表示UTC的时和分。整数的个位和十位表示分，百位和千位表示小时。如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而且分小于10分，需要保留十位上的0。 输入样例 933 输出样例 133 ","date":"0001-01-01","objectID":"/week-2/:4:0","tags":null,"title":"第2周 判断","uri":"/week-2/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"解题代码 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); int bjt = in.nextInt(); int utc = bjt - 800; if(utc \u003c 0) { utc += 2400; // 时为负数，则进行隔日计算 } System.out.println(utc); } } ","date":"0001-01-01","objectID":"/week-2/:4:1","tags":null,"title":"第2周 判断","uri":"/week-2/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"题目2. 信号报告（5分） 题目内容 无线电台的RS制信号报告是由三两个部分组成的： R(Readability) 信号可辨度即清晰度. S(Strength) 信号强度即大小. 其中R位于报告第一位，共分5级，用1—5数字表示. 1—Unreadable 2—Barely readable, occasional words distinguishable 3—Readable with considerable difficulty 4—Readable with practically no difficulty 5—Perfectly readable 报告第二位是S，共分九个级别，用1—9中的一位数字表示 1—Faint signals, barely perceptible 2—Very weak signals 3—Weak signals 4—Fair signals 5—Fairly good signals 6—Good signals 7—Moderately strong signals 8—Strong signals 9—Extremely strong signals 现在，你的程序要读入一个信号报告的数字，然后输出对应的含义。如读到59，则输出： Extremely strong signals, perfectly readable. 输入格式 一个整数，信号报告。整数的十位部分表示可辨度，个位部分表示强度。输入的整数范围是[11,59]内有效的数字，这个范围外的数字不可能出现在测试数据中。 输出格式 一句话，表示这个信号报告的意义。按照题目中的文字，先输出表示强度的文字，跟上逗号和空格，然后是表示可辨度的文字，跟上句号。注意可辨度的句子的第一个字母是小写的。注意这里的标点符号都是英文的。 输入样例 33 输出样例 Weak signals, readable with considerable difficulty. ","date":"0001-01-01","objectID":"/week-2/:5:0","tags":null,"title":"第2周 判断","uri":"/week-2/"},{"categories":[["计算机科学","Java","零基础学Java语言-浙江大学-翁恺"]],"content":"解题代码 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); int rs = in.nextInt(); int readability = rs / 10; int strength = rs % 10; switch(strength) { case 1: System.out.print(\"Faint signals, barely perceptible\"); break; case 2: System.out.print(\"Very weak signals\"); break; case 3: System.out.print(\"Weak signals\"); break; case 4: System.out.print(\"Fair signals\"); break; case 5: System.out.print(\"Fairly good signals\"); break; case 6: System.out.print(\"Good signals\"); break; case 7: System.out.print(\"Moderately strong signals\"); break; case 8: System.out.print(\"Strong signals\"); break; case 9: System.out.print(\"Extremely strong signals\"); break; } switch(readability) { case 1: System.out.print(\", unreadable.\"); break; case 2: System.out.print(\", barely readable, occasional words distinguishable.\"); break; case 3: System.out.print(\", readable with considerable difficulty.\"); break; case 4: System.out.print(\", readable with practically no difficulty.\"); break; case 5: System.out.print(\", perfectly readable.\"); break; } } } ","date":"0001-01-01","objectID":"/week-2/:5:1","tags":null,"title":"第2周 判断","uri":"/week-2/"},{"categories":["Docker","安全"],"content":"https://github.com/ysrc/xunfeng/blob/master/docs/install/Docker.md dokcer容器实验摸索结果： /opt/xunfeng目录下含配置文件，其中Config.py定义web前端的登录账号密码及数据库端口、账号密码，内容如下 class Config(object): ACCOUNT = 'admin' PASSWORD = 'xunfeng321' class ProductionConfig(Config): DB = '127.0.0.1' PORT = 65521 DBUSERNAME = 'scan' DBPASSWORD = 'scanlol66' DBNAME = 'xunfeng' /data用于存放MongoDB数据库文件，扫描历史结果、POC漏洞插件设置情况等等都在此。 为了持久化扫描结果数据，建议将/data目录映射到宿主机 故启动参数如下： docker run -d --name=xunfeng \\ -p 8118:80 \\ -p 2717:65521 \\ -v /userdatas/Sandisk/xunfeng:/data \\ ysrc/xunfeng:latest ","date":"0001-01-01","objectID":"/%E9%83%A8%E7%BD%B2%E5%B7%A1%E9%A3%8Exunfeng/:0:0","tags":["Docker","安全","扫描器"],"title":"部署巡风[xunfeng]","uri":"/%E9%83%A8%E7%BD%B2%E5%B7%A1%E9%A3%8Exunfeng/"},{"categories":["Docker","安全"],"content":"1、按官方步骤安装muggle-ocr python3 -m pip install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com muggle-ocr 2、安装相应依赖库 apt update \u0026\u0026 apt install libgl1-mesa-glx 3、降低tf版本 pip install --upgrade tensor ","date":"0001-01-01","objectID":"/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/:0:0","tags":["安全","docker"],"title":"验证码识别服务安装过程","uri":"/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/"}]