<!-- build time:Fri Dec 16 2022 20:58:21 GMT+0800 (China Standard Time) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://sirliu.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://sirliu.github.io/atom.xml"><link rel="alternate" type="application/json" href="https://sirliu.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CMicrosoft%20YaHei:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="编程,aiohttp,异步"><link rel="canonical" href="https://sirliu.github.io/2021/11/python3%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8Basync/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/"><title>python3异步编程async/await原理解释的比较详细的文章 - Python | Black Elk = = 潛龍勿用</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">python3异步编程async/await原理解释的比较详细的文章</h1><div class="meta"><span class="item" title="创建时间：2021-11-27 07:06:09"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-11-27T07:06:09+08:00">2021-11-27</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>13k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>12 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Black Elk</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://api.ixiaowai.cn/gqapi/gqapi.php?id=662959"></li><li class="item" data-background-image="https://api.ixiaowai.cn/gqapi/gqapi.php?id=273405"></li><li class="item" data-background-image="https://api.ixiaowai.cn/gqapi/gqapi.php?id=304670"></li><li class="item" data-background-image="https://api.ixiaowai.cn/gqapi/gqapi.php?id=532044"></li><li class="item" data-background-image="https://api.ixiaowai.cn/gqapi/gqapi.php?id=859848"></li><li class="item" data-background-image="https://api.ixiaowai.cn/gqapi/gqapi.php?id=730103"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/Python/" itemprop="item" rel="index" title="分类于 Python"><span itemprop="name">Python</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://sirliu.github.io/2021/11/python3%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8Basync/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="黑麋鹿"><meta itemprop="description" content="潛龍勿用, 折腾之路"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><p>身为 <code>Python</code> 核心开发组的成员，我对于这门语言的各种细节充满好奇。尽管我很清楚自己不可能对这门语言做到全知全能，但哪怕是为了能够解决各种 issue 和参与常规的语言设计工作，我也觉得有必要试着接触和理解 <code>Python</code> 的内核，弄清楚在底层它是怎么工作的。</p><p>话虽如此，直到最近我才理解了<a target="_blank" rel="noopener" href="https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-492"> Python3.5 中 <code>async/await</code> 的工作机制</a>。在此之前，对于 <code>async/await</code> 语法，我只知道<a target="_blank" rel="noopener" href="https://docs.python.org/3/whatsnew/3.3.html#pep-380"> Python3.3 中的 <code>yield from</code> </a>和<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/asyncio.html#module-asyncio"> Python3.4 中的 <code>asyncio</code> </a>让这个新语法得以在 Python3.5 中实现。由于日常工作中没有接触多少网络编程 -- <code>asyncio</code> 的主要应用领域，虽然它可以做的远不止于此 -- 我对 <code>async/await</code> 并没有关注太多。以代码来说，我知道：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">yield</span> <span class="token keyword">from</span> iterator</pre></td></tr></table></figure><p>(大体) 等价于:</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">from</span> x <span class="token keyword">in</span> iterator<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">yield</span> x</pre></td></tr></table></figure><p>而且我知道 <code>asyncio</code> 是个事件循环的框架，支持异步编程，还有这些术语所表示的 (基本) 意义。但未曾真正的深入研究 <code>async/await</code> 语法，分析从最基础的指令到实现代码语法功能的过程，我觉得并没有理解 Python 中的异步编程，这一点甚至让我心烦意乱。因此我决定花点时间弄明白这个语法的工作机制。鉴于我听到许多人说他们也不理解异步编程的工作机制，我写出了这篇论文 (是的，这篇博文耗费时间之长，字数之多，让我妻子把它叫做论文)。</p><p>由于我希望对这个语法的工作机制有一个完整的理解，这篇论文中会出现涉及 CPython 的底层技术细节。如果你不关心这些细节，或者无法通过这篇文章完全理解这些细节 -- 限于篇幅，我不可能详细解释 CPython 的每个细节，否则这篇文章就要变成一本书了 (例如，如果你不知道代码对象具有标识位，那就别在意代码对象是什么，这不是这篇文章的重点)-- 那也没什么关系。在每个章节的最后，我都添加了一个概念明确的小结，因此如果你对某个章节的内容不感兴趣，那么可以跳过前面的长篇大论，直接阅读结论。</p><p>Python 中协程 (coroutine) 的历史</p><p>根据<span class="exturl" data-url="aHR0cHM6Ly93d3cud2lraXBlZGlhLm9yZy8=">维基百科</span>，“<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29yb3V0aW5l">协程</span>是将多个低优先级的任务转换成统一类型的子任务，以实现在多个节点之间停止或唤醒程序运行的程序模块”。这句专业论述翻译成通俗易懂的话就是，“协程就是可以人为暂停执行的函数”。如果你觉得，“这听起来像是生成器 (generators)”，那么你是对的。</p><p>生成器的概念在<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy93aGF0c25ldy8yLjIuaHRtbA=="> Python2.2</span> 时的<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZy9kZXYvcGVwcy9wZXAtMDI1NS8="> PEP 255</span> 中 (由于实现了<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9saWJyYXJ5L3N0ZHR5cGVzLmh0bWwjaXRlcmF0b3ItdHlwZXM=">遍历器的协议</span>，生成器也被成为生成器遍历器) 第一次被引入。主要受到了<span class="exturl" data-url="aHR0cDovL3d3dy5jcy5hcml6b25hLmVkdS9pY29uLw=="> Icon 语言</span>的影响，生成器允许用户创建一个特殊的遍历器，在生成下一个值时，不会占用额外的内存，并且实现方式非常简单 (当然，在自定义类中实现 <code>__iter__()</code> 和 <code>__next__()</code> 方法也可以达到不存储遍历器中所有值的效果，但也带来了额外的工作量)。举例来说，如果你想实现自己的 <code>range()</code> 函数，最直接的方式是创建一个整数数组：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">def</span> <span class="token function">eager_range</span><span class="token punctuation">(</span>up_to<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token triple-quoted-string string">"""创建一个从0到变量up_to的数组，不包括up_to"""</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    sequence <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    index <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">while</span> index <span class="token operator">&lt;</span> up_to<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        sequence<span class="token punctuation">.</span>append<span class="token punctuation">(</span>index<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        index <span class="token operator">+=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">return</span> sequence</pre></td></tr></table></figure><p>简单直白，但这个函数的问题是，如果你需要的序列很大，比如 0 到一百万，你必须创建一个包含了所有整数的长度是一百万的数组。如果使用生成器，你就可以毫不费力的创建一个从 0 到上限前一个整数的生成器。所占用的内存也只是每次生成的一个整数。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">def</span> <span class="token function">lazy_range</span><span class="token punctuation">(</span>up_to<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token triple-quoted-string string">"""一个从0到变量up_to，不包括up_to的生成器"""</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    index <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">while</span> index <span class="token operator">&lt;</span> up_to<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">yield</span> index</pre></td></tr><tr><td data-num="6"></td><td><pre>        index <span class="token operator">+=</span> <span class="token number">1</span></pre></td></tr></table></figure><p>函数可以在遇到 <code>yield</code> 表达式时暂停执行 -- 尽管 <code>yield</code> 直到 Python2.5 才出现 -- 然后在下次被调用时继续执行，这种特性对于节约内存使用有意义深远，可以用于实现无限长度的序列。</p><p>也许你已经注意到了，生成器所操作的都是遍历器。多一种更好的创建遍历器的语法的确不错 (当你为一个对象定义 <code>__iter__()</code> 方法作为生成器时，也会收到类似的提升)，但如果我们把生成器的 “暂停” 功能拿出来，再加上 “把事物传进去” 的功能，Python 就有了自己的协程功能 (暂且把这个当成 Python 的一个概念，真正的 Python 中的协程会在后面详细讨论)。<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy93aGF0c25ldy8yLjUuaHRtbA==">Python 2.5</span> 中引入了把对象传进一个被暂停的生成器的功能，这要归功于<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZy9kZXYvcGVwcy9wZXAtMDM0Mi8="> PEP 342</span>。抛开与本文无关的内容不看，PEP 342 引入了生成器的 <code>send()</code> 方法。这样就不光可以暂停生成器，更可以在生成器停止时给它传回一个值。在上文 <code>range()</code> 函数的基础上更近一步，你可以让函数产生的序列前进或后退：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">def</span> <span class="token function">jumping_range</span><span class="token punctuation">(</span>up_to<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token triple-quoted-string string">"""一个从0到变量up_to，不包括up_to的生成器</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    传入生成器的值会让序列产生对应的位移</pre></td></tr><tr><td data-num="4"></td><td><pre>    """</pre></td></tr><tr><td data-num="5"></td><td><pre>    index <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">while</span> index <span class="token operator">&lt;</span> up_to<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        jump <span class="token operator">=</span> <span class="token keyword">yield</span> index</pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">if</span> jump <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span> <span class="token comment">## 原文这里是 if jump is Not None, 应该是笔误，此处已做修改</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            jump <span class="token operator">=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        index <span class="token operator">+=</span> jump</pre></td></tr><tr><td data-num="11"></td><td><pre> </pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    iterator <span class="token operator">=</span> jumping_range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>iterator<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 0</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 2</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">next</span><span class="token punctuation">(</span>iterator<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 3</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 2</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">for</span> x <span class="token keyword">in</span> iterator<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment"># 3, 4</span></pre></td></tr></table></figure><p>直到<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy93aGF0c25ldy8zLjMuaHRtbA=="> Python 3.3</span> 中<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZy9kZXYvcGVwcy9wZXAtMDM4MC8="> PEP 380</span> 引入 <code>yield from</code> 之前，生成器都没有太大的变化。严格的说， <code>yield from</code> 让用户可以轻松便捷的从遍历器 (生成器最常见的应用场景) 里提取每一个值，进而重构生成器。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">def</span> <span class="token function">lazy_range</span><span class="token punctuation">(</span>up_to<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token triple-quoted-string string">"""一个从0到变量up_to，不包括up_to的生成器"""</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    index <span class="token operator">=</span> <span class="token number">0</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">gratuitous_refactor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token keyword">nonlocal</span> index</pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">while</span> index <span class="token operator">&lt;</span> up_to<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>            <span class="token keyword">yield</span> index</pre></td></tr><tr><td data-num="8"></td><td><pre>            index <span class="token operator">+=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">yield</span> <span class="token keyword">from</span> gratuitous_refactor<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>同样出于简化重构操作的目的， <code>yield from</code> 也支持将生成器串连起来，这样再不同的调用栈之间传递值时，不需要对原有代码做太大的改动。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">def</span> <span class="token function">bottom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token triple-quoted-string string">"""返回yield表达式来允许值通过调用栈进行传递"""</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">yield</span> <span class="token number">42</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">def</span> <span class="token function">middle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">yield</span> <span class="token keyword">from</span> bottom<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre> </pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">yield</span> <span class="token keyword">from</span> middle<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre> </pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token comment"># 获取生成器</span></pre></td></tr><tr><td data-num="12"></td><td><pre>gen <span class="token operator">=</span> top<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>value <span class="token operator">=</span> <span class="token builtin">next</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>  <span class="token comment"># Prints '42'</span></pre></td></tr><tr><td data-num="15"></td><td><pre> </pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">try</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    value <span class="token operator">=</span> gen<span class="token punctuation">.</span>send<span class="token punctuation">(</span>value <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">except</span> StopIteration <span class="token keyword">as</span> exc<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Error!"</span><span class="token punctuation">)</span>  <span class="token comment"># Prints 'Error!'</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    value <span class="token operator">=</span> exc<span class="token punctuation">.</span>value</pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token keyword">print</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>  <span class="token comment"># Prints '84'</span></pre></td></tr></table></figure><p>总结</p><p>Python2.2 引入的生成器使代码的执行可以被暂停。而在 Python2.5 中引入的允许传值给被暂停的生成器的功能，则让 Python 中协程的概念成为可能。在 Python3.3 中引入的 <code>yield from</code> 让重构和连接生成器变得更加简单。</p><h3 id="事件循环是什么"><a class="anchor" href="#事件循环是什么">#</a> <strong>事件循环是什么？</strong></h3><p>如果你想理解 <code>async/await</code> 语法，那么理解事件循环的定义，知道它如何支持的异步编程，是不可或缺的基础知识。如果你曾经做过 GUI 编程 -- 包括网页前端工作 -- 那么你已经接触过事件循环了。但在 Python 的语言体系中，异步编程的概念还是第一次出现，所以如果不知道事件循环是什么，也情有可原。</p><p>让我们回到维基百科，<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXZlbnRfbG9vcA==">事件循环</span>是 “在程序中等待、分发事件或消息的编程结构”。简而言之，事件循环的作用是，“当 A 发生后，执行 B”。最简单的例子可能是每个浏览器中都有的 JavaScript 事件循环，当你点击网页某处 (&quot;当 A 发生后&quot;)，点击事件被传递给 JavaScript 的事件循环，然后事件循环检查网页上该位置是否有注册了处理这次点击事件的 <code>onclick</code> 回调函数 (&quot;执行 B&quot;)。如果注册了回调函数，那么回调函数就会接收点击事件的详细信息，被调用执行。事件循环会不停的收集发生的事件，循环已注册的事件操作来找到对应的操作，因此被称为 “循环”。</p><p>Python 标准库中的 <code>asyncio</code> 库可以提供事件循环。 <code>asyncio</code> 在网络编程里的一个重要应用场景，就是以连接到 socket 的 I/O 准备好读 / 写 (通过<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9saWJyYXJ5L3NlbGVjdG9ycy5odG1sI21vZHVsZS1zZWxlY3RvcnM="> selector 模块</span>实现) 事件作为事件循环中的 “当 A 发生后” 事件。除了 GUI 和 I/O，事件循环也经常在执行多线程或多进程代码时充当调度器 (例如<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29vcGVyYXRpdmVfbXVsdGl0YXNraW5n">协同式多任务处理</span>)。如果你知道 Python 中的 GIL (General Interpreter Lock)，事件循环在规避 GIL 限制方面也有很大的作用。</p><p>总结</p><p>事件循环提供了一个让你实现 “当事件 A 发生后，执行事件 B” 功能的循环。简单来说，事件循环监视事件的发生，如果发生的是事件循环关心 (“注册” 过) 的事件，那么事件循环会执行所有被关联到该事件的操作。在 Python3.4 中加入标准库的 <code>asyncio</code> 使 Python 也有了事件循环。</p><h3 id="async和await是怎么工作的"><a class="anchor" href="#async和await是怎么工作的">#</a> <code>async</code> 和 <code>await</code> 是怎么工作的</h3><p>在 Python3.4 中的工作方式</p><p>在 Python3.3 推动生成器的发展和 Python3.5 中事件循环以 <code>asyncio</code> 的形式出现之间，Python3.4 以<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uY3VycmVudF9jb21wdXRpbmc=">并发编程</span>的形式实现了异步编程。从本质上说，异步编程就是无法预知执行时间的计算机程序 (也就是异步，而非同步)。并发编程的代码即使运行在同一个线程中，执行时也互不干扰 (<a target="_blank" rel="noopener" href="http://blog.golang.org/concurrency-is-not-parallelism">并发<strong>不是</strong>并行</a>)。例如，以下 Python3.4 的代码中，并发两个异步的函数调用，每秒递减计数，互不干扰。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> asyncio</pre></td></tr><tr><td data-num="2"></td><td><pre> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment"># Borrowed from http://curio.readthedocs.org/en/latest/tutorial.html.</span></pre></td></tr><tr><td data-num="4"></td><td><pre> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">def</span> <span class="token function">countdown</span><span class="token punctuation">(</span>number<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">while</span> n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'T-minus'</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token string">'(&#123;&#125;)'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token keyword">yield</span> <span class="token keyword">from</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        n <span class="token operator">-=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="10"></td><td><pre> </pre></td></tr><tr><td data-num="11"></td><td><pre>loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>tasks <span class="token operator">=</span> <span class="token punctuation">[</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    asyncio<span class="token punctuation">.</span>ensure_future<span class="token punctuation">(</span>countdown<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    asyncio<span class="token punctuation">.</span>ensure_future<span class="token punctuation">(</span>countdown<span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="16"></td><td><pre>loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>asyncio<span class="token punctuation">.</span>wait<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>在 Python3.4 中，<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.coroutine"> <code>asyncio.coroutine</code> 装饰器</a>被用于修饰使用 <code>asyncio</code> 库并且作为<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9yZWZlcmVuY2UvZGF0YW1vZGVsLmh0bWw/I2Nvcm91dGluZS1vYmplY3Rz">协程</span>在它的事件循环中运行的函数。这是 Python 中第一次出现明确的协程定义：一种实装了<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZy9kZXYvcGVwcy9wZXAtMDM0Mi8="> PEP 342</span> 中添加给生成器的方法，基类是<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Coroutine">抽象类 <code>collections.abc.Coroutine</code> </a>的对象。这个定义让那些原本没有异步执行意图的生成器也带上了协程的特征。而为了解决这种混淆， <code>asyncio</code> 规定所有作为协程执行的函数都需要以<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.coroutine"> <code>asyncio.coroutine</code> 装饰器</a>进行修饰。</p><p>有了这样一个明确的协程的定义 (同时符合生成器的接口规范)，你可以使用 <code>yield from</code> 将任何<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/asyncio-task.html#future"> <code>asyncio.Future</code> 对象</a>传入事件循环，在等待事件发生时暂停程序执行 (future 对象是 <code>asyncio</code> 中的一种对象，此处不再详述)。future 对象进入事件循环后就处于事件循环的监控之下，一旦 future 对象完成了自身任务，事件循环就会唤醒原本被暂停的协程继续执行，future 对象的返回结果则通过 <code>send()</code> 方法由事件循环传递给协程。</p><p>以上文代码为例，事件循环启动了两个调用 <code>call()</code> 函数的协程，运行到某个协程中包含 <code>yield from</code> 和 <code>asyncio.sleep()</code> 语句处，这条语句将一个 <code>asyncio.Future</code> 对象返回事件循环，暂停协程的执行。这时事件循环会为 future 对象等待一秒 (并监控其他程序，例如另外一个协程)，一秒后事件循环唤醒传出了 future 对象的被暂停的 <code>countdown()</code> 协程继续执行，并把 future 对象的执行结果归还给原协程。这个循环过程会持续到 <code>countdown()</code> 协程结束执行，事件循环中没有被监控的事件为止。稍后我会用一个完整的例子详细解释协程 / 事件循环结构的工作流程，但首先，我要解释一下 <code>async</code> 和 <code>await</code> 是如何工作的。</p><p>从 <code>yield from</code> 到 Python3.5 中的 <code>await</code></p><p>在 Python3.4 中，一个用于异步执行的协程代码会被标记成以下形式：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># 这种写法在 Python3.5 中同样有效</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token decorator annotation punctuation">@asyncio<span class="token punctuation">.</span>coroutine</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">def</span> <span class="token function">py34_coro</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">yield</span> <span class="token keyword">from</span> stuff<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>Python3.5 也添加了一个作用和 <code>asyncio.coroutine</code> 相同，用于修饰协程函数的<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/types.html#types.coroutine">装饰器 <code>types.coroutine</code> </a>。也可以使用 <code>async def</code> 语法定义协程函数，但是这样定义的协程函数中不能使用 <code>yield</code> 语句，只允许使用 <code>return</code> 或 <code>await</code> 语句返回数据。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">py35_coro</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">await</span> stuff<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>对同一个协程概念添加的不同语法，是为了规范协程的定义。这些陆续补充的语法使协程从抽象的接口变成了具体的对象类型，让普通的生成器和协程用的生成器有了明显的区别 (<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/inspect.html#inspect.iscoroutine"> <code>inspect.iscoroutine()</code> 方法</a>的判断标准则比 <code>async</code> 还要严格)。</p><p>另外，除了 <code>async</code> ，Python3.5 也引入了 <code>await</code> 语法 (只能在 <code>async def</code> 定义的函数中使用)。虽然 <code>await</code> 的使用场景与 <code>yield from</code> 类似，但是 <code>await</code> 接收的对象不同。作为由于协程而产生的语法， <code>await</code> 接收协程对象简直理所当然。但是当你对某个对象使用 <code>await</code> 语法时，技术上说，这个对象必须是<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMy9yZWZlcmVuY2UvZGF0YW1vZGVsLmh0bWw/I2F3YWl0YWJsZS1vYmplY3Rz">可等待对象 (awaitable object)</span>：一种定义了 <code>__await__()</code> 方法 (返回非协程本身的遍历器) 的对象。协程本身也被视作可等待对象 (体现在 Python 语言设计中，就是 <code>collections.abc.Coroutine</code> 继承了 <code>collections.abc.Awaitable</code> 抽象类)。可等待对象的定义沿用了 Python 中将大多数语法结构在底层转换成方法调用的传统设计思想，例如 <code>a + b</code> 等价于 <code>a.__add__(b)</code> 或 <code>b.__radd__(a)</code> 。</p><p>那么在编译器层面， <code>yield from</code> 和 <code>await</code> 的运行机制有什么区别 (例如 <code>types.coroutine</code> 修饰的生成器和 <code>async def</code> 语法定义的函数) 呢？让我们看看上面两个例子在 Python3.5 环境下执行时的字节码细节有什么不同， <code>py34_coro()</code> 执行时的字节码是：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>In <span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dis<span class="token punctuation">.</span>dis<span class="token punctuation">(</span>py34_coro<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token number">3</span>           <span class="token number">0</span> LOAD_GLOBAL              <span class="token number">0</span> <span class="token punctuation">(</span>stuff<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>              <span class="token number">3</span> CALL_FUNCTION            <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span> positional<span class="token punctuation">,</span> <span class="token number">0</span> keyword pair<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>              <span class="token number">6</span> GET_YIELD_FROM_ITER</pre></td></tr><tr><td data-num="5"></td><td><pre>              <span class="token number">7</span> LOAD_CONST               <span class="token number">0</span> <span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>             <span class="token number">10</span> YIELD_FROM</pre></td></tr><tr><td data-num="7"></td><td><pre>             <span class="token number">11</span> POP_TOP</pre></td></tr><tr><td data-num="8"></td><td><pre>             <span class="token number">12</span> LOAD_CONST               <span class="token number">0</span> <span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>             <span class="token number">15</span> RETURN_VALUE</pre></td></tr></table></figure><p><code>py35_coro()</code> 执行时的字节码是：</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre>In <span class="token punctuation">[</span><span class="token number">33</span><span class="token punctuation">]</span><span class="token punctuation">:</span> dis<span class="token punctuation">.</span>dis<span class="token punctuation">(</span>py35_coro<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token number">2</span>           <span class="token number">0</span> LOAD_GLOBAL              <span class="token number">0</span> <span class="token punctuation">(</span>stuff<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>              <span class="token number">3</span> CALL_FUNCTION            <span class="token number">0</span> <span class="token punctuation">(</span><span class="token number">0</span> positional<span class="token punctuation">,</span> <span class="token number">0</span> keyword pair<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>              <span class="token number">6</span> GET_AWAITABLE</pre></td></tr><tr><td data-num="5"></td><td><pre>              <span class="token number">7</span> LOAD_CONST               <span class="token number">0</span> <span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>             <span class="token number">10</span> YIELD_FROM</pre></td></tr><tr><td data-num="7"></td><td><pre>             <span class="token number">11</span> POP_TOP</pre></td></tr><tr><td data-num="8"></td><td><pre>             <span class="token number">12</span> LOAD_CONST               <span class="token number">0</span> <span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>             <span class="token number">15</span> RETURN_VALUE</pre></td></tr></table></figure><p>除了 <code>py34_coro</code> 代码中多了一行装饰器而导致的行号不同，两组字节码的区别集中在<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/dis.html#opcode-GET_YIELD_FROM_ITER"> <code>GET_YIELD_FROM_ITER</code> 操作符</a>和<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/dis.html#opcode-GET_AWAITABLE"> <code>GET_AWAITABLE</code> 操作符</a>。两个函数都是以协程的语法声明的。对于 <code>GET_YIELD_FROM_ITER</code> ，编译器只检查参数是否生成器或者协程，如果不是，就调用 <code>iter()</code> 函数遍历参数 ( <code>types.coroutine</code> 装饰器修饰了生成器，让代码对象在 C 代码层面附带了 <code>CO_ITERABLE_COROUTINE</code> 标识，因此 <code>yield from</code> 语句可以在协程中接收协程对象)。</p><p><code>GET_AWAITABLE</code> 则是另外一番光景。虽然同 <code>GET_YIELD_FROM_ITER</code> 操作符一样，字节码也接收协程对象，但它不会接收没有协程标记的生成器。而且，正如前文所述，字节码不止接收协程对象，也可以接收可等待对象。这样， <code>yield from</code> 语句和 <code>await</code> 语句都可以实现协程概念，但一个接收的是普通的生成器，另一个是可等待对象。</p><p>也许你会好奇，为什么基于 <code>async</code> 的协程和基于生成器的协程在暂停时接收的对象会不同？这种设计的主要目的是让用户不至于混淆两种类型的协程实现，或者不小心弄错类似的 API 的参数类型，甚而影响 Python 最重要的特性的使用体验。例如生成器继承了协程的 API，在需要协程时很容易犯使用了普通的生成器的错误。生成器的使用场景不限于通过协程实现流程控制的情况，因此很容易的辨别普通生成器和协程也非常重要。可是，Python 不是需要预编译的静态语言，在使用基于生成器的协程时编译器只能做到在运行时进行检查。换句话说，就算使用了 <code>types.coroutine</code> 装饰器，编译器也无法确定生成器会充当本职工作还是扮演协程的角色 (记住，即使代码中明明白白使用了 <code>types.coroutine</code> 装饰器，依然有在之前的代码中类似 <code>types = spam</code> 这样的语句存在的可能)，编译器会根据已知的信息，在不同的上下文环境下调用不同的操作符。</p><p>对于基于生成器的协程和 <code>async</code> 定义的协程的区别，我的一个非常重要的观点是，只有基于生成器的协程可以真正的暂停程序执行，并把外部对象传入事件循环。当你使用事件循环相关的函数，如<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/asyncio-task.html#asyncio.sleep"> <code>asyncio.sleep()</code> </a>时，这些函数与事件循环的交互所用的是框架内部的 API，事件循环究竟如何变化，并不需要用户操心，因此也许你很少看到这种关注底层概念的说法。我们大多数人其实并不需要真正实现一个事件循环，而只需要使用 <code>async</code> 这样的语法来通过事件循环实现某个功能。但如果你像我一样，好奇为什么我们不能使用 <code>async</code> 协程实现类似 <code>asnycio.sleep()</code> 的功能，那么答案就在这里。</p><p>总结</p><p>让我们总结一下这两个相似的术语，使用 <code>async def</code> 可以定义协程，使用 <code>types.coroutine</code> 装饰器可以将一个生成器 -- 返回一个不是协程本身的遍历器 -- 声明为协程。 <code>await</code> 语句只能用于可等待对象 ( <code>await</code> 不能作用于普通的生成器)，除此之外就和 <code>yield from</code> 的功能基本相同。 <code>async</code> 函数定义的协程中一定会有 <code>return</code> 语句 -- 包括每个 Python 函数都有的默认返回语句 <code>return None</code> -- 和 / 或 <code>await</code> 语句 (不能使用 <code>yield</code> 语句)。对 <code>async</code> 函数所添加的限制，是为了保证用户不会混淆它和基于生成器的协程，两者的期望用途差别很大。</p><h3 id="请把asyncawait视为异步编程的api"><a class="anchor" href="#请把asyncawait视为异步编程的api">#</a> 请把 <code>async/await</code> 视为异步编程的 API</h3><p><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1sWWU4VzA0RVJuWQ==">David Bzazley 的 Python Brasil 2015 keynote</span> 让我发现自己忽略了一件很重要的事。在那个演讲中，David 指出， <code>async/await</code> 其实是一种异步编程的 API (他在 Twitter 上<span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9kYWJlYXovc3RhdHVzLzY5NjAyODk0NjIyMDA1NjU3Ng==">对我说过同样的话</span>)。我想 David 的意思是，我们不应该把 <code>async/await</code> 当成 <code>asnycio</code> 的一种别名，而应该利用 <code>async/await</code> ，让 <code>asyncio</code> 成为异步编程的通用框架。</p><p>David 对将 <code>async/await</code> 作为异步编程 API 的想法深信不疑，甚至在他的<a target="_blank" rel="noopener" href="https://pypi.python.org/pypi/curio"> <code>curio</code> 项目</a>中实现了自己的事件循环。这也侧面证明了 Python 中 <code>async/await</code> 作为异步编程语法的作用 (不像其他集成了事件循环的语言那样，用户需要自己实现事件循环和底层细节)。 <code>async/await</code> 语法让像 <code>curio</code> 这样的项目可以进行不同的底层操作 ( <code>asyncio</code> 使用 future 对象与事件循环进行交互，而 <code>curio</code> 使用元祖对象)，还让它们可以有不同的侧重和性能优化 (为了更广泛的适用性， <code>asyncio</code> 实现了完整的传输和协议层框架，而相对简单的 <code>curio</code> 则需要用户实现那些框架，但也因此获得了更快的运行速度)。</p><p>看完了 Python 中异步编程的 (简略) 历史，很容易得出 <code>async/await</code> == <code>asyncio</code> 的结论。我想说的是， <code>asyncio</code> 导致了 Python3.4 中异步编程的出现，并且对 Python3.5 中 <code>async/await</code> 的产生居功至伟，但是， <code>async/await</code> 的灵活的设计，甚至到了可以_不使用_ <code>asyncio</code> 的地步，也不需要为了应用 <code>asyncio</code> 框架而修改架构。简而言之， <code>async/await</code> 语法延续了 Python 在保证实用性的同时尽可能的让设计灵活的传统。</p><h3 id="一个例子"><a class="anchor" href="#一个例子">#</a> 一个例子</h3><p>看到这里，你的脑子里应该已经装满了各种新术语和新概念，但对于这些新事物如何实现异步编程却仍一知半解。为了加深理解，以下是一个 (略显做作的) 异步编程的例子，包括完整的从事件循环到相关业务函数的代码。在这个例子中，协程的用途是实现独立的火箭发射倒计时器，产生的效果是同步进行的倒计时。这是通过异步编程而实现的函数并发，程序执行是有三个协程运行在在同一个线程中，却可以彼此互不干扰。</p><figure class="highlight python"><figcaption data-lang="python"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">import</span> datetime</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">import</span> heapq</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">import</span> types</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">import</span> time</pre></td></tr><tr><td data-num="5"></td><td><pre> </pre></td></tr><tr><td data-num="6"></td><td><pre> </pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Task</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="8"></td><td><pre> </pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token triple-quoted-string string">"""Represent how long a coroutine should wait before starting again.</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    Comparison operators are implemented for use by heapq. Two-item</pre></td></tr><tr><td data-num="11"></td><td><pre>    tuples unfortunately don't work because when the datetime.datetime</pre></td></tr><tr><td data-num="12"></td><td><pre>    instances are equal, comparison falls to the coroutine and they don't</pre></td></tr><tr><td data-num="13"></td><td><pre>    implement comparison methods, triggering an exception.</pre></td></tr><tr><td data-num="14"></td><td><pre>    </pre></td></tr><tr><td data-num="15"></td><td><pre>    Think of this as being like asyncio.Task/curio.Task.</pre></td></tr><tr><td data-num="16"></td><td><pre>    """</pre></td></tr><tr><td data-num="17"></td><td><pre> </pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> wait_until<span class="token punctuation">,</span> coro<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        self<span class="token punctuation">.</span>coro <span class="token operator">=</span> coro</pre></td></tr><tr><td data-num="20"></td><td><pre>        self<span class="token punctuation">.</span>waiting_until <span class="token operator">=</span> wait_until</pre></td></tr><tr><td data-num="21"></td><td><pre> </pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">__eq__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>waiting_until <span class="token operator">==</span> other<span class="token punctuation">.</span>waiting_until</pre></td></tr><tr><td data-num="24"></td><td><pre> </pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">__lt__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>waiting_until <span class="token operator">&lt;</span> other<span class="token punctuation">.</span>waiting_until</pre></td></tr><tr><td data-num="27"></td><td><pre> </pre></td></tr><tr><td data-num="28"></td><td><pre> </pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">SleepingLoop</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="30"></td><td><pre> </pre></td></tr><tr><td data-num="31"></td><td><pre>    <span class="token triple-quoted-string string">"""An event loop focused on delaying execution of coroutines.</span></pre></td></tr><tr><td data-num="32"></td><td><pre>    Think of this as being like asyncio.BaseEventLoop/curio.Kernel.</pre></td></tr><tr><td data-num="33"></td><td><pre>    """</pre></td></tr><tr><td data-num="34"></td><td><pre> </pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>coros<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        self<span class="token punctuation">.</span>_new <span class="token operator">=</span> coros</pre></td></tr><tr><td data-num="37"></td><td><pre>        self<span class="token punctuation">.</span>_waiting <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="38"></td><td><pre> </pre></td></tr><tr><td data-num="39"></td><td><pre>    <span class="token keyword">def</span> <span class="token function">run_until_complete</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token comment"># Start all the coroutines.</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token keyword">for</span> coro <span class="token keyword">in</span> self<span class="token punctuation">.</span>_new<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="42"></td><td><pre>            wait_for <span class="token operator">=</span> coro<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="43"></td><td><pre>            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_waiting<span class="token punctuation">,</span> Task<span class="token punctuation">(</span>wait_for<span class="token punctuation">,</span> coro<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        <span class="token comment"># Keep running until there is no more work to do.</span></pre></td></tr><tr><td data-num="45"></td><td><pre>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>_waiting<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="46"></td><td><pre>            now <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="47"></td><td><pre>            <span class="token comment"># Get the coroutine with the soonest resumption time.</span></pre></td></tr><tr><td data-num="48"></td><td><pre>            task <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_waiting<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="49"></td><td><pre>            <span class="token keyword">if</span> now <span class="token operator">&lt;</span> task<span class="token punctuation">.</span>waiting_until<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="50"></td><td><pre>                <span class="token comment"># We're ahead of schedule; wait until it's time to resume.</span></pre></td></tr><tr><td data-num="51"></td><td><pre>                delta <span class="token operator">=</span> task<span class="token punctuation">.</span>waiting_until <span class="token operator">-</span> now</pre></td></tr><tr><td data-num="52"></td><td><pre>                time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>delta<span class="token punctuation">.</span>total_seconds<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="53"></td><td><pre>                now <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="54"></td><td><pre>            <span class="token keyword">try</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="55"></td><td><pre>                <span class="token comment"># It's time to resume the coroutine.</span></pre></td></tr><tr><td data-num="56"></td><td><pre>                wait_until <span class="token operator">=</span> task<span class="token punctuation">.</span>coro<span class="token punctuation">.</span>send<span class="token punctuation">(</span>now<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="57"></td><td><pre>                heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_waiting<span class="token punctuation">,</span> Task<span class="token punctuation">(</span>wait_until<span class="token punctuation">,</span> task<span class="token punctuation">.</span>coro<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="58"></td><td><pre>            <span class="token keyword">except</span> StopIteration<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="59"></td><td><pre>                <span class="token comment"># The coroutine is done.</span></pre></td></tr><tr><td data-num="60"></td><td><pre>                <span class="token keyword">pass</span></pre></td></tr><tr><td data-num="61"></td><td><pre> </pre></td></tr><tr><td data-num="62"></td><td><pre> </pre></td></tr><tr><td data-num="63"></td><td><pre><span class="token decorator annotation punctuation">@types<span class="token punctuation">.</span>coroutine</span></pre></td></tr><tr><td data-num="64"></td><td><pre><span class="token keyword">def</span> <span class="token function">sleep</span><span class="token punctuation">(</span>seconds<span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="65"></td><td><pre>    <span class="token triple-quoted-string string">"""Pause a coroutine for the specified number of seconds.</span></pre></td></tr><tr><td data-num="66"></td><td><pre>    Think of this as being like asyncio.sleep()/curio.sleep().</pre></td></tr><tr><td data-num="67"></td><td><pre>    """</pre></td></tr><tr><td data-num="68"></td><td><pre>    now <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="69"></td><td><pre>    wait_until <span class="token operator">=</span> now <span class="token operator">+</span> datetime<span class="token punctuation">.</span>timedelta<span class="token punctuation">(</span>seconds<span class="token operator">=</span>seconds<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="70"></td><td><pre>    <span class="token comment"># Make all coroutines on the call stack pause; the need to use `yield`</span></pre></td></tr><tr><td data-num="71"></td><td><pre>    <span class="token comment"># necessitates this be generator-based and not an async-based coroutine.</span></pre></td></tr><tr><td data-num="72"></td><td><pre>    actual <span class="token operator">=</span> <span class="token keyword">yield</span> wait_until</pre></td></tr><tr><td data-num="73"></td><td><pre>    <span class="token comment"># Resume the execution stack, sending back how long we actually waited.</span></pre></td></tr><tr><td data-num="74"></td><td><pre>    <span class="token keyword">return</span> actual <span class="token operator">-</span> now</pre></td></tr><tr><td data-num="75"></td><td><pre> </pre></td></tr><tr><td data-num="76"></td><td><pre> </pre></td></tr><tr><td data-num="77"></td><td><pre><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">countdown</span><span class="token punctuation">(</span>label<span class="token punctuation">,</span> length<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">,</span> delay<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="78"></td><td><pre>    <span class="token triple-quoted-string string">"""Countdown a launch for `length` seconds, waiting `delay` seconds.</span></pre></td></tr><tr><td data-num="79"></td><td><pre>    This is what a user would typically write.</pre></td></tr><tr><td data-num="80"></td><td><pre>    """</pre></td></tr><tr><td data-num="81"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span>label<span class="token punctuation">,</span> <span class="token string">'waiting'</span><span class="token punctuation">,</span> delay<span class="token punctuation">,</span> <span class="token string">'seconds before starting countdown'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="82"></td><td><pre>    delta <span class="token operator">=</span> <span class="token keyword">await</span> sleep<span class="token punctuation">(</span>delay<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="83"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span>label<span class="token punctuation">,</span> <span class="token string">'starting after waiting'</span><span class="token punctuation">,</span> delta<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="84"></td><td><pre>    <span class="token keyword">while</span> length<span class="token punctuation">:</span></pre></td></tr><tr><td data-num="85"></td><td><pre>        <span class="token keyword">print</span><span class="token punctuation">(</span>label<span class="token punctuation">,</span> <span class="token string">'T-minus'</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="86"></td><td><pre>        waited <span class="token operator">=</span> <span class="token keyword">await</span> sleep<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="87"></td><td><pre>        length <span class="token operator">-=</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="88"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span>label<span class="token punctuation">,</span> <span class="token string">'lift-off!'</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="89"></td><td><pre> </pre></td></tr><tr><td data-num="90"></td><td><pre> </pre></td></tr><tr><td data-num="91"></td><td><pre><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="92"></td><td><pre>    <span class="token triple-quoted-string string">"""Start the event loop, counting down 3 separate launches.</span></pre></td></tr><tr><td data-num="93"></td><td><pre>    This is what a user would typically write.</pre></td></tr><tr><td data-num="94"></td><td><pre>    """</pre></td></tr><tr><td data-num="95"></td><td><pre>    loop <span class="token operator">=</span> SleepingLoop<span class="token punctuation">(</span>countdown<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> countdown<span class="token punctuation">(</span><span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> delay<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="96"></td><td><pre>                        countdown<span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> delay<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="97"></td><td><pre>    start <span class="token operator">=</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="98"></td><td><pre>    loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="99"></td><td><pre>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Total elapsed time is'</span><span class="token punctuation">,</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="100"></td><td><pre> </pre></td></tr><tr><td data-num="101"></td><td><pre> </pre></td></tr><tr><td data-num="102"></td><td><pre><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span></pre></td></tr><tr><td data-num="103"></td><td><pre>    main<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>正如前文所说，这个例子是有意为之，如果在 Python3.5 下运行，你会发现虽然三个协程在同一线程中互不干扰，但总运行时间是 5 秒左右。你可以把 <code>Task</code> ， <code>SleepingLoop</code> 和 <code>sleep()</code> 看成 <code>asyncio</code> 和 <code>curio</code> 这样生成事件循环的框架提供的接口函数，对普通用户来说，只有 <code>countdown()</code> 和 <code>main()</code> 函数才需要关注。到此为止，你应该已经明白， <code>async</code> ， <code>await</code> 语句，甚至整个异步编程，都不是完全无法理解的魔术， <code>async/await</code> 只是 Python 为了让异步编程更简便易用而添加的 API。</p><h3 id="我对未来的愿景"><a class="anchor" href="#我对未来的愿景">#</a> 我对未来的愿景</h3><p>我已经理解了 Python 中的异步编程，我想把它用到所有地方！这个精巧高效的概念完全可以替代原本线程的作用。问题是，Python3.5 和 <code>async/await</code> 都是面世不久的新事物，这就意味着支持异步编程的库数量不会太多。例如，要发送 HTTP 请求，你要么手动构造 HTTP 请求对象 (麻烦透顶)，然后用一个类似<a target="_blank" rel="noopener" href="https://pypi.python.org/pypi/aiohttp"> <code>aiohttp</code> </a>的框架把 HTTP 放进另外的事件循环 (对于 <code>aiohttp</code> ，是 <code>asyncio</code> ) 开始操作；要么就等着哪天出现一个像<a target="_blank" rel="noopener" href="https://pypi.python.org/pypi/hyper"> <code>hyper</code> </a>这样的项目对 HTTP 这类 I/O 进行抽象，让你可以使用任意的 I/O 库 (遗憾的是，到目前为止 <code>hyper</code> 只支持 HTTP/2)。</p><p>我的个人观点是希望像 <code>hyper</code> 这样的项目可以继续发展，分离从 I/O 获取二进制数据和解析二进制数据的逻辑。Python 中大部分的 I/O 库都是包揽进行 I/O 操作和处理从 I/O 接收的数据，因此对操作分离进行抽象意义重大。Python 标准库的<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/http.html#module-http"> <code>http</code> 包</a>也存在同样的问题，有处理 I/O 的连接对象，却没有 HTTP 解析器。而如果你希望 <code>requests</code> 库支持异步编程，那么<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2tlbm5ldGhyZWl0ei9yZXF1ZXN0cy9pc3N1ZXMvMjgwMQ==">你可能要失望了</span>，因为 <code>requests</code> 从设计上就是同步编程。拥有异步编程能力让 Python 社区有机会弥补 Python 语言中没有多层网络栈抽象的缺点。现在 Python 的优势是可以像运行同步代码那样运行异步代码，因此填补异步编程空白的工具，可以应用在同步异步两种场景中。</p><p>我还希望 Python 可以增加 <code>async</code> 协程对 <code>yield</code> 语句的支持。这可能需要一个新的关键字 (也许是 <code>anticipate</code> ?)，但只使用 <code>async</code> 语法就不能实现事件循环的情况实在不尽人意。幸运的是，<span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9kYWJlYXovc3RhdHVzLzY5NjAxNDc1NDU1NzQ2NDU3Ng==">在这一点上我不是一个人</span>，<span class="exturl" data-url="aHR0cHM6Ly93d3cucHl0aG9uLm9yZy9kZXYvcGVwcy9wZXAtMDQ5Mi8=">PEP 492</span> 的作者与我观点相同，我觉得这个愿望很有可能成为现实。</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>总而言之， <code>async</code> 和 <code>await</code> 出现的目的就是为了协程，顺便支持可等待对象，也可以把普通生成器转换成协程。所有这些都是为了实现并发操作，来提升 Python 中的异步编程体验。相比使用多线程的编程体验，协程功能强大并且更为易用 -- 只用了包括注释在内的不到 100 行代码就实现了一个完整的异步编程实例 -- 兼具良好的适用性和运行效率 (curio 的 FAQ 里说它的运行速度比 <code>twisted</code> 快 30-40%，比 <code>gevent</code> 慢 10-15%，别忘了，在 Python2 + 版本中，Twisted 用的内存更少而且调试比 Go 简单，想想我们可以做到什么程度！)。能在 Python 3 中看到 <code>async/await</code> 的引入，我非常高兴，并且期待 Python 社区接纳这个新语法，希望有更多的库和框架支持 <code>async/await</code> 语法，让所有的 Python 开发者都可以从异步编程中受益。</p><h1 id="来源"><a class="anchor" href="#来源">#</a> 来源</h1><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Blcm1pa2UvYXJ0aWNsZS9kZXRhaWxzLzExMDgyMTI0Ng==">https://blog.csdn.net/permike/article/details/110821246</span></p><div class="tags"><a href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag"><i class="ic i-tag"></i> 编程</a> <a href="/tags/aiohttp/" rel="tag"><i class="ic i-tag"></i> aiohttp</a> <a href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag"><i class="ic i-tag"></i> 异步</a></div></div><footer><div class="meta"><span id="2021/11/python3异步编程async/await原理解释的比较详细的文章/" class="item leancloud_visitors" data-flag-title="python3异步编程async/await原理解释的比较详细的文章" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>黑麋鹿 <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://sirliu.github.io/2021/11/python3%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8Basync/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/" title="python3异步编程async&#x2F;await原理解释的比较详细的文章">https://sirliu.github.io/2021/11/python3异步编程async/await原理解释的比较详细的文章/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2021/11/%E6%92%B8%E9%A3%9E%E9%B8%9F%E5%8A%A0%E9%80%9F%E5%99%A8/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;api.ixiaowai.cn&#x2F;gqapi&#x2F;gqapi.php?id&#x3D;101835" title="撸飞鸟加速器"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 逆向</span><h3>撸飞鸟加速器</h3></a></div><div class="item right"><a href="/2021/11/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3%20Python%E4%B8%AD%20%E7%9A%84%20async-await%20%E6%A6%82%E5%BF%B5/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;api.ixiaowai.cn&#x2F;gqapi&#x2F;gqapi.php?id&#x3D;643606" title="轻松理解 Python中 的 async-await 概念"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Python</span><h3>轻松理解 Python中 的 async-await 概念</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.</span> <span class="toc-text">事件循环是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async%E5%92%8Cawait%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84"><span class="toc-number">2.</span> <span class="toc-text">async 和 await 是怎么工作的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%8A%8Aasyncawait%E8%A7%86%E4%B8%BA%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84api"><span class="toc-number">3.</span> <span class="toc-text">请把 async&#x2F;await 视为异步编程的 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">4.</span> <span class="toc-text">一个例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91%E5%AF%B9%E6%9C%AA%E6%9D%A5%E7%9A%84%E6%84%BF%E6%99%AF"><span class="toc-number">5.</span> <span class="toc-text">我对未来的愿景</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number"></span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A5%E6%BA%90"><span class="toc-number"></span> <span class="toc-text">来源</span></a></li></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2021/8/requests%E3%80%81aiohttp%E3%80%81httpx%E5%AF%B9%E6%AF%94/" rel="bookmark" title="requests、aiohttp、httpx对比">requests、aiohttp、httpx对比</a></li><li><a href="/2021/8/%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91aiohttp/" rel="bookmark" title="异步并发aiohttp">异步并发aiohttp</a></li><li><a href="/2021/9/pipreqs%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91/" rel="bookmark" title="pipreqs使用踩坑">pipreqs使用踩坑</a></li><li><a href="/2021/9/Python%E4%B8%ADAES%E5%8A%A0%E8%A7%A3%E5%AF%86/" rel="bookmark" title="Python中AES加解密">Python中AES加解密</a></li><li><a href="/2021/9/Python%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/" rel="bookmark" title="Python上传图片">Python上传图片</a></li><li><a href="/2021/10/%E4%BD%BF%E7%94%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95API%E5%90%8E%E7%AB%AF/" rel="bookmark" title="使用腾讯云函数搭建简单API后端">使用腾讯云函数搭建简单API后端</a></li><li><a href="/2021/10/pymongo%E6%93%8D%E4%BD%9C/" rel="bookmark" title="pymongo操作">pymongo操作</a></li><li><a href="/2021/11/Python%E7%88%AC%E5%8F%96TG%E9%A2%91%E9%81%93%E5%9B%BE%E7%89%87/" rel="bookmark" title="Python爬取TG频道图片">Python爬取TG频道图片</a></li><li><a href="/2021/11/How%20to%20use%20Flask%20with%20gevent%20(uWSGI%20and%20Gunicorn%20editions)/" rel="bookmark" title="How to use Flask with gevent (uWSGI and Gunicorn editions)">How to use Flask with gevent (uWSGI and Gunicorn editions)</a></li><li><a href="/2021/11/%E8%85%BE%E8%AE%AF%E4%BA%91%E5%87%BD%E6%95%B0Python%E4%BE%9D%E8%B5%96%E5%8C%85%E5%AE%89%E8%A3%85%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/" rel="bookmark" title="腾讯云函数Python依赖包安装打包过程">腾讯云函数Python依赖包安装打包过程</a></li><li class="active"><a href="/2021/11/python3%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8Basync/await%E5%8E%9F%E7%90%86%E8%A7%A3%E9%87%8A%E7%9A%84%E6%AF%94%E8%BE%83%E8%AF%A6%E7%BB%86%E7%9A%84%E6%96%87%E7%AB%A0/" rel="bookmark" title="python3异步编程async/await原理解释的比较详细的文章">python3异步编程async/await原理解释的比较详细的文章</a></li><li><a href="/2021/11/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3%20Python%E4%B8%AD%20%E7%9A%84%20async-await%20%E6%A6%82%E5%BF%B5/" rel="bookmark" title="轻松理解 Python中 的 async-await 概念">轻松理解 Python中 的 async-await 概念</a></li><li><a href="/2021/11/aiohttp%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%BE%B9%E8%AF%B7%E6%B1%82%E8%BE%B9%E5%A4%84%E7%90%86/" rel="bookmark" title="aiohttp使用回调函数边请求边处理">aiohttp使用回调函数边请求边处理</a></li><li><a href="/2021/12/pip%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%BA%93/" rel="bookmark" title="pip离线安装依赖库">pip离线安装依赖库</a></li><li><a href="/2021/12/Python%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%96%87%E4%BB%B6%E8%A1%8C%E6%95%B0%E6%96%B9%E6%B3%95%E5%8F%8A%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83/" rel="bookmark" title="Python计算大文件行数方法及性能比较">Python计算大文件行数方法及性能比较</a></li><li><a href="/2021/12/Python%E5%AE%9E%E7%8E%B0%E5%AF%B9%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E5%A2%9E%E9%87%8F%E8%AF%BB%E5%8F%96/" rel="bookmark" title="Python实现对大文件的增量读取">Python实现对大文件的增量读取</a></li><li><a href="/2022/5/Pandas%E6%9D%A1%E4%BB%B6%E5%AE%9A%E4%BD%8D%E5%8D%95%E5%85%83%E6%A0%BC%E3%80%90%E7%B1%BB%E4%BC%BCSQL%E6%9F%A5%E8%AF%A2%E3%80%91/" rel="bookmark" title="Pandas条件定位单元格【类似select 字段 from 表 where 其他字段=某值】">Pandas条件定位单元格【类似select 字段 from 表 where 其他字段=某值】</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="黑麋鹿" data-src="/images/avatar.jpg"><p class="name" itemprop="name">黑麋鹿</p><div class="description" itemprop="description">折腾之路</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">178</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">36</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">90</span> <span class="name">标签</span></a></div></nav><div class="social"><a href="https://github.com/sirliu" title="https:&#x2F;&#x2F;github.com&#x2F;sirliu" class="item github" rel="noopener" target="_blank"><i class="ic i-github"></i></a> <a href="https://twitter.com/" title="https:&#x2F;&#x2F;twitter.com&#x2F;" class="item twitter" rel="noopener" target="_blank"><i class="ic i-twitter"></i></a> <a href="https://www.zhihu.com/" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;" class="item zhihu" rel="noopener" target="_blank"><i class="ic i-zhihu"></i></a> <a href="https://music.163.com/" title="https:&#x2F;&#x2F;music.163.com&#x2F;" class="item music" rel="noopener" target="_blank"><i class="ic i-cloud-music"></i></a> <a href="https://weibo.com/" title="https:&#x2F;&#x2F;weibo.com&#x2F;" class="item weibo" rel="noopener" target="_blank"><i class="ic i-weibo"></i></a> <a href="mailto:yourname@mail.com" title="mailto:yourname@mail.com" class="item email" rel="noopener" target="_blank"><i class="ic i-envelope"></i></a> <a href="https://www.facebook.com/" title="https:&#x2F;&#x2F;www.facebook.com&#x2F;" class="item facebook" rel="noopener" target="_blank"><i class="ic i-facebook"></i></a> <a href="https://stackoverflow.com/" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;" class="item stackoverflow" rel="noopener" target="_blank"><i class="ic i-stack-overflow"></i></a> <a href="https://www.youtube.com/" title="https:&#x2F;&#x2F;www.youtube.com&#x2F;" class="item youtube" rel="noopener" target="_blank"><i class="ic i-youtube"></i></a> <a href="https://instagram.com/" title="https:&#x2F;&#x2F;instagram.com&#x2F;" class="item instagram" rel="noopener" target="_blank"><i class="ic i-instagram"></i></a> <a href="skype:yourname?call|chat" title="skype:yourname?call|chat" class="item skype" rel="noopener" target="_blank"><i class="ic i-skype"></i></a> <a href="https://www.douban.com/" title="https:&#x2F;&#x2F;www.douban.com&#x2F;" class="item douban" rel="noopener" target="_blank"><i class="ic i-douban"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2021/11/%E6%92%B8%E9%A3%9E%E9%B8%9F%E5%8A%A0%E9%80%9F%E5%99%A8/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2021/11/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3%20Python%E4%B8%AD%20%E7%9A%84%20async-await%20%E6%A6%82%E5%BF%B5/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">黑麋鹿 @ Black Elk</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">729k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">11:03</span></div><div class="powered-by">基于 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & Theme.<a href="https://github.com/amehime/hexo-theme-shoka" rel="noopener" target="_blank">Shoka</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2021/11/python3异步编程async/await原理解释的比较详细的文章/",favicon:{show:"BlackELK",hide:"看看再走吧"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->